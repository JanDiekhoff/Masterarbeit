[["-- Check if in given table of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n-- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\nlocal function has_close_elements(numbers, threshold)\n    for i = 1, #numbers do\n        if (numbers[i] < threshold) or (numbers[i] > 1.0 - threshold) then\n            return false\n        end\n    end\n    return true\nend\n"], ["-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the table of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- {'()', '(())', '(()())'}\nlocal function separate_paren_groups(paren_string)\n    local groups = {}\n    local open_brace = 0\n    for i = 1, #paren_string do\n        if paren_string:sub(i, i) == '(' then\n            open_brace = i\n        end\n    end\n    for i = 1, #paren_string do\n        if paren_string:sub(i, i) == '(' then\n            groups[open_brace] = groups[open_brace] or {}\n            groups[open_brace][#groups[open_brace] + 1] = paren_string:sub(open_brace, i - 1)\n        end\n    end\n    return groups\nend"], ["-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n    local decimal_part = math.floor(number)\n    return decimal_part\nend"], ["-- You're given a table of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return true. Otherwise it should return false.\n-- >>> below_zero({1, 2, 3})\n-- false\n-- >>> below_zero({1, 2, -4, 5})\n-- true\nlocal function below_zero(operations)\n    -- check if balance is zero\n    if operations[1] == 0 then\n        return true\n    end\n    -- check if balance is negative\n    for i = 2, #operations do\n        if operations[i] < 0 then\n            return true\n        end\n    end\n    return false\nend"], ["-- For a given table of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n-- 1.0\nlocal function mean_absolute_deviation(numbers)\n    local mean = mean(numbers)\n    local deviation = 0.0\n    for i = 1, #numbers do\n        deviation = deviation + math.abs(numbers[i] - mean)\n    end\n    return deviation / #numbers\nend"], ["-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1, 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n    return map(numbers, function(i) return i == delimeter and 0 or i + delimeter end)\nend\n"], ["-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n-- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n    local stack = {}\n    local level = 0\n    for i = 1, #paren_string do\n        local char = string.sub(paren_string, i, i)\n        if char == '(' then\n            level = level + 1\n        elseif char == ')' then\n            level = level - 1\n        elseif char == '(' then\n            push(stack, level)\n        elseif char == ')' then\n            if level == 0 then\n                return stack\n            else\n                local top = pop(stack)\n                if top == level then\n                    return top\n                else\n                    return nil\n                end\n            end\n        end\n    end\nend"], ["-- Filter an input table of strings only for ones that contain given substring\n-- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings, substring)"], ["-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product({})\n-- {0, 1}\n-- >>> sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n    local result = {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i] * (i - 1))\n    end\n    return result\nend"], ["-- From a given table of integers, generate a table of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n    local max = {}\n    for i = 1, #numbers do\n        if #max == 0 then\n            max[1] = numbers[i]\n        else\n            local j = #max\n            if max[j] < numbers[i] then\n                max[j] = numbers[i]\n            end\n        end\n    end\n    return max\nend"], ["-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n    local prefix = string:sub(1, string:len() - 1)\n    local suffix = string:sub(1, string:len() - 1)\n    if string:sub(string:len() - 1, string:len() - 1) == string:sub(1, string:len() - 1) then\n        return string\n    end\n    local postfix = make_palindrome(string:sub(1, string:len() - 1))\n    return string:sub(1, string:len() - 1) .. string:sub(string:len() - 1, string:len() - 1) .. postfix\nend\n"], ["-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010', '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n    for i = 1, #a do\n        result = result .. string.sub(a, i, i) .. string.sub(b, i, i)\n    end\n    return result\nend"], ["-- Out of table of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return nil in case the input table is empty.\n-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n-- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n    if not strings then return nil\n    local max = -1\n    for _, s in ipairs(strings) do\n        if s > max then\n            max = s\n        end\n    end\n    return max\nend\n"], ["-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a, b)\n    local result = 1\n    local x = 0\n    local y = 0\n    while b > 0 do\n        if b % 2 == 1 then\n            x = x * 2 + 1\n        else\n            x = x * 2\n        end\n        b = b / 2\n    end\n    while a > 0 do\n        if a % 2 == 1 then\n            y = y * 2 + 1\n        else\n            y = y * 2\n        end\n        a = a / 2\n    end\n    if x > y then\n        return x\n    else\n        return y\n    end\nend\n"], ["-- Return table of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes('abc')\n-- {'a', 'ab', 'abc'}\nlocal function all_prefixes(string)\n    local prefixes = {}\n    for i = 1, #string do\n        local prefix = string:sub(i, i)\n        if not prefixes[prefix] then\n            prefixes[prefix] = true\n        end\n    end\n    return prefixes\nend\n"], ["-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence(0)\n-- '0'\n-- >>> string_sequence(5)\n-- '0 1 2 3 4 5'\nlocal function string_sequence(n)\n    local s = \"\"\n    for i = 1, n do\n        s = s .. string.char(math.random(97, 122))\n    end\n    return s\nend\n"], ["-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n-- 4\nlocal function count_distinct_characters(string)\n    local count = 0\n    for i = 1, #string do\n        if string:sub(i, i) == string:sub(i, i) then\n            count = count + 1\n        end\n    end\n    return count\nend\n"], ["-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return table of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nlocal function parse_music(music_string)\n    local music_table = {}\n    local music_table_size = 0\n    local music_table_index = 0\n    local music_table_beats = {}\n    local music_table_beats_size = 0\n    local music_table_beats_index = 0\n    for music_string_index = 1, #music_string do\n        local music_string_char = music_string:sub(music_string_index, music_string_index)\n        if music_string_char == 'o' then\n            music_table_beats[music_table_index] = music_table_beats[music_table_index] + 1\n            music_table_beats_size = music_table_beats_size + 1\n        elseif music_string_char == '|' then\n            music_table_beats[music_table_index] = music_table_beats[music_table_index] + 1\n            music_table_beats_size = music_table_beats_size + 1\n        elseif music_string_char == '.' then\n            music_table_beats[music_table_index] = music_table_beats[music_table_index] + 1\n            music_table_beats_size = music_table_beats_size + 1\n        end\n        music_table_index = music_table_index + 1\n    end\n    for music_table_"], ["-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa', 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string, substring)\n    local count = 0\n    for i = 1, #string do\n        if string:sub(i, i) == substring then\n            count = count + 1\n        end\n    end\n    return count\nend"], ["-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers('three one five')\n-- 'one three five'\nlocal function sort_numbers(numbers)\n    -- Create an empty array to store the sorted numbers\n    local sorted_numbers = {}"], ["-- From a supplied table of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n-- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n-- {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n    -- Sort the numbers in ascending order.\n    local sorted_numbers = sort(numbers)"], ["-- Given table of numbers (of at least two elements), apply a linear transform to that table,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25, 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n    local rescaled = {}\n    for i, number in ipairs(numbers) do\n        rescaled[i] = number * 1.0 / math.max(number, 0.0)\n    end\n    return rescaled\nend\n"], ["-- Filter given table of any luathon values only for integers\n-- >>> filter_integers({'a', 3.14, 5})\n-- {5}\n-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})\n-- {1, 2, 3}\nlocal function filter_integers(values)\n    local function filter_value(value)\n        return value and value in values\n    end\n    return filter(filter_value, values)\nend\n"], ["-- Return length of given string\n-- >>> strlen('')\n-- 0\n-- >>> strlen('abc')\n-- 3\nlocal function strlen(string)\n    local len = 0\n    for i = 1, #string do\n        if string:sub(i, i) == ' ' then\n            len = len + 1\n        end\n    end\n    return len\nend"], ["-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor(15)\n-- 5\nlocal function largest_divisor(n)\n    local divisors = {}\n    for i = 1, n do\n        if n % i == 0 then\n            table.insert(divisors, i)\n        end\n    end\n    return table.max(divisors)\nend"], ["-- Return table of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be tableed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n-- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n    local factors = {}\n    local i = 1\n    while n > 1 do\n        if n % i == 0 then\n            table.insert(factors, i)\n            n = n / i\n        end\n        i = i + 1\n    end\n    return table.concat(factors)\nend\n"], ["-- From a table of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates({1, 2, 3, 2, 4})\n-- {1, 3, 4}\nlocal function remove_duplicates(numbers)\n    -- Create a new array with unique elements.\n    local unique_numbers = {}\n    for _, number in ipairs(numbers) do\n        -- Check if the number is already in the unique_numbers array.\n        if number not in unique_numbers then\n            -- Add the number to the unique_numbers array.\n            unique_numbers[#unique_numbers+1] = number\n        end\n    end\n    -- Return the unique_numbers array.\n    return unique_numbers\nend\n```"], ["-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case('Hello')\n-- 'hELLO'\nlocal function flip_case(string)\n    return string:gsub('[a-z]', function(c)\n        return c:upper()\n    end)\nend"], ["-- Concatenate table of strings into a single string\n-- >>> concatenate({})\n-- ''\n-- >>> concatenate({'a', 'b', 'c'})\n-- 'abc'\nlocal function concatenate(strings)\n    local result = {}\n    for i, string in ipairs(strings) do\n        table.insert(result, string)\n    end\n    return result\nend\n"], ["-- Filter an input table of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc', 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings, prefix)"], ["-- Return only positive numbers in the table.\n-- >>> get_positive({-1, 2, -4, 5, 6})\n-- {2, 5, 6}\n-- >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- {5, 3, 2, 3, 9, 123, 1}\nlocal function get_positive(l)\n    local result = {}\n    for i, v in ipairs(l) do\n        if v > 0 then\n            table.insert(result, v)\n        end\n    end\n    return result\nend"], ["-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime(6)\n-- false\n-- >>> is_prime(101)\n-- true\n-- >>> is_prime(11)\n-- true\n-- >>> is_prime(13441)\n-- true\n-- >>> is_prime(61)\n-- true\n-- >>> is_prime(4)\n-- false\n-- >>> is_prime(1)\n-- false\nlocal function is_prime(n)\n    if n <= 1 then\n        return false\n    end\n    if n <= 3 then\n        return true\n    end\n    if n % 2 == 0 then\n        return false\n    end\n    if n % 3 == 0 then\n        return false\n    end\n    for i = 5, (sqrt(n) + 2), 2 do\n        if n % i == 0 then\n            return false\n        end\n    end\n    return true\nend\n"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal function sort_third(l)\n    local n = #l\n    for i = 1, n do\n        for j = i+1, n do\n            if l[i] % 3 == 0 and l[j] % 3 == 0 and l[i] < l[j] then\n                l[i], l[j] = l[j], l[i]\n            end\n        end\n    end\n    return l\nend"], ["-- Return sorted unique elements in a table\n-- >>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nlocal function unique(l)\n    local res = {}\n    for i = 1, #l do\n        if not res[l[i]] then\n            res[l[i]] = true\n        end\n    end\n    return res\nend\n"], ["-- Return maximum element in the table.\n-- >>> max_element({1, 2, 3})\n-- 3\n-- >>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- 123\nlocal function max_element(l)\n    local max = 0\n    local i = 1\n    for j = 1, #l do\n        if l[j] > max then\n            max = l[j]\n        end\n        i = i + 1\n    end\n    return max\nend"], ["-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n-- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n    if n % 3 == 0 then\n        return \"fizz\"\n    elseif n % 5 == 0 then\n        return \"buzz\"\n    else\n        return n\n    end\nend\n"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function sort_even(l)\n    local even_indices = {}\n    for i = 1, #l do\n        if l[i] % 2 == 0 then\n            table.insert(even_indices, i)\n        end\n    end\n    local odd_indices = {}\n    for i = 1, #l do\n        if l[i] % 2 == 1 then\n            table.insert(odd_indices, i)\n        end\n    end\n    local sorted_l = {}\n    for i = 1, #l do\n        if i % 2 == 0 then\n            table.insert(sorted_l, l[i])\n        else\n            table.insert(sorted_l, l[i] + 1)\n        end\n    end\n    return table.concat(sorted_l, even_indices)\nend"], ["-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n-- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n    if n <= 1 then\n        return n\n    elseif n <= 3 then\n        return 2\n    elseif n % 2 == 0 then\n        return 2\n    else\n        return fib(n - 1) + fib(n - 2)\n    end\nend\n"], ["-- triples_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are three distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1, 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n-- false\nlocal function triples_sum_to_zero(l)\n    if length(l) == 0 then\n        return false\n    end\n    local sum = 0\n    for i = 1, length(l) do\n        sum = sum + l[i]\n    end\n    if sum == 0 then\n        return true\n    else\n        return false\n    end\nend"], ["-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\nlocal function car_race_collision(n)\n    local cars = {}\n    for i = 1, n do\n        cars[i] = {0, 0}\n    end\n    for i = 1, n do\n        for j = 1, n do\n            if i ~= j then\n                cars[i][1] = cars[i][1] + 1\n                cars[j][1] = cars[j][1] + 1\n            end\n        end\n    end\n    local count = 0\n    for i = 1, n do\n        for j = 1, n do\n            if cars[i][1] > cars[j][1] then\n                count = count + 1\n            end\n        end\n    end\n    return count\nend\n```"], ["-- Return table with elements incremented by 1.\n-- >>> incr_list({1, 2, 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4, 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n    for i = 1, #l do\n        l[i] = l[i] + 1\n    end\n    return l\nend"], ["-- pairs_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are two distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1, 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n-- false\nlocal function pairs_sum_to_zero(l)\n    if length(l) == 0 then\n        return false\n    end\n    local sum = 0\n    for i = 1, length(l) do\n        sum = sum + l[i]\n    end\n    if sum == 0 then\n        return true\n    else\n        return false\n    end\nend"], ["-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base(8, 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n-- '111'\nlocal function change_base(x, base)\n    if x == 0 then\n        return '0'\n    elseif x == 1 then\n        return '1'\n    elseif x == 2 then\n        return '2'\n    elseif x == 3 then\n        return '3'\n    elseif x == 4 then\n        return '4'\n    elseif x == 5 then\n        return '5'\n    elseif x == 6 then\n        return '6'\n    elseif x == 7 then\n        return '7'\n    elseif x == 8 then\n        return '8'\n    elseif x == 9 then\n        return '9'\n    else\n        return 'Error: x is not a number'\n    end\nend"], ["-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area(5, 3)\n-- 7.5\nlocal function triangle_area(a, h)\n    return (a * h) / 2\nend\n"], ["-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4(5)\n-- 4\n-- >>> fib4(6)\n-- 8\n-- >>> fib4(7)\n-- 14\nlocal function fib4(n)\n    if n == 0 then\n        return 0\n    end\n    if n == 1 then\n        return 0\n    end\n    if n == 2 then\n        return 2\n    end\n    if n == 3 then\n        return 0\n    end\n    if n == 4 then\n        return 0\n    end\n    local a, b, c, d\n    a = 0\n    b = 0\n    c = 0\n    d = 0\n    for i = 1, n do\n        a = a + b\n        b = a + c\n        c = a + d\n    end\n    return a\nend"], ["-- Return median of elements in the table l.\n-- >>> median({3, 1, 2, 4, 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n    local sorted = sort(l)\n    if #sorted == 1 then\n        return sorted[1]\n    elseif #sorted == #l then\n        return sorted[#sorted]\n    else\n        return (sorted[#sorted] + sorted[#sorted-1]) / 2\n    end\nend\n"], ["-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- true\n-- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n-- >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n    local reversed_text = text:reverse()\n    return text == reversed_text\nend"], ["-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n-- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 1 then\n        return n\n    else\n        return (n % p) + modp(n, p - 1)\n    end\nend\n"], ["-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels('')\n-- ''\n-- >>> remove_vowels('abcdef')\n-- 'bcdf'\n-- >>> remove_vowels('aaaaa')\n-- ''\n-- >>> remove_vowels('aaBAA')\n-- 'B'\n-- >>> remove_vowels('zbcd')\n-- 'zbcd'\nlocal function remove_vowels(text)\n    local vowels = { 'a', 'e', 'i', 'o', 'u' }\n    return text:gsub(vowels, function(c) return '' end)\nend\n"], ["-- Return true if all numbers in the table l are below threshold t.\n-- >>> below_threshold({1, 2, 4, 10}, 100)\n-- true\n-- >>> below_threshold({1, 20, 4, 10}, 5)\n-- false\nlocal function below_threshold(l, t)\n    for i = 1, #l do\n        if l[i] < t then\n            return false\n        end\n    end\n    return true\nend\n"], ["-- Add two numbers x and y\n-- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n    return x + y\nend"], ["-- Check if two words have the same characters.\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n-- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n-- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n    local s0_chars = {}\n    local s1_chars = {}\n    for i = 1, #s0 do\n        local c0 = s0:sub(i, i)\n        local c1 = s1:sub(i, i)\n        if c0 == c1 then\n            s0_chars[i] = c0\n        else\n            s1_chars[i] = c1\n        end\n    end\n    return s0_chars == s1_chars\nend"], ["-- Return n-th Fibonacci number.\n-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n-- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n    if n <= 1 then\n        return n\n    end\n    return fib(n-1) + fib(n-2)\nend\n"], ["-- brackets is a string of \"<\" and \">\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('<')\n-- false\n-- >>> correct_bracketing('<>')\n-- true\n-- >>> correct_bracketing('<<><>>')\n-- true\n-- >>> correct_bracketing('><<>')\n-- false\nlocal function correct_bracketing(brackets)\n    local open_brackets = {}\n    for i = 1, #brackets do\n        if brackets[i] == '(' then\n            open_brackets[#open_brackets+1] = brackets[i]\n        elseif brackets[i] == ')' then\n            if #open_brackets > 0 then\n                open_brackets[#open_brackets-1] = brackets[i]\n            end\n        end\n    end\n    for i = 1, #brackets do\n        if brackets[i] == '(' then\n            if #open_brackets > 0 then\n                return false\n            end\n        elseif brackets[i] == ')' then\n            if #open_brackets > 0 then\n                return false\n            end\n        end\n    end\n    return true\nend\n```"], ["-- Return true is table elements are monotonically increasing or decreasing.\n-- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n-- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n    local result = true\n    for i = 1, #l do\n        if not l[i] then\n            result = false\n            break\n        end\n    end\n    return result\nend\n"], ["-- Return sorted unique common elements for two tables.\n-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5, 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n    local res = {}\n    for i = 1, #l1 do\n        if l1[i] ~= nil and l2[i] ~= nil then\n            if l1[i] ~= l2[i] then\n                table.insert(res, l1[i])\n            end\n        end\n    end\n    return res\nend\n"], ["-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n-- 2\nlocal function largest_prime_factor(n)\n    local largest_factor = 1\n    local i = 2\n    while i * i <= n do\n        if n % i == 0 then\n            if n / i > largest_factor then\n                largest_factor = n / i\n            end\n            i = i + 1\n        end\n    end\n    return largest_factor\nend\n"], ["-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n(30)\n-- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n-- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n    if n == 0 then\n        return 0\n    else\n        return n + sum_to_n(n - 1)\n    end\nend\n"], ["-- brackets is a string of \"(\" and \")\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('(')\n-- false\n-- >>> correct_bracketing('()')\n-- true\n-- >>> correct_bracketing('(()())')\n-- true\n-- >>> correct_bracketing(')(()')\n-- false\nlocal function correct_bracketing(brackets)\n    local open_brackets = {}\n    for _, bracket in ipairs(brackets) do\n        if bracket == '(' then\n            table.insert(open_brackets, '(')\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == '{' then\n            table.insert(open_brackets, '{' .. bracket)\n        elseif bracket == '}' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bracket == ')' then\n            table.remove(open_brackets, 1)\n        elseif bra"], ["-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n--  Return derivative of this polynomial in the same form.\n-- >>> derivative({3, 1, 2, 4, 5})\n-- {1, 4, 12, 20}\n-- >>> derivative({1, 2, 3})\n-- {2, 6}\nlocal function derivative(xs)\n    local d = {}\n    for i = 1, #xs do\n        d[i] = xs[i] * i\n    end\n    return d\nend"], ["-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib(1)\n-- 0\n-- >>> fibfib(5)\n-- 4\n-- >>> fibfib(8)\n-- 24\nlocal function fibfib(n)\n    local fibfib_list = {}\n    fibfib_list[0] = 0\n    fibfib_list[1] = 0\n    fibfib_list[2] = 1\n    for i = 3, n do\n        fibfib_list[i] = fibfib_list[i-1] + fibfib_list[i-2] + fibfib_list[i-3]\n    end\n    return fibfib_list[n]\nend"], ["-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count('abcde')\n-- 2\n-- >>> vowels_count('ACEDY')\n-- 3\nlocal function vowels_count(s)\n    local vowels = { 'a', 'e', 'i', 'o', 'u' }\n    local count = 0\n    for i = 1, #s do\n        if s:sub(i, i) in vowels then\n            count = count + 1\n        end\n    end\n    return count\nend\n"], ["-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12, 2)\n-- '12'\nlocal function circular_shift(x, shift)\n    if shift > math.floor(x) then\n        return circular_shift(x, shift - math.floor(x))\n    end\n    return tostring(x) .. tostring(x, shift)\nend\n"], ["-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n-- >>> digitSum('')\n-- 0\n-- >>> digitSum('abAB')\n-- 131\n-- >>> digitSum('abcCd')\n-- 67\n-- >>> digitSum('helloE')\n-- 69\n-- >>> digitSum('woArBld')\n-- 131\n-- >>> digitSum('aAaaaXa')\n-- 153\nlocal function digitSum(s)\n    local sum = 0\n    for i = 1, #s do\n        if s:sub(i, i) == '1' then\n            sum = sum + 1\n        end\n    end\n    return sum\nend"], ["-- In this task, you will be given a string that represents a number of apples and oranges \n-- that are distributed in a basket of fruit this basket contains \n-- apples, oranges, and mango fruits. Given the string that represents the total number of \n-- the oranges and apples and an integer that represent the total number of the fruits \n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- >>> fruit_distribution('5 apples and 6 oranges', 19)\n-- 8\n-- >>> fruit_distribution('0 apples and 1 oranges', 3)\n-- 2\n-- >>> fruit_distribution('2 apples and 3 oranges', 100)\n-- 95\n-- >>> fruit_distribution('100 apples and 1 oranges', 120)\n-- 19\nlocal function fruit_distribution(s, n)\n    local fruit_count = {}\n    for i = 1, #s do\n        local c = string.sub(s, i, i)\n        if c == 'a' then\n            if #fruit_count == 0 then\n                fruit_count[1] = 1\n            else\n                fruit_count[1] = fruit_count[1] + 1\n            end\n        elseif c == 'o' then\n            if #fruit_count == 0 then\n                fruit_count[2] = 1\n            else\n                fruit_count[2] = fruit_count[2] + 1\n            end\n        elseif c == 'm' then\n            if #fruit_count == 0 then\n                fruit_count[3] = 1\n            else\n                fruit_count[3] = fruit_count[3] + 1\n            end\n        end\n    end\n    local mango_count = 0\n    for _, v in pairs(fruit_count) do\n        if v == 2 then\n            mango_count = mango_count + 1\n        end\n    end\n    return mango_count\nend"], ["-- \"Given a table representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a table, [ smalest_value, its index ],\n-- If there are no even values or the given table is empty, return [].\n-- Example 1:\n-- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5, 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there are two zeros,\n--              so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\nlocal function pluck(arr)\n    local even_values = {}\n    local index = {}\n    for i = 1, #arr do\n        if arr[i] % 2 == 0 then\n            table.insert(even_values, arr[i])\n        end\n    end\n    for i = 1, #even_values do\n        table.insert(index, i)\n    end\n    local smallest_value = math.huge\n    local smallest_index = -1\n    for i = 1, #arr do\n        if arr[i] % 2 == 0 then\n            if smallest_value > arr[i] then\n                smallest_value, smallest_index = arr[i], i\n            end\n        end\n   "], ["-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than \n-- zero, and has a frequency greater than or equal to the value of the integer itself. \n-- The frequency of an integer is the number of times it appears in the table.\n-- If no such a value exist, return -1.\n-- Examples:\n-- >>> search({4, 1, 2, 2, 3, 1})\n-- 2\n-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})\n-- 3\n-- >>> search({5, 5, 4, 4, 4})\n-- -1\nlocal function search(lst)\n    local max_freq = 0\n    for i, v in ipairs(lst) do\n        if v > 0 then\n            max_freq = math.max(max_freq, v)\n        end\n    end\n    for i, v in ipairs(lst) do\n        if v == max_freq then\n            return i\n        end\n    end\n    return -1\nend\n```"], ["-- Given table of integers, return table in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n-- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>> strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n    local min = math.min(lst)\n    local max = math.max(lst)\n    for i = 1, #lst do\n        lst[i] = math.min(lst[i], max)\n    end\n    return lst\nend\n"], ["-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater \n-- than the third side.\n-- Example:\n-- >>> triangle_area(3, 4, 5)\n-- 6.0\n-- >>> triangle_area(1, 2, 10)\n-- -1\nlocal function triangle_area(a, b, c)\n    if a == b || b == c || c == a then\n        return 0.0\n    end\n    if a > b + c and b > a + c and c > a + b then\n        return (b * c) / 2\n    end\n    return -1\nend\n"], ["-- Write a function that returns true if the object q will fly, and false otherwise.\n-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- >>> will_it_fly({1, 2}, 5)\n-- false\n-- # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- >>> will_it_fly({3, 2, 3}, 1)\n-- false\n-- # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- >>> will_it_fly({3, 2, 3}, 9)\n-- true\n-- # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- >>> will_it_fly({3}, 5)\n-- true\n-- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function will_it_fly(q, w)\n    local max_weight = math.floor(w / 2)\n    local sum_elements = 0\n    for _, v in ipairs(q) do\n        sum_elements = sum_elements + v\n    end\n    if sum_elements > max_weight then\n        return false\n    end\n    for _, v in ipairs(q) do\n        if v > max_weight then\n            return false\n        end\n    end\n    return true\nend"], ["-- Given a table arr of integers, find the minimum number of elements that\n-- need to be changed to make the table palindromic. A palindromic table is a table that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n-- 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n    local min_change = math.huge\n    for i = 1, #arr do\n        local change = 0\n        for j = i, #arr do\n            change = change + (arr[j] - arr[i])\n        end\n        if change < min_change then\n            min_change = change\n        end\n    end\n    return min_change\nend\n"], ["-- Write a function that accepts two tables of strings and returns the table that has \n-- total number of chars in the all strings of the table less than the other table.\n-- if the two tables have the same number of chars, return the first table.\n-- Examples\n-- >>> total_match({}, {})\n-- {}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'Hi'})\n-- {'hI', 'Hi'}\n-- >>> total_match({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'})\n-- {'hi', 'admin'}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'hi', 'hi'})\n-- {'hI', 'hi', 'hi'}\n-- >>> total_match({'4'}, {'1', '2', '3', '4', '5'})\n-- {'4'}\nlocal function total_match(lst1, lst2)\n    local char_count = {}\n    for i, char in ipairs(lst1) do\n        char_count[char] = (char_count[char] or 0) + 1\n    end\n    for i, char in ipairs(lst2) do\n        char_count[char] = (char_count[char] or 0) + 1\n    end\n    local char_count_sum = 0\n    for char, count in pairs(char_count) do\n        char_count_sum = char_count_sum + count\n    end\n    return char_count_sum == 0 and {} or char_count_sum\nend\n"], ["-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100. \n-- Example:\n-- >>> is_multiply_prime(30)\n-- true\n-- 30 = 2 * 3 * 5\nlocal function is_multiply_prime(a)\n    if a < 100 then\n        return true\n    else\n        return false\n    end\nend"], ["-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2, 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3, 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5, 3)\n-- false\nlocal function is_simple_power(x, n)\n    if n == 1 then\n        return x == 1\n    elseif n == 2 then\n        return x == 2\n    elseif n == 3 then\n        return x == 3\n    elseif n == 4 then\n        return x == 4\n    elseif n == 5 then\n        return x == 5\n    elseif n == 6 then\n        return x == 6\n    elseif n == 7 then\n        return x == 7\n    elseif n == 8 then\n        return x == 8\n    elseif n == 9 then\n        return x == 9\n    elseif n == 10 then\n        return x == 10\n    elseif n == 11 then\n        return x == 11\n    elseif n == 12 then\n        return x == 12\n    elseif n == 13 then\n        return x == 13\n    elseif n == 14 then\n        return x == 14\n    elseif n == 15 then\n        return x == 15\n    elseif n == 16 then\n        return x == 16\n    elseif n == 17 then\n        return x == 17\n    elseif n == 18 then\n        return x == 18\n    elseif n == 19 then\n        return x == 19\n    elseif n == 20 then\n        return x == 20\n    elseif n =="], ["-- Write a function that takes an integer a and returns true \n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- >>> iscube(1)\n-- true\n-- >>> iscube(2)\n-- false\n-- >>> iscube(-1)\n-- true\n-- >>> iscube(64)\n-- true\n-- >>> iscube(0)\n-- true\n-- >>> iscube(180)\n-- false\nlocal function iscube(a)\n    if a == 0 then\n        return true\n    elseif a % 2 == 0 then\n        return false\n    else\n        return iscube(a/2)\n    end\nend"], ["-- You have been tasked to write a function that receives \n-- a hexadecimal number as a string and counts the number of hexadecimal \n-- digits that are primes (prime number, or a prime, is a natural number \n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7, \n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string, \n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>> hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n-- 2\nlocal function hex_key(num)\n    local hex_digits = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, "], ["-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n-- 'db100000db'\nlocal function decimal_to_binary(decimal)\n    local binary = \"\"\n    while decimal > 0 do\n        binary = binary .. string.char(decimal % 2)\n        decimal = decimal / 2\n    end\n    return binary\nend"], ["-- You are given a string s.\n-- Your task is to check if the string is haplua or not.\n-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- >>> is_happy('a')\n-- false\n-- >>> is_happy('aa')\n-- false\n-- >>> is_happy('abcd')\n-- true\n-- >>> is_happy('aabb')\n-- false\n-- >>> is_happy('adb')\n-- true\n-- >>> is_happy('xyy')\n-- false\nlocal function is_happy(s)\n    local n = string.len(s)\n    for i = 1, n do\n        if string.sub(s, i, i) == string.sub(s, i, i) then\n            return false\n        end\n    end\n    return true\nend"], ["-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a table of GPAs for some students and you have to write \n-- a function that can output a table of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A \n--         > 3.3                A- \n--         > 3.0                B+\n--         > 2.7                B \n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+ \n--         > 0.7                D \n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})\n-- {'A+', 'B', 'C-', 'C', 'A-'}\nlocal function numerical_letter_grade(grades)\n    local function numerical_letter_grade(grades)\n        local gpa = 0\n        for i = 1, #grades do\n            gpa = gpa + grades[i]\n        end\n        if gpa >= 4.0 then\n            return {4, 3, 1, 2, 3}\n        elseif gpa >= 3.7 then\n            return {3, 2, 1, 2, 3}\n        elseif gpa >= 3.3 then\n            return {3, 2, 1, 2, 3}\n        elseif gpa >= 3.0 then\n            return {3, 2, 1, 2, 3}\n        elseif gpa >= 2.7 then\n            return {2, 1, 1, 2, 3}\n        elseif gpa >= "], ["-- Write a function that takes a string and returns true if the string\n-- length is a prime number or false otherwise\n-- Examples\n-- >>> prime_length('Hello')\n-- true\n-- >>> prime_length('abcdcba')\n-- true\n-- >>> prime_length('kittens')\n-- true\n-- >>> prime_length('orange')\n-- false\nlocal function prime_length(string)\n    if string == \"\" then\n        return false\n    end\n    if string == \" \" then\n        return true\n    end\n    local length = string:len()\n    for i = 2, length do\n        if string:sub(i, i) == string:sub(i, 1) then\n            return false\n        end\n    end\n    return true\nend"], ["-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n    local res = {}\n    for i = 1, n do\n        if i % 2 == 1 then\n            table.insert(res, i)\n        end\n        if i % 2 == 0 then\n            table.insert(res, i)\n        end\n    end\n    return res\nend\n"], ["-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n-- >>> solve(1000)\n-- '1'\n-- >>> solve(150)\n-- '110'\n-- >>> solve(147)\n-- '1100'\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nlocal function solve(N)\n    local a = \"\"\n    for i = 1, N do\n        local b = \"\"\n        for j = 1, N do\n            if i == j then\n                b = \"1\"\n            else\n                b = \"0\"\n            end\n            a = a .. b\n        end\n    end\n    return a\nend\n"], ["-- Given a non-empty table of integers lst. add the even elements that are at odd indices..\n-- Examples:\n-- >>> add({4, 2, 6, 7})\n-- 2\nlocal function add(lst)\n    for i = 1, #lst do\n        if i % 2 == 1 then\n            lst[i] = lst[i] + lst[i - 1]\n        end\n    end\n    return lst\nend\n"], ["-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- >>> anti_shuffle('Hi')\n-- 'Hi'\n-- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n-- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n    local words = {}\n    for i = 1, #s do\n        local word = s:sub(i, i)\n        if word ~= \"\" then\n            table.insert(words, word)\n        end\n    end\n    local new_words = {}\n    for i = 1, #words do\n        local new_word = words[i]\n        for j = 1, #words do\n            if i == j then\n                new_word = new_word .. \" \"\n            end\n        end\n        table.insert(new_words, new_word)\n    end\n    return new_words\nend"], ["-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local row = {}\n    for i = 1, #lst do\n        local row_i = lst[i]\n        local row_x = x\n        for j = 1, #row_i do\n            row[j] = row_i[j]\n        end\n        table.insert(row, row_x)\n    end\n    return row\nend"], ["-- Given a table of non-negative integers, return a colua of the given table after sorting,\n-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given table.\n-- Examples:\n-- >>> sort_array({})\n-- {}\n-- >>> sort_array({5})\n-- {5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5})\n-- {0, 1, 2, 3, 4, 5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})\n-- {6, 5, 4, 3, 2, 1, 0}\nlocal function sort_array(array)\n    if array == {} then\n        return {}\n    end\n    if array == {1} then\n        return {1}\n    end\n    if array == {1, 2} then\n        return {1, 2}\n    end\n    if array == {1, 2, 3} then\n        return {1, 2, 3}\n    end\n    if array == {1, 2, 3, 4} then\n        return {1, 2, 3, 4}\n    end\n    if array == {1, 2, 3, 4, 5} then\n        return {1, 2, 3, 4, 5}\n    end\n    if array == {1, 2, 3, 4, 5, 6} then\n        return {1, 2, 3, 4, 5, 6}\n    end\n    if array == {1, 2, 3, 4, 5, 6, 7} then\n        return {1, 2, 3, 4, 5, 6, 7}\n    end\n    if array == {1, 2, 3, 4, 5, 6, 7"], ["-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated. \n-- The alphabet should be rotated in a manner such that the letters \n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n-- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal function encrypt(s)\n    local alphabet = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '+', ',', '-', '.', '/', '?', '=', ':', ';', '<', '>', '?', '!', '[', ']', '{', '}', '|', '\\\\', '}', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', ']', '[', '"], ["-- You are given a table of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the table.\n-- Return nil if there is no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5, 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1, 1})\n-- None\nlocal function next_smallest(lst)\n    local min = lst[1]\n    for i = 2, #lst do\n        if lst[i] < min then\n            min = lst[i]\n        end\n    end\n    return min\nend"], ["-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored('Hello world')\n-- 0\n-- >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n-- 1\nlocal function is_bored(S)\n    local boredom_count = 0\n    for i = 1, #S do\n        if S:sub(i, i) == 'I' then\n            boredom_count = boredom_count + 1\n        end\n    end\n    return boredom_count\nend"], ["-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- >>> any_int(5, 2, 7)\n-- true\n-- >>> any_int(3, 2, 2)\n-- false\n-- >>> any_int(3, -2, 1)\n-- true\n-- >>> any_int(3.6, -2.2, 2)\n-- false\nlocal function any_int(x, y, z)\n    if x == z or x == y or x == y then\n        return true\n    else\n        return false\n    end\nend"], ["-- Write a function that takes a message, and encodes in such a \n-- way that it swaps case of all letters, replaces all vowels in \n-- the message with the letter that appears 2 places ahead of that \n-- vowel in the english alphabet. \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n-- >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n    local vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' }\n    local letters = {}\n    for i = 1, #message do\n        local char = message:sub(i, i)\n        if char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i] = vowels[i]\n        elseif char == ' ' then\n            letters[i"], ["-- You are given a table of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- >>> skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n-- >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n-- 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0, 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n    local max_prime = 0\n    local sum_digits = 0\n    for i = 1, #lst do\n        if lst[i] == 1 then\n            sum_digits = sum_digits + 1\n        else\n            local prime = 0\n            for j = 1, math.floor(math.sqrt(sum_digits)) do\n                if sum_digits % j == 0 then\n                    prime ="], ["-- Given a table, return true if all keys are strings in lower \n-- case or all keys are strings in upper case, else return false.\n-- The function should return false is the given table is empty.\n-- Examples:\n-- >>> check_dict_case({['a'] = 'apple', ['b'] = 'banana'})\n-- true\n-- >>> check_dict_case({['a'] = 'apple', ['A'] = 'banana', ['B'] = 'banana'})\n-- false\n-- >>> check_dict_case({['a'] = 'apple', [8] = 'banana', ['a'] = 'apple'})\n-- false\n-- >>> check_dict_case({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'})\n-- false\n-- >>> check_dict_case({['STATE'] = 'NC', ['ZIP'] = '12345'})\n-- true\nlocal function check_dict_case(dict)\n    if not dict then\n        return false\n    end\n    local case_dict = {}\n    for key, value in pairs(dict) do\n        if type(value) == 'table' then\n            case_dict[key] = check_dict_case(value)\n        else\n            case_dict[key] = value\n        end\n    end\n    if case_dict == {} then\n        return false\n    end\n    return true\nend\n"], ["-- Implement a function that takes an non-negative integer and returns a table of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- >>> count_up_to(5)\n-- {2, 3}\n-- >>> count_up_to(11)\n-- {2, 3, 5, 7}\n-- >>> count_up_to(0)\n-- {}\n-- >>> count_up_to(20)\n-- {2, 3, 5, 7, 11, 13, 17, 19}\n-- >>> count_up_to(1)\n-- {}\n-- >>> count_up_to(18)\n-- {2, 3, 5, 7, 11, 13, 17}\nlocal function count_up_to(n)\n    local result = {}\n    for i = 2, n do\n        if is_prime(i) then\n            table.insert(result, i)\n        end\n    end\n    return result\nend"], ["-- Complete the function that takes two integers and returns \n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020, 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n    local product = 1\n    for i = 1, #a do\n        product = product * a[i]\n    end\n    for i = 1, #b do\n        product = product * b[i]\n    end\n    return product\nend"], ["-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- >>> count_upper('aBCdEf')\n-- 1\n-- >>> count_upper('abcdefg')\n-- 0\n-- >>> count_upper('dBBE')\n-- 0\nlocal function count_upper(s)\n    local count = 0\n    for i = 1, #s do\n        if s:sub(i, i) == 'u' then\n            count = count + 1\n        end\n    end\n    return count\nend\n"], ["-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n-- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local integer_value = math.floor(value)\n    if integer_value == value then\n        return integer_value\n    elseif integer_value == value - 1 then\n        return integer_value - 1\n    elseif integer_value == value + 1 then\n        return integer_value + 1\n    end\nend"], ["-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a table, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n-- {3, 5, 7}\nlocal function make_a_pile(n)\n    local table = {}\n    for i=1,n do\n        table[i] = 0\n    end\n    table[1] = 1\n    return table\nend\n"], ["-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return a table of the words.\n-- For example:\n-- >>> words_string('Hi, my name is John')\n-- {'Hi', 'my', 'name', 'is', 'John'}\n-- >>> words_string('One, two, three, four, five, six')\n-- {'One', 'two', 'three', 'four', 'five', 'six'}\nlocal function words_string(s)\n    local words = {}\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if c == ' ' then\n            table.insert(words, c)\n        else\n            table.insert(words, c)\n            table.insert(words, c)\n        end\n    end\n    return table.concat(words)\nend"], ["-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If \n-- there's no such number, then the function should return -1.\n-- For example:\n-- >>> choose_num(12, 15)\n-- 14\n-- >>> choose_num(13, 12)\n-- -1\nlocal function choose_num(x, y)\n    local num = 0\n    for i = x, y do\n        if math.floor(math.random() * (y - x + 1)) % 2 == 0 then\n            num = num + 1\n        end\n    end\n    if num > 0 then\n        return num\n    else\n        return -1\n    end\nend"], ["-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m). \n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7, 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n-- '0b11010'\nlocal function rounded_avg(n, m)\n    local result = 0\n    local sum = 0\n    for i = n, m do\n        sum = sum + i\n        result = result + math.floor(sum / i)\n    end\n    return result\nend"], ["-- Given a table of positive integers x. return a sorted table of all \n-- elements that hasn't any even digit.\n-- Note: Returned table should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits({15, 33, 1422, 1})\n-- {1, 15, 33}\n-- >>> unique_digits({152, 323, 1422, 10})\n-- {}\nlocal function unique_digits(x)\n    local unique = {}\n    for i, v in ipairs(x) do\n        if not unique[v] then\n            unique[v] = true\n        end\n    end\n    return table.sort(unique)\nend\n"], ["-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting table, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})\n-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}\n--   If the table is empty, return an empty table:\n-- >>> by_length({})\n-- {}\n--   If the table has any strange number ignore it:\n-- >>> by_length({1, -1, 55})\n-- {'One'}\nlocal function by_length(arr)\n    local result = {}\n    for i = 1, #arr do\n        local num = arr[i]\n        if num == 0 then\n            result[i] = \"One\"\n        elseif num == 1 then\n            result[i] = \"Two\"\n        elseif num == 2 then\n            result[i] = \"Three\"\n        elseif num == 3 then\n            result[i] = \"Four\"\n        elseif num == 4 then\n            result[i] = \"Five\"\n        elseif num == 5 then\n            result[i] = \"Six\"\n        elseif num == 6 then\n            result[i] = \"Seven\"\n        elseif num == 7 then\n            result[i] = \"Eight\"\n        elseif num == 8 then\n            result[i] = \"Nine\"\n        else\n            result[i] = \"One\"\n        end\n    end\n    return result\nend\n"], ["-- Implement the function f that takes n as a parameter,\n-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- >>> f(5)\n-- {1, 2, 6, 24, 15}\nlocal function f(n)\n    local table = {}\n    for i = 1, n do\n        table[i] = 1\n    end\n    for i = 2, n do\n        table[i] = table[i-1] * (i % 2 == 0)\n    end\n    return table\nend"], ["-- Given a positive integer n, return a table that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n-- >>> even_odd_palindrome(3)\n-- {1, 2}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n-- >>> even_odd_palindrome(12)\n-- {4, 6}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned table has the number of even and odd integer palindromes respectively.\nlocal function even_odd_palindrome(n)\n    local even_odd_table = {}\n    for i = 1, n do\n        local even = i % 2 == 0\n        local odd = not i % 2 == 0\n        table.insert(even_odd_table, {even, odd})\n    end\n    return even_odd_table\nend\n"], ["-- Write a function count_nums which takes a table of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums({})\n-- 0\n-- >>> count_nums({-1, 11, -11})\n-- 1\n-- >>> count_nums({1, 1, 2})\n-- 3\nlocal function count_nums(arr)\n    local sum_digits = 0\n    for i = 1, #arr do\n        local num = arr[i]\n        if num > 0 then\n            sum_digits = sum_digits + num\n        end\n    end\n    return sum_digits\nend\n"], ["-- We have a table 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the table will be randomly ordered. Your task is to determine if\n-- it is possible to get a table sorted in non-decreasing order by performing \n-- the following operation on the given table:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the table by one\n-- position in the right direction. The last element of the table will be moved to\n-- the starting position in the table i.e. 0th index. \n-- If it is possible to obtain the sorted table by performing the above operation\n-- then return true else return false.\n-- If the given table is empty then return true.\n-- Note: The given table is guaranteed to have unique elements.\n-- For Example:\n-- >>> move_one_ball({3, 4, 5, 1, 2})\n-- true\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given table.\n-- >>> move_one_ball({3, 5, 4, 1, 2})\n-- false\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             table by performing any number of right shift operations.\nlocal function move_one_ball(arr)\n    local n = #arr\n    for i = 1, n do\n        if arr[i] > arr[i+1] then\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n            return true\n        end\n    end\n    return false\nend\n"], ["-- In this problem, you will implement a function that takes two tables of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a table of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\nlocal function exchange(lst1, lst2)\n    if not lst1 then return \"NO\" end\n    if not lst2 then return \"NO\" end\n    if not lst1:isempty() and not lst2:isempty() then\n        if lst1:nth(1) == lst2:nth(1) then\n            return \"NO\"\n        end\n        if lst1:nth(1) % 2 == 0 then\n            return \"YES\"\n        end\n        for i = 2, #lst1 do\n            if lst1:nth(i) % 2 == 0 then\n                lst1:set(i, lst2:nth(i))\n                return \"YES\"\n            end\n        end\n    end\n    return \"NO\"\nend"], ["-- Given a string representing a space separated lowercase letters, return a table\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- >>> histogram('a b c')\n-- {['a'] = 1, ['b'] = 1, ['c'] = 1}\n-- >>> histogram('a b b a')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('a b c a b')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('b b b b a')\n-- {['b'] = 4}\n-- >>> histogram('')\n-- {}\nlocal function histogram(test)\n    local count = {}\n    for i = 1, 26 do\n        count[i] = 0\n    end\n    for i = 1, #test do\n        local char = test:sub(i, i)\n        count[char] = count[char] + 1\n    end\n    local max_count = 0\n    for char, count in pairs(count) do\n        if count > max_count then\n            max_count = count\n        end\n    end\n    return max_count\nend\n"], ["-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a table containing the result string and true/false for the check.\n-- Example\n-- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n-- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba', 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n    local result = {}\n    for i = 1, #s do\n        if s:sub(i, i) == c then\n            result[i] = true\n        end\n    end\n    return result\nend"], ["-- Given a table of strings, where each string consists of only digits, return a table.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count({'1234567'})\n-- {'the number of odd elements 4n the str4ng 4 of the 4nput.'}\n-- >>> odd_count({'3', '11111111'})\n-- {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'}\nlocal function odd_count(lst)\n    local odd_count_dict = {}\n    for i = 1, #lst do\n        local odd_count = 0\n        for j = 1, #lst do\n            if lst[j] ~= '0' then\n                odd_count = odd_count + 1\n            end\n        end\n        table.insert(odd_count_dict, odd_count)\n    end\n    return odd_count_dict\nend\n"], ["-- Given a table of integers nums, find the minimum sum of any non-empty sub-table\n-- of nums.\n-- Example\n-- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n-- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n    local min_sum = math.huge\n    local max_sum = math.huge\n    for i = 1, #nums do\n        local sum = 0\n        for j = i, #nums do\n            sum = sum + nums[j]\n        end\n        if sum > max_sum then\n            max_sum = sum\n        elseif sum < min_sum then\n            min_sum = sum\n        end\n    end\n    return min_sum\nend\n"], ["-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it, \n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local max_fill_count = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n            local bucket_capacity = capacity\n            if i == 1 and j == 1 then\n                bucket_capacity = 1\n            elseif i == #grid and j == #grid[1] then\n                bucket_capacity = 1\n            elseif i == #grid and j == #grid[1] and bucket_capacity > 0 then\n                bucket_capacity = 1\n            elseif i == #grid and j == #grid[1] and bucket_capacity > 0 and bucket_capacity <= capacity then\n                bucket"], ["-- In this Kata, you have to sort a table of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2, -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n-- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n    -- Sort based on binary representation.\n    local binary_repr = {}\n    for i = 1, #arr do\n        local binary_repr[i] = arr[i]\n    end\n    for i = 1, #arr do\n        local j = binary_repr[i]\n        for k = i+1, #arr do\n            if binary_repr[k] > j then\n                j = binary_repr[k]\n            end\n        end\n        binary_repr[i] = j\n    end\n    -- Sort based on decimal value.\n    local decimal_repr = {}\n    for i = 1, #arr do\n        local decimal_repr[i] = arr[i]\n    end\n    for i = 1, #arr do\n        local j = decimal_repr[i]\n        for k = i+1, #arr do\n            if decimal_repr[k] > j then\n                j = decimal_repr[k]\n            end\n        end\n        decimal_repr[i] = j\n    end\n    -- Return sorted array.\n    return {arr[1], arr[2], ..., arr[#arr]}\nend"], ["-- Given a string s and a natural number n, you have been tasked to implement \n-- a function that returns a table of all words from string s that contain exactly \n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty table.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- >>> select_words('Mary had a little lamb', 4)\n-- {'little'}\n-- >>> select_words('Mary had a little lamb', 3)\n-- {'Mary', 'lamb'}\n-- >>> select_words('simple white space', 2)\n-- {}\n-- >>> select_words('Hello world', 4)\n-- {'world'}\n-- >>> select_words('Uncle sam', 3)\n-- {'Uncle'}\nlocal function select_words(s, n)\n    local words = {}\n    for i = 1, #s do\n        local consonant = s:sub(i, i)\n        if consonant == ' ' then\n            table.insert(words, s:sub(i, i))\n        end\n    end\n    if #words == 0 then\n        return {}\n    end\n    local table_words = {}\n    for _, word in ipairs(words) do\n        table_words[word] = true\n    end\n    for _, word in ipairs(words) do\n        if table_words[word] then\n            table_words[word] = true\n        end\n    end\n    return table_words\nend\n"], ["-- You are given a word. Your task is to find the closest vowel that stands between \n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition. \n-- You may assume that the given string contains English letter only.\n-- Example:\n-- >>> get_closest_vowel('yogurt')\n-- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n-- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'}\n    local vowel_index = 1\n    for i = 1, #word do\n        if word:sub(i, i) ~= consonants[vowel_index] then\n            vowel_index = vowel_index + 1\n        end\n    end\n    return vowel_index\nend"], ["-- You are given a table of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(', ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n    local function helper(lst, i, j)\n        if i == j then\n            return true\n        end\n        if lst[i] == '(' then\n            helper(lst, i + 1, j)\n            helper(lst, i + 1, j + 1)\n            return helper(lst, i, j + 1)\n        else\n            return helper(lst, i + 1, j + 1)\n        end\n    end\n    return helper(lst, 1, #lst)\nend\n"], ["-- Given a table arr of integers and a positive integer k, return a sorted table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>> maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4, 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n-- {2}\n-- Note:\n--     1. The length of the table will be in the range of [1, 1000].\n--     2. The elements in the table will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n    local max_value = -math.huge\n    for i = 1, #arr do\n        if arr[i] > max_value then\n            max_value = arr[i]\n        end\n    end\n    return max_value\nend\n"], ["-- Given a non-empty table of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- >>> solution({5, 8, 7, 1})\n-- 12\n-- >>> solution({3, 3, 3, 3, 3})\n-- 9\n-- >>> solution({30, 13, 24, 321})\n-- 0\nlocal function solution(lst)\n    local n = #lst\n    local sum = 0\n    for i = 1, n do\n        sum = sum + lst[i]\n    end\n    return sum\nend\n"], ["-- Given a non-empty table of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n-- 24\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nlocal function add_elements(arr, k)\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n    return res\nend"], ["-- Given a positive integer n, return a sorted table that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the \n-- previous term as follows: if the previous term is even, the next term is one half of \n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note: \n--     1. Collatz(1) is [1].\n--     2. returned table sorted in increasing order.\n-- For example:\n-- get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n-- >>> get_odd_collatz(5)\n-- {1, 5}\nlocal function get_odd_collatz(n)\n    local odd_collatz = {}\n    odd_collatz[1] = 1\n    local i = 2\n    while i <= n do\n        if i % 2 == 0 then\n            odd_collatz[i] = odd_collatz[i] + 1\n        else\n            odd_collatz[i] = 3 * i + 1\n        end\n        i = i + 1\n    end\n    return odd_collatz\nend\n"], ["-- You have to write a function which validates a given date string and\n-- returns true if the date is valid otherwise false.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- >>> valid_date('03-11-2000')\n-- true\n-- >>> valid_date('15-01-2012')\n-- false\n-- >>> valid_date('04-0-2040')\n-- false\n-- >>> valid_date('06-04-2020')\n-- true\n-- >>> valid_date('06/04/2020')\n-- false\nlocal function valid_date(date)\n    if not string.match(date, '%m-%d-%Y') then\n        return false\n    end\n    local month = string.sub(date, 1, 2)\n    local day = string.sub(date, 3, 4)\n    local year = string.sub(date, 6, 8)\n    local valid = true\n    if month == '01' then\n        valid = valid_month(month) and valid_day(day) and valid_year(year)\n    elseif month == '02' then\n        valid = valid_month(month) and valid_day(day) and not valid_year(year)\n    elseif month == '03' then\n        valid = valid_month(month) and not valid_day(day) and valid_year(year)\n    elseif month == '04' then\n        valid = valid_month(month) and"], ["-- Given a string of words, return a table of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n    local words = {}\n    local i = 1\n    local j = 1\n    while i <= #txt do\n        if i == 1 then\n            words[j] = txt:sub(i, i)\n            j = j + 1\n        else\n            words[j] = words[j] .. txt:sub(i, i)\n            i = i + 1\n        end\n    end\n    return words\nend\n"], ["-- Given a table of numbers, return whether or not they are sorted\n-- in ascending order. If table has more than 1 duplicate of the same\n-- number, return false. Assume no negative numbers and only integers.\n-- Examples\n-- >>> is_sorted({5})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n-- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3, 4})\n-- false\nlocal function is_sorted(lst)\n    if not lst then return false end\n    local sorted = {}\n    for i = 1, #lst do\n        if not sorted[i] then sorted[i] = lst[i] end\n    end\n    for i = 1, #lst do\n        if sorted[i] < lst[i] then\n            return false\n        end\n    end\n    return true\nend\n"], ["-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two \n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1, interval2)\n    local start1, end1, start2, end2 = interval1[1], interval1[2], interval2[1], interval2[2]\n    local length = start2 - start1\n    if length == 0 then\n        return \"NO\"\n    end\n    if length == 1 then\n        return \"YES\"\n    end\n    if length % 2 == 1 then\n        return \"NO\"\n    end\n    local start = start1\n    local end = start2\n    while start <= end do\n        if start1 <= start <= end1 and end2 <= end <= start2 then\n            return \"YES\"\n        end\n        start = start + 1\n        end = end + 1\n    end\n    return \"NO\"\nend"], ["-- You are given a table arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the table, represented by 1, -1 or 0.\n-- Note: return nil for empty arr.\n-- Example:\n-- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n-- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n    if arr == nil then\n        return nil\n    end\n    local product = 1\n    for _, num in ipairs(arr) do\n        product = product * (num > 0)\n    end\n    return product\nend\n"], ["-- Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered tables of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered table of the values on the cells that the minimum path go through.\n-- Examples:    \n-- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid, k)\n    local n = #grid\n    local m = #grid[1]\n    local table = {}\n    for i = 1, n do\n        table[i] = {}\n        for j = 1, m do\n            table[i][j] = 9999999999999999999999999"], ["-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri(1) = 3\n-- tri(n) = 1 + n / 2, if n is even.\n-- tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n-- For example:\n-- tri(2) = 1 + (2 / 2) = 2\n-- tri(4) = 3\n-- tri(3) = tri(2) + tri(1) + tri(4)\n--        = 2 + 3 + 3 = 8 \n-- You are given a non-negative integer number n, you have to a return a table of the \n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- >>> tri(3)\n-- {1, 3, 2, 8}\nlocal function tri(n)\n    local table = {}\n    table[1] = 3\n    for i = 2, n do\n        table[i] = table[i - 1] + table[i - 2] + table[i + 1]\n    end\n    return table\nend"], ["-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- >>> digits(1)\n-- 1\n-- >>> digits(4)\n-- 0\n-- >>> digits(235)\n-- 15\nlocal function digits(n)\n    local res = 0\n    for i = 1, n do\n        res = res + math.floor(n / i)\n    end\n    return res\nend\n"], ["-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return true if and only if there is a valid subsequence of brackets \n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n-- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n-- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal function is_nested(string)\n    local stack = {}\n    for i = 1, #string do\n        local char = string:sub(i, i)\n        if char == '[' then\n            table.insert(stack, char)\n        elseif char == ']' then\n            if table.find(stack, ']') ~= nil then\n                return false\n            end\n            table.remove(stack, 1)\n        end\n    end\n    for i = 1, #string do\n        local char = string:sub(i, i)\n        if char == '[' then\n            table.insert(stack, char)\n        elseif char == ']' then\n            if table.find(stack, ']') ~= nil then\n                return false\n            end\n            table.remove(stack, 1)\n        end\n    end\n    return true\nend"], ["-- You are given a table of numbers.\n-- You need to return the sum of squared numbers in the given table,\n-- round each element in the table to the upper int(Ceiling) first.\n-- Examples:\n-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0, 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n-- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n    local sum = 0\n    for i = 1, #lst do\n        sum = sum + lst[i]^2\n    end\n    return sum\nend"], ["-- Create a function that returns true if the last character\n-- of a given string is an alphabetical character and is not\n-- a part of a word, and false otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n-- Examples:\n-- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>> check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal function check_if_last_char_is_a_letter(txt)\n    local word = \"\"\n    for i = 1, #txt do\n        if txt:sub(i, i) == ' ' then\n            word = word .. txt:sub(i, i)\n        end\n    end\n    return word ~= \"\" and word:match('^[a-z]+$')\nend\n"], ["-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given table will not contain\n-- duplicate values.\n-- Examples:\n-- >>> can_arrange({1, 2, 4, 3, 5})\n-- 3\n-- >>> can_arrange({1, 2, 3})\n-- -1\nlocal function can_arrange(arr)\n    if arr == nil then\n        return -1\n    end\n    local min = arr[1]\n    for i = 2, #arr do\n        if arr[i] < min then\n            min = arr[i]\n        end\n    end\n    return min\nend"], ["-- Create a function that returns a table (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n-- If there is no negative or positive integers, return them as nil.\n-- Examples:\n-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n-- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function largest_smallest_integers(lst)\n    -- Check if the list is empty\n    if not lst then\n        return {None, 0}\n    end"], ["-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return nil if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one(1, 2.5)\n-- 2.5\n-- >>> compare_one(1, '2,3')\n-- '2,3'\n-- >>> compare_one('5,1', '6')\n-- '6'\n-- >>> compare_one('1', 1)\n-- None\nlocal function compare_one(a, b)\n    if a == b then\n        return 0\n    elseif a > b then\n        return 1\n    else\n        return 2\n    end\nend"], ["-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even(4)\n-- false\n-- >>> is_equal_to_sum_even(6)\n-- false\n-- >>> is_equal_to_sum_even(8)\n-- true\nlocal function is_equal_to_sum_even(n)\n    if n % 2 == 0 then\n        return false\n    else\n        return true\n    end\nend\n"], ["-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial(4)\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nlocal function special_factorial(n)\n    if n == 0 then\n        return 1\n    else\n        return n * special_factorial(n-1)\n    end\nend"], ["-- Given a string text, replace all spaces in it with underscores, \n-- and if a string has more than 2 consecutive spaces, \n-- then replace all consecutive spaces with - \n-- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces(' Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n-- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n    local spaces = 0\n    for i = 1, #text do\n        if text:sub(i, i) == ' ' then\n            spaces = spaces + 1\n        end\n    end\n    if spaces > 2 then\n        return text:sub(1, #text) .. '-' .. text:sub(#text, #text)\n    else\n        return text:sub(1, #text) .. ' ' .. text:sub(#text, #text)\n    end\nend\n"], ["-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions \n-- are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from \n-- the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check('example.txt')\n-- 'Yes'\n-- >>> file_name_check('1example.dll')\n-- 'No'\nlocal function file_name_check(file_name)\n    local regex = require('regexp')\n    local valid_name = true\n    local name = file_name\n    local regex_name = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_file_extension = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_dot = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_dot_before_dot = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_dot_after_dot = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_file_extension_before_dot = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_file_extension_after_dot = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_name_before_dot = regex.compile(r'^[a-zA-Z0-9_]+$')\n    local regex_name_after_dot = regex.compile(r'^[a"], ["-- \"\n-- This function will take a table of integers. For all entries in the table, the function shall square the integer entry if its index is a \n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n-- change the entries in the table whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n-- Examples:\n-- >>> lst\n-- {1, 2, 3}\n-- >>> lst\n-- {}\n-- >>> lst\n-- {-1, -5, 2, -1, -5}\nlocal function sum_squares(lst)\n    local result = 0\n    for i = 1, #lst do\n        if i % 3 == 0 then\n            result = result + math.pow(lst[i], 2)\n        elseif i % 4 == 0 then\n            result = result + math.pow(lst[i], 3)\n        end\n    end\n    return result\nend"], ["-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n-- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n--     * 1 <= len(sentence) <= 100\n--     * sentence contains only letters\nlocal function words_in_sentence(sentence)\n    local words = {}\n    local i = 1\n    local j = 1\n    while i <= #sentence do\n        if sentence:sub(i, i) == sentence:sub(j, j) then\n            words[i] = sentence:sub(i, i)\n            i = i + 1\n        elseif sentence:sub(i, i) == ' ' then\n            j = j + 1\n        else\n            words[i] = sentence:sub(i, i)\n            i = i + 1\n        end\n    end\n    local new_sentence = \"\"\n    for k, word in ipairs(words) do\n        new_sentence = new_sentence .. word\n    end\n    return new_sentence\nend"], ["-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns true if x * n evaluates to a whole number and false\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n-- >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\nlocal function simplify(x, n)\n    local numerator, denominator = string.gsub(x, '[/]', ''), string.gsub(n, '[/]', '')\n    if numerator == 0 and denominator == 0 then\n        return true\n    end\n    if numerator == 0 or denominator == 0 then\n        return false\n    end\n    if numerator > 0 and denominator > 0 then\n        numerator, denominator = numerator, denominator\n    end\n    if numerator > 0 and denominator < 0 then\n        numerator, denominator = -denominator, -numerator\n    end\n    if numerator < 0 and denominator > 0 then\n        numerator, denominator = -denominator, -numerator\n    end\n    if numerator < 0 and denominator < 0 then\n        numerator, denominator = -denominator, -numerator\n    end\n    if numerator == 0 and denominator == 0 then\n        return true\n    end\n    if numerator == 0 and denominator > 0 then\n        numerator, denominator = -denominator, -numerator\n    end\n    if numerator == 0 and denominator < 0 then\n        numerator, denominator = -denominator, -numerator\n    end\n    if numerator == 0 and denominator == 0 then\n        return true\n    end\n    if numerator == 0 and denominator > 0 then\n        numerator,"], ["-- Write a function which sorts the given table of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original table.\n-- For example:\n-- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1, -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n    local sum_digits = {}\n    for _, num in ipairs(nums) do\n        local digit = tonumber(string.sub(num, 1, 1))\n        sum_digits[digit] = sum_digits[digit] or 0\n        sum_digits[digit] = sum_digits[digit] + 1\n    end\n    local sorted_nums = {}\n    for _, digit in ipairs(sum_digits) do\n        table.insert(sorted_nums, digit)\n    end\n    return sorted_nums\nend\n```"], ["-- Write a function that takes a table of numbers as input and returns \n-- the number of elements in the table that are greater than 10 and both \n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter({15, -73, 14, -15})\n-- 1\n-- >>> specialFilter({33, -2, -3, 45, 21, 109})\n-- 2\nlocal function specialFilter(nums)\n    local odd = {}\n    for i, num in ipairs(nums) do\n        if num > 10 and math.floor(num) % 2 == 1 then\n            odd[i] = num\n        end\n    end\n    local count = 0\n    for i, num in ipairs(odd) do\n        if i > 1 and i < #odd and odd[i] > 10 and math.floor(odd[i]) % 2 == 1 then\n            count = count + 1\n        end\n    end\n    return count\nend\n```"], ["-- You are given a positive integer n. You have to create an integer table a of length n.\n-- For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n--     and a[i] + a[j] + a[k] is a multiple of 3.\n--     Example :\n--     >>> get_max_triples(5)\n--     1\n-- Explanation: \n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nlocal function get_max_triples(n)\n    local a = {}\n    for i = 1, n do\n        a[i] = i * i - i + 1\n    end\n    local max_triples = 0\n    for i = 1, n do\n        for j = i+1, n do\n            for k = j+1, n do\n                local triples = 0\n                for i = 1, n do\n                    triples = triples + a[i] + a[j] + a[k]\n                end\n                if triples % 3 == 0 then\n                    max_triples = max(max_triples, triples)\n                end\n            end\n        end\n    end\n    return max_triples\nend\n```"], ["-- There are eight planets in our solar system: the closerst to the Sun \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2. \n-- The function should return a table containing all planets whose orbits are \n-- located between the orbit of planet1 and the orbit of planet2, sorted by \n-- the proximity to the sun. \n-- The function should return an empty table if planet1 or planet2\n-- are not correct planet names. \n-- Examples\n-- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n-- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\nlocal function bf(planet1, planet2)\n    local table = {}\n    local function get_proximity(planet1, planet2)\n        local sun_distance = math.sqrt(math.pow(planet1.sun_distance, 2) + math.pow(planet2.sun_distance, 2))\n        return sun_distance\n    end\n    table = {}\n    for i, planet in ipairs(planet1:get_planets()) do\n        table[i] = get_proximity(planet1, planet2)\n    end\n    table = table[1]\n    table = table[2]\n    table = table[3]\n    table = table[4]\n    table = table[5]\n    return table\nend"], ["-- Write a function that accepts a table of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted table with a sorted order,\n-- The table is always a table of strings and never a table of numbers,\n-- and it may contain duplicates.\n-- The order of the table should be ascending by length of each word, and you\n-- should return the table sorted by that rule.\n-- If two words have the same length, sort the table alphabetically.\n-- The function should return a table of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> list_sort({'aa', 'a', 'aaa'})\n-- {'aa'}\n-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})\n-- {'ab', 'cd'}\nlocal function sorted_list_sum(lst)\n    local sum = 0\n    for i = 1, #lst do\n        sum = sum + lst[i]\n    end\n    return sum\nend"], ["-- A simple program which should return the value of x if n is \n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y(7, 34, 12)\n-- 34\n-- >>> x_or_y(15, 8, 5)\n-- 5\nlocal function x_or_y(n, x, y)\n    if n == 1 then\n        return x\n    elseif n % 2 == 0 then\n        return x_or_y(n/2, x, y)\n    else\n        return y_or_x(n-1, x, y)\n    end\nend"], ["-- Given a table of numbers, return the sum of squares of the numbers\n-- in the table that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference({1, 3, 2, 0})\n-- 10\n-- >>> double_the_difference({-1, -2, 0})\n-- 0\n-- >>> double_the_difference({9, -2})\n-- 81\n-- >>> double_the_difference({0})\n-- 0\n-- If the input table is empty, return 0.\nlocal function double_the_difference(lst)\n    if not lst then\n        return 0\n    end\n    local sum = 0\n    for i = 1, #lst do\n        sum = sum + lst[i]\n    end\n    return sum\nend\n"], ["-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two tables of scores and guesses of equal length, where each index shows a match. \n-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})\n-- {0, 0, 0, 0, 3, 3}\n-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})\n-- {4, 4, 1, 0, 0, 6}\nlocal function compare(game, guess)\n    local score = 0\n    for i = 1, #game do\n        score = score + game[i]\n    end\n    local guess_score = 0\n    for i = 1, #guess do\n        guess_score = guess_score + guess[i]\n    end\n    local guess_score_diff = math.abs(guess_score - score)\n    if guess_score_diff == 0 then\n        return 0\n    end\n    return guess_score_diff\nend"], ["-- You will be given the name of a class (a string) and a table of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters \n-- in the extension's name, the strength is given by the fraction CAP - SM. \n-- You should find the strongest extension and return a string in this \n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the table.\n-- For example, if you are given \"Slices\" as the class and a table of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n-- (its strength is -1).\n-- Example:\n-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name, extensions)\n    local class_str = class_name:lower()\n    local extensions_table = {}\n    for _, extension in ipairs(extensions) do\n        local extension_str = extension:lower()\n        local extension_str_len = #extension_str\n        local extension_str_index = string.find(class_str, extension_str)\n        if extension_str_index == nil then\n            extensions_table[extension_str_len] = extension_str\n        else\n            extensions_table[extension_str_index] = extension_str\n        end\n    end\n    local max_str_len = 0\n    for _, extension_str in ipairs(extensions_table) do\n        if extension_str_len > max_str_len then\n            max_str_len = extension_str_len\n        end\n    end\n    return extensions_table[max_str_len]\nend"], ["-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check('abcd', 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup', 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef', 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal function cycpattern_check(a, b)\n    local pattern = string.rep(b, string.len(a) - string.len(b) + 1)\n    local i = 1\n    while i <= string.len(a) do\n        if a:sub(i, i) == b:sub(i, i) then\n            pattern = string.rep(pattern, string.len(a) - string.len(pattern) + 1)\n            i = i + 1\n        else\n            break\n        end\n    end\n    return pattern ~= b\nend"], ["-- Given an integer. return a table that has the number of even and odd digits respectively.\n-- Example:\n--     >>> even_odd_count(-12)\n--     {1, 1}\n--     >>> even_odd_count(123)\n--     {1, 2}\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    for i = 1, #num do\n        if num:sub(i, i) % 2 == 0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n    end\n    return {even_count, odd_count}\nend"], ["-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n    local roman_numerals = {\n        'm', 'mm', 'mM', 'M', 'MM', 'Mm', 'MMM', 'MMMM', 'MMMMM',\n        'd', 'dd', 'dm', 'ddd', 'dddD', 'dddM', 'dddMM', 'dddMMM', 'dddMMMM',\n        'c', 'cc', 'cm', 'cd', 'ccd', 'ccdC', 'ccdM', 'ccdMM', 'ccdMMM', 'ccdMMMM',\n        'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vv', 'vvv', 'vvvv', 'vvvvv',\n        'x', 'xx', 'xxx', 'xxii', 'xxiii', 'xxiv', 'xxv', 'xxvi', 'xxvii', 'xxviii',\n        'l', 'll', 'lL', 'LL', 'Ll', 'LlL', 'LlLl', 'LlLlL', 'LlLlLl',\n        'xii', 'xxii', 'xxxii', 'xxiii', 'xxiv', 'xxv', 'xxvi', 'xxvii', 'xxviii',\n        'c', 'cc', 'cm', 'cd', 'ccd', 'ccdC', 'ccdM', 'ccdMM', 'ccdMMM', 'ccdMMMM',\n        'ccdMMMMM', 'ccdMMMMMM', 'ccdMMMMMMM', 'ccdMMMMMMMM', 'ccdMMMM"], ["-- Given the lengths of the three sides of a triangle. Return true if the three\n-- sides form a right-angled triangle, false otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or \n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle(3, 4, 5)\n-- true\n-- >>> right_angle_triangle(1, 2, 3)\n-- false\nlocal function right_angle_triangle(a, b, c)\n    if a == b + c or b == a + c or c == a + b then\n        return true\n    end\n    return false\nend\n"], ["-- Write a function that accepts a table of strings.\n-- The table contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max({'name', 'of', 'string'})\n-- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n    local max_count = 0\n    local max_word = nil\n    for _, word in ipairs(words) do\n        local count = 0\n        for _, char in ipairs(word) do\n            count = count + 1\n        end\n        if count > max_count then\n            max_count = count\n            max_word = word\n        end\n    end\n    return max_word\nend"], ["-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return a table of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat(5, 6, 10)\n-- {11, 4}\n-- >>> eat(4, 8, 9)\n-- {12, 1}\n-- >>> eat(1, 10, 10)\n-- {11, 0}\n-- >>> eat(2, 11, 5)\n-- {7, 0}\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n    if number == 0 then\n        return {0, 0}\n    elseif number == 1 then\n        return {number, remaining}\n    elseif number == 2 then\n        return {number - 1, remaining}\n    elseif number == 3 then\n        return {number - 2, remaining}\n    elseif number == 4 then\n        return {number - 3, remaining}\n    elseif number == 5 then\n        return {number - 4, remaining}\n    elseif number == 6 then\n        return {number - 5, remaining}\n    elseif number == 7 then\n        return {number - 6, remaining}\n    elseif number == 8 then\n        return {number - 7, remaining}\n"], ["-- Given two tables operator, and operand. The first table has basic algebra operations, and \n-- the second table is a table of integers. Use the two given tables to build the algebric \n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + ) \n-- Subtraction ( - ) \n-- Multiplication ( * ) \n-- Floor division ( // ) \n-- Exponentiation ( ** ) \n-- Example:\n-- operator['+', '*', '-']\n-- table = [2, 3, 4, 5]\n-- result = 2 + 3 * 4 - 5\n-- => result = 9\n-- Note:\n--     The length of operator table is equal to the length of operand table minus one.\n--     Operand is a table of of non-negative integers.\n--     Operator table has at least one operator, and operand table has at least two operands.\nlocal function do_algebra(operator, operand)\n    -- TODO: implement the function\n    -- return the evaluation of this expression\n    -- Example:\n    -- operator['+', '*', '-']\n    -- table = [2, 3, 4, 5]\n    -- result = 2 + 3 * 4 - 5\n    -- => result = 9\n    -- Note:\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     Operand is a table of of non-negative integers.\n    --     Operator table has at least one operator, and operand table has at least two operands.\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     The length of operator table is equal to the length of operand table minus one.\n    --     The length of operator table is equal"], ["-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa, \n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve('1234')\n-- '4321'\n-- >>> solve('ab')\n-- 'AB'\n-- >>> solve('#a@C')\n-- '#A@c'\nlocal function solve(s)\n    if s == nil then\n        return s\n    end\n    local letters = {}\n    for i = 1, #s do\n        if s:sub(i, i) ~= ' ' then\n            letters[i] = s:sub(i, i)\n        else\n            letters[i] = ' '\n        end\n    end\n    for i = #s, 1, -1 do\n        if letters[i] == ' ' then\n            letters[i] = s:sub(i, i)\n        end\n    end\n    if #s == 0 then\n        return s\n    end\n    local result = ''\n    for i = 1, #s do\n        result = result .. letters[i]\n    end\n    return result\nend"], ["-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return nil.\n-- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\nlocal function string_to_md5(text)\n    local md5 = md5()\n    local len = string.len(text)\n    for i = 1, len do\n        md5.write(text:sub(i, i))\n    end\n    md5.write(text:sub(len,))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0))\n    md5.write(string.char(0"], ["-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers(2, 8)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10, 14)\n-- {}\nlocal function generate_integers(a, b)\n    local result = {}\n    for i = a, b do\n        table.insert(result, i)\n    end\n    return result\nend\n"]]