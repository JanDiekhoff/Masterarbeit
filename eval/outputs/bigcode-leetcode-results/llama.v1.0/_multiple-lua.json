[["-- Check if in given table of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n-- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\nlocal function has_close_elements(numbers, threshold)\n  local sorted_numbers = sorted_numbers(numbers)\n  local sorted_threshold = sorted_threshold(threshold)\n  return sorted_numbers[1] <= sorted_threshold and sorted_numbers[2] <= sorted_threshold\nend\n```"], ["-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the table of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- {'()', '(())', '(()())'}\nlocal function separate_paren_groups(paren_string)\n  local groups = {}\n  local open_braces = {}\n  local close_braces = {}\n  local balanced = true\n  for I, char in ipairs(paren_string) do\n    if char == '(' and balanced then\n      balanced = false\n      open_braces[#open_braces+1] = i\n    elseif char == ')' and balanced then\n      balanced = true\n      close_braces[#close_braces+1] = i\n    elseif char == '(' and not balanced then\n      open_braces[#open_braces+1] = i\n    elseif char == ')' and balanced then\n      close_braces[#close_braces+1] = i\n    elseif char == '(' and balanced then\n      balanced = true\n      open_braces[#open_braces+1] = i\n    elseif char == ')' and balanced then\n      balanced = false\n      close_braces[#close_braces+1] = i\n    elseif char == '(' and not balanced then\n      open_braces[#open_braces+1] = i\n    elseif char == ')' and balanced then\n      close_braces[#close_braces+1] = i\n    else\n      error('Invalid character in paren string')\n    end\n  end\n  for I, char in ipairs(paren_string) do\n    if char == '(' and balanced then\n      balanced = false\n      open_braces[#open_braces+1] = i\n    elseif char == ')' and balanced then\n      balanced = true\n"], ["-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n  local integer, decimal = number:match(\"^%d+%.%d+$\")\n  local integer_part = tonumber(integer)\n  local decimal_part = tonumber(decimal)\n  if decimal_part == 0 then\n    return integer_part\n  else\n    return integer_part + decimal_part\n  end\nend"], ["-- You're given a table of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return true. Otherwise it should return false.\n-- >>> below_zero({1, 2, 3})\n-- false\n-- >>> below_zero({1, 2, -4, 5})\n-- true\nlocal function below_zero(operations)\n  local balance = operations[1]\n  for I = 2, #operations do\n    if operations[i] < 0 then\n      return false\n    end\n    balance = balance - operations[i]\n  end\n  return balance >= 0\nend"], ["-- For a given table of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n-- 1.0\nlocal function mean_absolute_deviation(numbers)\n  local mean = sum(numbers) / #numbers\n  local sum_of_squares = sum(numbers * numbers)\n  local sum_of_squares_with_mean = sum_of_squares - mean * mean\n  return sum_of_squares_with_mean / #numbers\nend"], ["-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1, 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n  if #numbers == 0 then\n    return {}\n  end\n  local result = {}\n  for I, number in ipairs(numbers) do\n    result[#result + 1] = number\n  end\n  result[#result + 1] = delimeter\n  return result\nend\n```"], ["-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n-- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n  local depth = 0\n  local max_depth = 0\n  local result = {}\n  for _, char in ipairs(paren_string) do\n    if char == '(' then\n      depth = depth + 1\n      max_depth = math.max(max_depth, depth)\n    elseif char == ')' then\n      depth = depth - 1\n      max_depth = math.max(max_depth, depth)\n    end\n  end\n  result[max_depth] = depth\n  return result\nend"], ["-- Filter an input table of strings only for ones that contain given substring\n-- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings, substring)\n  local filtered_strings = {}\n  for _, string in ipairs(strings) do\n    if string:match(substring) then\n      table.insert(filtered_strings, string)\n    end\n  end\n  return filtered_strings\nend\n```"], ["-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product({})\n-- {0, 1}\n-- >>> sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n  local sum = 0\n  local product = 1\n  for I, num in ipairs(numbers) do\n    sum = sum + num\n    product = product * num\n  end\n  return {sum, product}\nend"], ["-- From a given table of integers, generate a table of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n  local max = numbers[1]\n  for I = 2, #numbers do\n    local current = numbers[i]\n    if current > max then\n      max = current\n    end\n  end\n  return max\nend"], ["-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n  local longest_prefix = \"\"\n  local longest_suffix = \"\"\n  local palindrome_prefix = \"\"\n  local palindrome_suffix = \"\"\n  for I = 1, #string do\n    local char = string:sub(i, i)\n    if char == string:sub(i, i) then\n      longest_suffix = longest_suffix .. char\n    else\n      longest_prefix = longest_prefix .. char\n    end\n  end\n  for I = 1, #longest_suffix do\n    palindrome_suffix = palindrome_suffix .. longest_suffix:sub(i, i)\n  end\n  for I = 1, #longest_prefix do\n    palindrome_prefix = palindrome_prefix .. longest_prefix:sub(i, i)\n  end\n  return palindrome_prefix .. longest_prefix .. palindrome_suffix\nend"], ["-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010', '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = ''\n  for I = 1, #a do\n    local char = a[i]\n    local char2 = b[i]\n    if char == char2 then\n      result = result .. char\n    else\n      result = result .. '0'\n    end\n  end\n  return result\nend\n```"], ["-- Out of table of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return nil in case the input table is empty.\n-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n-- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n  local longest_string = nil\n  local longest_length = 0\n  for _, string in ipairs(strings) do\n    if string:len() > longest_length then\n      longest_string = string\n      longest_length = string:len()\n    end\n  end\n  return longest_string\nend\n```"], ["-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a, b)\n  if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend\n```"], ["-- Return table of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes('abc')\n-- {'a', 'ab', 'abc'}\nlocal function all_prefixes(string)\n  local prefixes = {}\n  local function prefix_length(prefix)\n    return #prefix\n  end\n  local function prefix_length_increasing(prefix)\n    return prefix_length(prefix) == prefix_length(prefixes[#prefixes])\n  end\n  local function prefix_length_decreasing(prefix)\n    return prefix_length(prefix) == prefix_length(prefixes[#prefixes + 1])\n  end\n  local function prefix_length_increasing_decreasing(prefix)\n    return prefix_length(prefix) == prefix_length(prefixes[#prefixes])\n  end\n  local function prefix_length_increasing_decreasing_in_order(prefix)\n    return prefix_length(prefix) == prefix_length(prefixes[#prefixes])\n  end\n  for I = 1, #string do\n    local prefix = string:sub(i, i)\n    if prefix_length(prefix) == prefix_length(prefixes[#prefixes]) then\n      prefixes[#prefixes + 1] = prefix\n    elseif prefix_length_increasing(prefix) then\n      prefixes[#prefixes + 1] = prefix\n    elseif prefix_length_decreasing(prefix) then\n      prefixes[#prefixes + 1] = prefix\n    elseif prefix_length_increasing_decreasing_in_order(prefix) then\n      prefixes[#prefixes + 1] = prefix\n    end\n  end\n  return prefixes\nend"], ["-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence(0)\n-- '0'\n-- >>> string_sequence(5)\n-- '0 1 2 3 4 5'\nlocal function string_sequence(n)\n  local result = ''\n  for I = 1, n do\n    result = result .. tostring(i)\n  end\n  return result\nend\n```"], ["-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n-- 4\nlocal function count_distinct_characters(string)\n  local count = {}\n  for char in string:gmatch('%a') do\n    if not table.has_key(count, char) then\n      count[char] = 1\n    else\n      count[char] = count[char] + 1\n    end\n  end\n  return table.concat(count, ',')\nend\n```"], ["-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return table of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nlocal function parse_music(music_string)\n  local notes = {}\n  local beat_count = {}\n  local current_note = \"\"\n  for I, note in ipairs(music_string) do\n    if note == \"o\" then\n      table.insert(notes, 1)\n    elseif note == \"o|\" then\n      table.insert(notes, 2)\n    elseif note == \".\" then\n      table.insert(notes, 1)\n    elseif note == \"|\" then\n      table.insert(notes, 2)\n    else\n      table.insert(notes, 1)\n    end\n    beat_count[#beat_count + 1] = 1\n  end\n  beat_count[#beat_count + 1] = #notes\n  return beat_count\nend"], ["-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa', 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string, substring)\n  local count = 0\n  for I = 1, #string do\n    if string:sub(i, i):lower() == substring:lower() then\n      count = count + 1\n    end\n  end\n  return count\nend\n```"], ["-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers('three one five')\n-- 'one three five'\nlocal function sort_numbers(numbers)\n  local sorted_numbers = {}\n  for I, num in ipairs(numbers) do\n    if sorted_numbers[num] == nil then\n      sorted_numbers[num] = i\n    end\n  end\n  return table.concat(sorted_numbers)\nend"], ["-- From a supplied table of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n-- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n-- {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n  local sorted_numbers = {}\n  for I, number in ipairs(numbers) do\n    local distance = math.abs(number - numbers[i])\n    if distance < 0.00001 then\n      table.insert(sorted_numbers, number)\n    end\n  end\n  return sorted_numbers\nend"], ["-- Given table of numbers (of at least two elements), apply a linear transform to that table,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25, 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n  local min_num = numbers[1]\n  local max_num = numbers[#numbers]\n  local rescaled_numbers = {}\n  for I, num in ipairs(numbers) do\n    if num < min_num then\n      rescaled_numbers[i] = min_num\n    elseif num > max_num then\n      rescaled_numbers[i] = max_num\n    else\n      rescaled_numbers[i] = num\n    end\n  end\n  return rescaled_numbers\nend"], ["-- Filter given table of any luathon values only for integers\n-- >>> filter_integers({'a', 3.14, 5})\n-- {5}\n-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})\n-- {1, 2, 3}\nlocal function filter_integers(values)\n  return values:filter(function(value)\n    return type(value) == 'number' and value ~= 0\n  end)\nend\n```"], ["-- Return length of given string\n-- >>> strlen('')\n-- 0\n-- >>> strlen('abc')\n-- 3\nlocal function strlen(string)\n  return #string\nend\n```"], ["-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor(15)\n-- 5\nlocal function largest_divisor(n)\n  local largest = n\n  for I = 2, math.floor(math.sqrt(n)) do\n    if n % I == 0 then\n      largest = i\n    end\n  end\n  return largest\nend\n```"], ["-- Return table of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be tableed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n-- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n  local factors = {}\n  local count = 1\n  while n > 1 do\n    local factor = math.floor(n / count)\n    table.insert(factors, factor)\n    n = n % count\n    count = count * 2\n  end\n  return factors\nend\n```"], ["-- From a table of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates({1, 2, 3, 2, 4})\n-- {1, 3, 4}\nlocal function remove_duplicates(numbers)\n  local seen = {}\n  for I, num in ipairs(numbers) do\n    if not seen[num] then\n      seen[num] = true\n      return numbers\n    end\n  end\n  return numbers\nend"], ["-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case('Hello')\n-- 'hELLO'\nlocal function flip_case(string)\n  return string:gsub('[%w]', function(c) return string.upper(c) end)\nend"], ["-- Concatenate table of strings into a single string\n-- >>> concatenate({})\n-- ''\n-- >>> concatenate({'a', 'b', 'c'})\n-- 'abc'\nlocal function concatenate(strings)\n  local result = ''\n  for _, string in ipairs(strings) do\n    result = result .. string\n  end\n  return result\nend"], ["-- Filter an input table of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc', 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings, prefix)\n  return {\n    for I, v in ipairs(strings) do\n      if v:sub(1, #prefix) == prefix then\n        return {v}\n      end\n    end\n  }\nend\n```"], ["-- Return only positive numbers in the table.\n-- >>> get_positive({-1, 2, -4, 5, 6})\n-- {2, 5, 6}\n-- >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- {5, 3, 2, 3, 9, 123, 1}\nlocal function get_positive(l)\n  local result = {}\n  for _, v in ipairs(l) do\n    if v > 0 then\n      table.insert(result, v)\n    end\n  end\n  return result\nend\n```"], ["-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime(6)\n-- false\n-- >>> is_prime(101)\n-- true\n-- >>> is_prime(11)\n-- true\n-- >>> is_prime(13441)\n-- true\n-- >>> is_prime(61)\n-- true\n-- >>> is_prime(4)\n-- false\n-- >>> is_prime(1)\n-- false\nlocal function is_prime(n)\n  if n <= 1 then\n    return false\n  end\n  for I = 2, math.floor(math.sqrt(n)) do\n    if n % I == 0 then\n      return false\n    end\n  end\n  return true\nend\n```"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal function sort_third(l)\n  local l' = {}\n  for I = 1, #l do\n    if I % 3 == 0 then\n      table.insert(l', l[i])\n    else\n      table.insert(l', l[i] * 3)\n    end\n  end\n  return l'\nend"], ["-- Return sorted unique elements in a table\n-- >>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nlocal function unique(l)\n  local seen = {}\n  for _, v in ipairs(l) do\n    if not seen[v] then\n      seen[v] = true\n      table.insert(seen, v)\n    end\n  end\n  return seen\nend"], ["-- Return maximum element in the table.\n-- >>> max_element({1, 2, 3})\n-- 3\n-- >>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- 123\nlocal function max_element(l)\n  local max = l[1]\n  for I, v in ipairs(l) do\n    if v > max then\n      max = v\n    end\n  end\n  return max\nend\n```"], ["-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n-- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n  local result = {}\n  for I = 1, n do\n    if i % 11 == 7 or i % 13 == 7 then\n      table.insert(result, \"FizzBuzz\")\n    elseif i % 11 == 11 then\n      table.insert(result, \"Buzz\")\n    else\n      table.insert(result, i)\n    end\n  end\n  return result\nend\n```"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function sort_even(l)\n  local l' = {}\n  for I = 1, #l do\n    if I % 2 == 1 then\n      table.insert(l', l[i])\n    else\n      table.insert(l', l[i] + 1)\n    end\n  end\n  return l'\nend"], ["-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n-- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n  if n <= 1 then\n    return false\n  end\n  if n == 2 or n == 3 then\n    return true\n  end\n  local fibonacci = 0\n  for I = 1, n do\n    fibonacci = fibonacci + fibonacci\n  end\n  if fibonacci > 1 then\n    return false\n  end\n  return true\nend\n```"], ["-- triples_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are three distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1, 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n-- false\nlocal function triples_sum_to_zero(l)\n  if #l == 3 and l[1] + l[2] + l[3] == 0 then\n    return true\n  else\n    return false\n  end\nend"], ["-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\nlocal function car_race_collision(n)\n  local cars = {}\n  for I = 1, n do\n    cars[i] = {x = math.random(-100, 100), y = math.random(-100, 100)}\n  end\n  local collisions = 0\n  for I = 1, n do\n    for j = I + 1, n do\n      if cars[i] and cars[j] then\n        local dx = cars[i].x - cars[j].x\n        local dy = cars[i].y - cars[j].y\n        if dx * dx + dy * dy > 1000 then\n          collisions = collisions + 1\n        end\n      end\n    end\n  end\n  return collisions\nend"], ["-- Return table with elements incremented by 1.\n-- >>> incr_list({1, 2, 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4, 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n  local result = {}\n  for I, v in ipairs(l) do\n    result[i] = v + 1\n  end\n  return result\nend\n```"], ["-- pairs_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are two distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1, 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n-- false\nlocal function pairs_sum_to_zero(l)\n  local sum = 0\n  for I, v in ipairs(l) do\n    if v ~= 0 then\n      sum = sum + v\n    end\n  end\n  return sum == 0\nend\n```"], ["-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base(8, 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n-- '111'\nlocal function change_base(x, base)\n  if x == 0 then\n    return '0'\n  end\n  local result = ''\n  for I = 1, math.floor(math.log(x, base)) do\n    result = result .. string.rep('0', base - 1)\n    x = x / base\n  end\n  result = result .. string.rep('1', base - math.floor(math.log(x, base)) + 1)\n  return result\nend\n```"], ["-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area(5, 3)\n-- 7.5\nlocal function triangle_area(a, h)\n  local s = a * h / 2\n  return s * s\nend\n```"], ["-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4(5)\n-- 4\n-- >>> fib4(6)\n-- 8\n-- >>> fib4(7)\n-- 14\nlocal function fib4(n)\n  if n == 0 or n == 1 then\n    return 0\n  end\n  if n == 2 then\n    return 2\n  end\n  return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend"], ["-- Return median of elements in the table l.\n-- >>> median({3, 1, 2, 4, 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n  if #l == 0 then\n    return nil\n  end\n  local n = #l\n  if n % 2 == 0 then\n    return l[n/2]\n  else\n    return l[n/2 - 1] + l[n/2]\n  end\nend\n```"], ["-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- true\n-- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n-- >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n  local reversed_text = text:reverse()\n  return text == reversed_text\nend\n```"], ["-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n-- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\n    return 0\n  end\n  local remainder = n % p\n  return remainder + modp(remainder, p)\nend\n```"], ["-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels('')\n-- ''\n-- >>> remove_vowels('abcdef')\n-- 'bcdf'\n-- >>> remove_vowels('aaaaa')\n-- ''\n-- >>> remove_vowels('aaBAA')\n-- 'B'\n-- >>> remove_vowels('zbcd')\n-- 'zbcd'\nlocal function remove_vowels(text)\n  local result = {}\n  for I, char in ipairs(text) do\n    if char ~= ' ' and char ~= '.' and char ~= ',' and char ~= ':' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~= '?' and char ~= '!' and char ~"], ["-- Return true if all numbers in the table l are below threshold t.\n-- >>> below_threshold({1, 2, 4, 10}, 100)\n-- true\n-- >>> below_threshold({1, 20, 4, 10}, 5)\n-- false\nlocal function below_threshold(l, t)\n  local n = #l\n  for I = 1, n do\n    if l[i] < t then\n      return false\n    end\n  end\n  return true\nend"], ["-- Add two numbers x and y\n-- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n  return x + y\nend\n```"], ["-- Check if two words have the same characters.\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n-- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n-- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n  if s0 == s1 then\n    return true\n  end\n  if #s0 == #s1 then\n    for I = 1, #s0 do\n      if s0[i] ~= s1[i] then\n        return false\n      end\n    end\n    return true\n  end\n  return false\nend\n```"], ["-- Return n-th Fibonacci number.\n-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n-- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n  if n < 2 then\n    return n\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend"], ["-- brackets is a string of \"<\" and \">\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('<')\n-- false\n-- >>> correct_bracketing('<>')\n-- true\n-- >>> correct_bracketing('<<><>>')\n-- true\n-- >>> correct_bracketing('><<>')\n-- false\nlocal function correct_bracketing(brackets)\n  if type(brackets) ~= 'string' then\n    return false\n  end\n  local open_brackets = {}\n  local close_brackets = {}\n  for I = 1, #brackets do\n    local char = brackets[i]\n    if char == '<' then\n      open_brackets[#open_brackets+1] = brackets[i]\n    elseif char == '>' then\n      close_brackets[#close_brackets+1] = brackets[i]\n    elseif char == '[' then\n      open_brackets[#open_brackets+1] = brackets[i]\n    elseif char == ']' then\n      close_brackets[#close_brackets+1] = brackets[i]\n    end\n  end\n  local has_matching_brackets = true\n  for I = 1, #open_brackets do\n    if open_brackets[i] ~= close_brackets[i] then\n      has_matching_brackets = false\n      break\n    end\n  end\n  return has_matching_brackets\nend"], ["-- Return true is table elements are monotonically increasing or decreasing.\n-- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n-- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n  local n = #l\n  local i = 1\n  while i <= n do\n    local v = l[i]\n    if v > l[i - 1] then\n      return false\n    elseif v < l[i - 1] then\n      return true\n    end\n    i = i + 1\n  end\n  return true\nend"], ["-- Return sorted unique common elements for two tables.\n-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5, 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n  local result = {}\n  for k, v in ipairs(l1) do\n    if not table.contains(result, v) then\n      result[#result+1] = v\n    end\n  end\n  for k, v in ipairs(l2) do\n    if not table.contains(result, v) then\n      result[#result+1] = v\n    end\n  end\n  return result\nend"], ["-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n-- 2\nlocal function largest_prime_factor(n)\n  if n <= 1 then\n    return n\n  end\n  local largest_factor = 1\n  for I = 2, math.floor(math.sqrt(n)) do\n    if n % I == 0 then\n      largest_factor = i\n      break\n    end\n  end\n  return largest_factor\nend\n```"], ["-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n(30)\n-- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n-- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n  return n * n\nend"], ["-- brackets is a string of \"(\" and \")\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('(')\n-- false\n-- >>> correct_bracketing('()')\n-- true\n-- >>> correct_bracketing('(()())')\n-- true\n-- >>> correct_bracketing(')(()')\n-- false\nlocal function correct_bracketing(brackets)\n  local open_brackets = {}\n  local close_brackets = {}\n  for I, c in ipairs(brackets) do\n    if c == '(' then\n      table.insert(open_brackets, i)\n    elseif c == ')' then\n      table.insert(close_brackets, i)\n    end\n  end\n  local has_matching_brackets = true\n  for I, c in ipairs(brackets) do\n    if not table.contains(open_brackets, i) and not table.contains(close_brackets, i) then\n      has_matching_brackets = false\n      break\n    end\n  end\n  return has_matching_brackets\nend"], ["-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n--  Return derivative of this polynomial in the same form.\n-- >>> derivative({3, 1, 2, 4, 5})\n-- {1, 4, 12, 20}\n-- >>> derivative({1, 2, 3})\n-- {2, 6}\nlocal function derivative(xs)\n  local n = #xs\n  local result = {}\n  for I = 1, n do\n    local x = xs[i]\n    local d = 1\n    for j = 1, I do\n      d = d * x\n    end\n    result[i] = d\n  end\n  return result\nend\n```"], ["-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib(1)\n-- 0\n-- >>> fibfib(5)\n-- 4\n-- >>> fibfib(8)\n-- 24\nlocal function fibfib(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 0\n  elseif n == 2 then\n    return 1\n  else\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend"], ["-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count('abcde')\n-- 2\n-- >>> vowels_count('ACEDY')\n-- 3\nlocal function vowels_count(s)\n  local count = 0\n  for I, v in ipairs(s) do\n    if v == 'a' or v == 'e' or v == 'i' or v == 'o' or v == 'u' then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12, 2)\n-- '12'\nlocal function circular_shift(x, shift)\n  if shift > #x then\n    return string.reverse(string.sub(x, 1, #x - shift))\n  else\n    local digits = string.sub(x, 1, shift)\n    local reversed_digits = string.reverse(digits)\n    return string.sub(reversed_digits, 1, #reversed_digits - shift) .. digits\n  end\nend"], ["-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n-- >>> digitSum('')\n-- 0\n-- >>> digitSum('abAB')\n-- 131\n-- >>> digitSum('abcCd')\n-- 67\n-- >>> digitSum('helloE')\n-- 69\n-- >>> digitSum('woArBld')\n-- 131\n-- >>> digitSum('aAaaaXa')\n-- 153\nlocal function digitSum(s)\n  local sum = 0\n  for I = 1, #s do\n    local c = s:sub(i, i)\n    if c:match('^%d+$') then\n      sum = sum + tonumber(c)\n    end\n  end\n  return sum\nend\n```"], ["-- In this task, you will be given a string that represents a number of apples and oranges \n-- that are distributed in a basket of fruit this basket contains \n-- apples, oranges, and mango fruits. Given the string that represents the total number of \n-- the oranges and apples and an integer that represent the total number of the fruits \n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- >>> fruit_distribution('5 apples and 6 oranges', 19)\n-- 8\n-- >>> fruit_distribution('0 apples and 1 oranges', 3)\n-- 2\n-- >>> fruit_distribution('2 apples and 3 oranges', 100)\n-- 95\n-- >>> fruit_distribution('100 apples and 1 oranges', 120)\n-- 19\nlocal function fruit_distribution(s, n)\n  local total_apples = 0\n  local total_oranges = 0\n  local total_fruits = 0\n  for I, v in ipairs(s:gmatch(\"%d+\")) do\n    if v == \"a\" or v == \"o\" or v == \"m\" then\n      total_apples = total_apples + 1\n    elseif v == \"a\" then\n      total_oranges = total_oranges + 1\n    else\n      total_fruits = total_fruits + 1\n    end\n  end\n  return total_fruits - total_apples - total_oranges\nend"], ["-- \"Given a table representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a table, [ smalest_value, its index ],\n-- If there are no even values or the given table is empty, return [].\n-- Example 1:\n-- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5, 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there are two zeros,\n--              so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\nlocal function pluck(arr)\n  if #arr == 0 then\n    return {}\n  end\n  local min_even = math.min(arr[1].value, arr[2].value)\n  local min_index = 1\n  for I, v in ipairs(arr) do\n    if v.value % 2 == 0 then\n      min_even = math.min(min_even, v.value)\n      min_index = i\n    end\n  end\n  return {min_even, min_index}\nend\n```"], ["-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than \n-- zero, and has a frequency greater than or equal to the value of the integer itself. \n-- The frequency of an integer is the number of times it appears in the table.\n-- If no such a value exist, return -1.\n-- Examples:\n-- >>> search({4, 1, 2, 2, 3, 1})\n-- 2\n-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})\n-- 3\n-- >>> search({5, 5, 4, 4, 4})\n-- -1\nlocal function search(lst)\n  if #lst == 0 then\n    return -1\n  end\n  local max = 0\n  local freq = {}\n  for I, v in ipairs(lst) do\n    if freq[v] == nil then\n      freq[v] = 1\n    else\n      freq[v] = freq[v] + 1\n    end\n    if freq[v] > max then\n      max = v\n    end\n  end\n  return max\nend\n```"], ["-- Given table of integers, return table in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n-- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>> strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n  if #lst == 0 then\n    return {}\n  end\n  local min_val = lst[1]\n  local max_val = lst[#lst]\n  local sorted_lst = {}\n  for I = 2, #lst do\n    local val = lst[i]\n    if val < min_val then\n      min_val = val\n    end\n    if val > max_val then\n      max_val = val\n    end\n    sorted_lst[#sorted_lst+1] = val\n  end\n  sorted_lst[#sorted_lst+1] = min_val\n  sorted_lst[#sorted_lst+1] = max_val\n  return sorted_lst\nend"], ["-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater \n-- than the third side.\n-- Example:\n-- >>> triangle_area(3, 4, 5)\n-- 6.0\n-- >>> triangle_area(1, 2, 10)\n-- -1\nlocal function triangle_area(a, b, c)\n  if a == b and b == c then\n    return 0\n  end\n  if a == b or b == c or a == c then\n    return -1\n  end\n  return (b + c) / 2\nend\n```"], ["-- Write a function that returns true if the object q will fly, and false otherwise.\n-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- >>> will_it_fly({1, 2}, 5)\n-- false\n-- # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- >>> will_it_fly({3, 2, 3}, 1)\n-- false\n-- # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- >>> will_it_fly({3, 2, 3}, 9)\n-- true\n-- # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- >>> will_it_fly({3}, 5)\n-- true\n-- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function will_it_fly(q, w)\n  if q.balanced and q.sum <= w then\n    return true\n  else\n    return false\n  end\nend"], ["-- Given a table arr of integers, find the minimum number of elements that\n-- need to be changed to make the table palindromic. A palindromic table is a table that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n-- 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n  -- Find the length of the table\n  local len = #arr"], ["-- Write a function that accepts two tables of strings and returns the table that has \n-- total number of chars in the all strings of the table less than the other table.\n-- if the two tables have the same number of chars, return the first table.\n-- Examples\n-- >>> total_match({}, {})\n-- {}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'Hi'})\n-- {'hI', 'Hi'}\n-- >>> total_match({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'})\n-- {'hi', 'admin'}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'hi', 'hi'})\n-- {'hI', 'hi', 'hi'}\n-- >>> total_match({'4'}, {'1', '2', '3', '4', '5'})\n-- {'4'}\nlocal function total_match(lst1, lst2)\n  if #lst1 == #lst2 then\n    return lst1\n  elseif #lst1 > #lst2 then\n    return total_match({}, lst2)\n  else\n    return total_match({}, lst1)\n  end\nend"], ["-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100. \n-- Example:\n-- >>> is_multiply_prime(30)\n-- true\n-- 30 = 2 * 3 * 5\nlocal function is_multiply_prime(a)\n  local b = 2\n  local c = 3\n  while b * b <= a do\n    if a % b ~= 0 or a % c ~= 0 then\n      return false\n    end\n    b = b + 1\n    c = c + 2\n  end\n  return true\nend"], ["-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2, 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3, 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5, 3)\n-- false\nlocal function is_simple_power(x, n)\n  if n == 1 then\n    return true\n  end\n  if n == 2 then\n    return x == 1\n  end\n  if n == 3 then\n    return x == 2\n  end\n  local y = n**int\n  return is_simple_power(y, n)\nend"], ["-- Write a function that takes an integer a and returns true \n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- >>> iscube(1)\n-- true\n-- >>> iscube(2)\n-- false\n-- >>> iscube(-1)\n-- true\n-- >>> iscube(64)\n-- true\n-- >>> iscube(0)\n-- true\n-- >>> iscube(180)\n-- false\nlocal function iscube(a)\n  if a == 0 then\n    return false\n  end\n  if a == 1 then\n    return true\n  end\n  local b = a / 2\n  return iscube(b) and iscube(b)\nend"], ["-- You have been tasked to write a function that receives \n-- a hexadecimal number as a string and counts the number of hexadecimal \n-- digits that are primes (prime number, or a prime, is a natural number \n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7, \n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string, \n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>> hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n-- 2\nlocal function hex_key(num)\n  local count = 0\n  for I = 1, #num do\n    local digit = num:sub(i, i):byte()\n    if digit >= 0 and digit <= 9 then\n      count = count + 1\n    end\n  end\n  return count\nend\n```"], ["-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n-- 'db100000db'\nlocal function decimal_to_binary(decimal)\n  local binary = ''\n  local decimal_part = decimal\n  local binary_part = ''\n  local count = 0\n  while decimal_part > 0 do\n    local remainder = decimal_part % 2\n    decimal_part = math.floor(decimal_part / 2)\n    binary_part = string.format('%01d', remainder)\n    count = count + 1\n  end\n  binary = binary .. binary_part\n  if count > 1 then\n    binary = binary .. 'db'\n  end\n  return binary\nend"], ["-- You are given a string s.\n-- Your task is to check if the string is haplua or not.\n-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- >>> is_happy('a')\n-- false\n-- >>> is_happy('aa')\n-- false\n-- >>> is_happy('abcd')\n-- true\n-- >>> is_happy('aabb')\n-- false\n-- >>> is_happy('adb')\n-- true\n-- >>> is_happy('xyy')\n-- false\nlocal function is_happy(s)\n  local n = #s\n  local count = {}\n  for I = 1, n do\n    local char = s:sub(i, i)\n    if count[char] then\n      count[char] = count[char] + 1\n    else\n      count[char] = 1\n    end\n  end\n  for I = 1, n do\n    local char = s:sub(i, i)\n    if count[char] == 3 then\n      return true\n    end\n  end\n  return false\nend\n```"], ["-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a table of GPAs for some students and you have to write \n-- a function that can output a table of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A \n--         > 3.3                A- \n--         > 3.0                B+\n--         > 2.7                B \n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+ \n--         > 0.7                D \n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})\n-- {'A+', 'B', 'C-', 'C', 'A-'}\nlocal function numerical_letter_grade(grades)\n  local letter_grades = {}\n  for _, grade in ipairs(grades) do\n    local letter = grade >= 3.7 and 'A+' or (grade >= 3.3 and 'A' or (grade >= 3.0 and 'A-' or (grade >= 2.7 and 'B+' or (grade >= 2.3 and 'B' or (grade >= 2.0 and 'B-' or 'C+'))))))\n    table.insert(letter_grades, letter)\n  end\n  return letter_grades\nend"], ["-- Write a function that takes a string and returns true if the string\n-- length is a prime number or false otherwise\n-- Examples\n-- >>> prime_length('Hello')\n-- true\n-- >>> prime_length('abcdcba')\n-- true\n-- >>> prime_length('kittens')\n-- true\n-- >>> prime_length('orange')\n-- false\nlocal function prime_length(string)\n  local length = 0\n  for I = 1, #string do\n    if string:sub(i, i):match('^%d+$') then\n      length = length + 1\n    end\n  end\n  return length == 2 or length == 3\nend\n```"], ["-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n  local count = 0\n  for I = 1, math.floor(n/10) do\n    local digit = n % 10\n    if digit == 1 then\n      count = count + 1\n    end\n    n = n % 10\n  end\n  return count\nend"], ["-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n-- >>> solve(1000)\n-- '1'\n-- >>> solve(150)\n-- '110'\n-- >>> solve(147)\n-- '1100'\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nlocal function solve(N)\n  local result = \"\"\n  local digits = {}\n  for I = 0, math.floor(N / 2) do\n    local digit = math.floor(N / 2) - I\n    digits[digit] = digit\n  end\n  for I = math.floor(N / 2) + 1, N do\n    local digit = math.floor(N / 2) - I\n    digits[digit] = digit\n  end\n  for I = 0, math.floor(N / 2) do\n    local digit = math.floor(N / 2) - I\n    result = result .. digits[digit]\n  end\n  return result\nend\n```"], ["-- Given a non-empty table of integers lst. add the even elements that are at odd indices..\n-- Examples:\n-- >>> add({4, 2, 6, 7})\n-- 2\nlocal function add(lst)\n  local even = {}\n  for I, num in ipairs(lst) do\n    if num % 2 ~= 0 then\n      even[i] = num\n    end\n  end\n  return even\nend\n```"], ["-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- >>> anti_shuffle('Hi')\n-- 'Hi'\n-- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n-- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n  local new_string = {}\n  local current_string = s\n  local current_index = 1\n  while current_index <= #current_string do\n    local current_char = current_string:sub(current_index, current_index)\n    local next_index = math.random(current_index, #current_string)\n    local next_char = current_string:sub(next_index, next_index)\n    if next_char == ' ' then\n      table.insert(new_string, current_char)\n    else\n      table.insert(new_string, next_char)\n    end\n    current_index = next_index\n  end\n  return table.concat(new_string)\nend"], ["-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local rows = {}\n  local columns = {}\n  for I, v in ipairs(lst) do\n    if type(v) == \"table\" then\n      for j, v2 in ipairs(v) do\n        if type(v2) == \"table\" then\n          local row = {}\n          for k, v3 in ipairs(v2) do\n            if type(v3) == \"number\" then\n              row[k] = v3\n            else\n              row[k] = {v3}\n            end\n          end\n          table.insert(rows, row)\n        else\n          table.insert(rows, {v2})\n        end\n      end\n    else\n      table.insert(rows, {v})\n    end\n  end\n  local sorted_rows = {}\n  for I, row in ipairs(rows) do\n    local sorted_row = {}\n    for j, v in ipairs(row) do\n      if type("], ["-- Given a table of non-negative integers, return a colua of the given table after sorting,\n-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given table.\n-- Examples:\n-- >>> sort_array({})\n-- {}\n-- >>> sort_array({5})\n-- {5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5})\n-- {0, 1, 2, 3, 4, 5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})\n-- {6, 5, 4, 3, 2, 1, 0}\nlocal function sort_array(array)\n  local sorted_array = {}\n  for I, num in ipairs(array) do\n    if num % 2 == 1 then\n      sorted_array[#sorted_array+1] = num\n    else\n      sorted_array[#sorted_array+1] = num + 1\n    end\n  end\n  return sorted_array\nend\n```"], ["-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated. \n-- The alphabet should be rotated in a manner such that the letters \n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n-- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal function encrypt(s)\n  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local rotated = {}\n  for I = 1, #alphabet do\n    rotated[#rotated+1] = alphabet:sub(i, i)\n  end\n  for I = 1, #s do\n    local letter = s:sub(i, i)\n    local index = rotated[#rotated]\n    rotated[#rotated+1] = index\n    rotated[#rotated+1] = letter\n  end\n  return table.concat(rotated, '')\nend"], ["-- You are given a table of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the table.\n-- Return nil if there is no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5, 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1, 1})\n-- None\nlocal function next_smallest(lst)\n  local min_idx = 1\n  local min_val = lst[1]\n  for I, v in ipairs(lst) do\n    if v < min_val then\n      min_idx = i\n      min_val = v\n    end\n  end\n  return min_val\nend\n```"], ["-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored('Hello world')\n-- 0\n-- >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n-- 1\nlocal function is_bored(S)\n  local count = 0\n  for I, word in ipairs(S) do\n    if word:match('^%?%s*%w+$') then\n      count = count + 1\n    end\n  end\n  return count == 0\nend\n```"], ["-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- >>> any_int(5, 2, 7)\n-- true\n-- >>> any_int(3, 2, 2)\n-- false\n-- >>> any_int(3, -2, 1)\n-- true\n-- >>> any_int(3.6, -2.2, 2)\n-- false\nlocal function any_int(x, y, z)\n  if x ~= y and x ~= z then\n    return false\n  elseif x == y and x == z then\n    return true\n  else\n    return false\n  end\nend\n```"], ["-- Write a function that takes a message, and encodes in such a \n-- way that it swaps case of all letters, replaces all vowels in \n-- the message with the letter that appears 2 places ahead of that \n-- vowel in the english alphabet. \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n-- >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n  local result = \"\"\n  for I, letter in ipairs(message) do\n    if letter == 'a' or letter == 'e' or letter == 'i' or letter == 'o' or letter == 'u' then\n      result = result .. string.sub(message, 1, 2)\n    else\n      result = result .. string.sub(message, 1, 1)\n      result = result .. string.sub(message, 2, 1)\n    end\n  end\n  return result\nend"], ["-- You are given a table of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- >>> skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n-- >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n-- 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0, 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n  local max = 0\n  local sum = 0\n  for I, v in ipairs(lst) do\n    local n = tonumber(v)\n    if n ~= 0 then\n      max = max + n\n      sum = sum + n\n    end\n  end\n  return max, sum\nend\n```"], ["-- Given a table, return true if all keys are strings in lower \n-- case or all keys are strings in upper case, else return false.\n-- The function should return false is the given table is empty.\n-- Examples:\n-- >>> check_dict_case({['a'] = 'apple', ['b'] = 'banana'})\n-- true\n-- >>> check_dict_case({['a'] = 'apple', ['A'] = 'banana', ['B'] = 'banana'})\n-- false\n-- >>> check_dict_case({['a'] = 'apple', [8] = 'banana', ['a'] = 'apple'})\n-- false\n-- >>> check_dict_case({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'})\n-- false\n-- >>> check_dict_case({['STATE'] = 'NC', ['ZIP'] = '12345'})\n-- true\nlocal function check_dict_case(dict)\n  if #dict == 0 then\n    return true\n  end\n  for k, v in pairs(dict) do\n    if type(k) ~= 'string' or type(v) ~= 'string' then\n      return false\n    end\n    if type(k) == 'string' and type(v) == 'string' and k:lower() == v:lower() then\n      return true\n    end\n  end\n  return false\nend\n```"], ["-- Implement a function that takes an non-negative integer and returns a table of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- >>> count_up_to(5)\n-- {2, 3}\n-- >>> count_up_to(11)\n-- {2, 3, 5, 7}\n-- >>> count_up_to(0)\n-- {}\n-- >>> count_up_to(20)\n-- {2, 3, 5, 7, 11, 13, 17, 19}\n-- >>> count_up_to(1)\n-- {}\n-- >>> count_up_to(18)\n-- {2, 3, 5, 7, 11, 13, 17}\nlocal function count_up_to(n)\n  local result = {}\n  for I = 2, n do\n    if is_prime(i) then\n      table.insert(result, i)\n    end\n  end\n  return result\nend"], ["-- Complete the function that takes two integers and returns \n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020, 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n  if b == 0 then\n    return a\n  elseif b == 1 then\n    return a\n  else\n    return a * b\n  end\nend\n```"], ["-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- >>> count_upper('aBCdEf')\n-- 1\n-- >>> count_upper('abcdefg')\n-- 0\n-- >>> count_upper('dBBE')\n-- 0\nlocal function count_upper(s)\n  local count = 0\n  for I = 1, #s do\n    if s:sub(i, i):lower() == s:sub(i, i):upper() then\n      count = count + 1\n    end\n  end\n  return count\nend\n```"], ["-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n-- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest_integer = 0\n  local closest_integer_distance = 0\n  local closest_integer_index = 0\n  local distance_from_two_integers = 0\n  local distance_from_zero = 0\n  local integer_index = 0\n  local integer_value = tonumber(value)\n  for I = 1, #value do\n    local integer_value = tonumber(value:sub(i, i))\n    distance_from_zero = abs(integer_value - 0)\n    distance_from_two_integers = distance_from_zero + distance_from_zero\n    if distance_from_zero < closest_integer_distance then\n      closest_integer_distance = distance_from_zero\n      closest_integer = integer_value\n      closest_integer_index = integer_index\n    end\n    if distance_from_zero == 0 then\n      closest_integer_index = integer_index\n    end\n  end\n  return closest_integer, closest_integer_index\nend"], ["-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a table, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n-- {3, 5, 7}\nlocal function make_a_pile(n)\n  local result = {}\n  local level = 1\n  while n > 0 do\n    local num = math.floor(n / 2)\n    n = n % 2\n    result[level] = num\n    level = level + 1\n  end\n  return result\nend"], ["-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return a table of the words.\n-- For example:\n-- >>> words_string('Hi, my name is John')\n-- {'Hi', 'my', 'name', 'is', 'John'}\n-- >>> words_string('One, two, three, four, five, six')\n-- {'One', 'two', 'three', 'four', 'five', 'six'}\nlocal function words_string(s)\n  local words = {}\n  for word in s:gmatch('%S+') do\n    table.insert(words, word)\n  end\n  return words\nend\n```"], ["-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If \n-- there's no such number, then the function should return -1.\n-- For example:\n-- >>> choose_num(12, 15)\n-- 14\n-- >>> choose_num(13, 12)\n-- -1\nlocal function choose_num(x, y)\n  if y < x then\n    return -1\n  end\n  local max_num = x\n  for I = x, y, 2 do\n    if i % 2 == 0 then\n      max_num = i\n    end\n  end\n  return max_num\nend"], ["-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m). \n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7, 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n-- '0b11010'\nlocal function rounded_avg(n, m)\n  if n > m then\n    return -1\n  end\n  local avg = 0\n  for I = n, m do\n    avg = avg + i\n  end\n  return avg / math.floor(avg / m)\nend\n```"], ["-- Given a table of positive integers x. return a sorted table of all \n-- elements that hasn't any even digit.\n-- Note: Returned table should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits({15, 33, 1422, 1})\n-- {1, 15, 33}\n-- >>> unique_digits({152, 323, 1422, 10})\n-- {}\nlocal function unique_digits(x)\n  local result = {}\n  for I, num in ipairs(x) do\n    if num ~= math.floor(num) and num ~= 0 then\n      table.insert(result, num)\n    end\n  end\n  return result\nend\n```"], ["-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting table, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})\n-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}\n--   If the table is empty, return an empty table:\n-- >>> by_length({})\n-- {}\n--   If the table has any strange number ignore it:\n-- >>> by_length({1, -1, 55})\n-- {'One'}\nlocal function by_length(arr)\n  if #arr == 0 then\n    return {}\n  end\n  local sorted = {}\n  for I, num in ipairs(arr) do\n    sorted[num] = i\n  end\n  local reverse = {}\n  for I, num in ipairs(sorted) do\n    reverse[num] = i\n  end\n  for I, num in ipairs(sorted) do\n    local name = reverse[num]\n    sorted[num] = name\n  end\n  return sorted\nend\n```"], ["-- Implement the function f that takes n as a parameter,\n-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- >>> f(5)\n-- {1, 2, 6, 24, 15}\nlocal function f(n)\n  local result = {}\n  for I = 1, n do\n    result[i] = math.factorial(i) * (i == 1 and 1 or math.sum(1, i))\n  end\n  return result\nend"], ["-- Given a positive integer n, return a table that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n-- >>> even_odd_palindrome(3)\n-- {1, 2}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n-- >>> even_odd_palindrome(12)\n-- {4, 6}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned table has the number of even and odd integer palindromes respectively.\nlocal function even_odd_palindrome(n)\n  local even_palindromes = {}\n  local odd_palindromes = {}\n  for I = 1, n do\n    local even_num = math.floor(i / 2)\n    local odd_num = i - even_num\n    if even_num % 2 == 0 then\n      even_palindromes[#even_palindromes + 1] = even_num\n    else\n      odd_palindromes[#odd_palindromes + 1] = odd_num\n    end\n  end\n  return even_palindromes, odd_palindromes\nend\n```"], ["-- Write a function count_nums which takes a table of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums({})\n-- 0\n-- >>> count_nums({-1, 11, -11})\n-- 1\n-- >>> count_nums({1, 1, 2})\n-- 3\nlocal function count_nums(arr)\n  local sum = 0\n  for I, num in ipairs(arr) do\n    sum = sum + num\n    if sum > 0 and num ~= 0 then\n      return I\n    end\n  end\n  return 0\nend"], ["-- We have a table 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the table will be randomly ordered. Your task is to determine if\n-- it is possible to get a table sorted in non-decreasing order by performing \n-- the following operation on the given table:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the table by one\n-- position in the right direction. The last element of the table will be moved to\n-- the starting position in the table i.e. 0th index. \n-- If it is possible to obtain the sorted table by performing the above operation\n-- then return true else return false.\n-- If the given table is empty then return true.\n-- Note: The given table is guaranteed to have unique elements.\n-- For Example:\n-- >>> move_one_ball({3, 4, 5, 1, 2})\n-- true\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given table.\n-- >>> move_one_ball({3, 5, 4, 1, 2})\n-- false\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             table by performing any number of right shift operations.\nlocal function move_one_ball(arr)\n  if #arr == 0 then\n    return true\n  end\n  local n = #arr\n  local shifted_arr = {}\n  for I = 1, n do\n    shifted_arr[i] = arr[i]\n  end\n  local last_index = n - 1\n  for I = n, 1, -1 do\n    if shifted_arr[i] > shifted_arr[i - 1] then\n      table.insert(shifted_arr, 1, shifted_arr[i])\n      table.insert(shifted_arr, last_index)\n      last_index = i\n    end\n  end\n  table.insert(shifted_arr, last_index)\n  return true\nend"], ["-- In this problem, you will implement a function that takes two tables of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a table of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\nlocal function exchange(lst1, lst2)\n  -- Check if the tables are empty\n  if #lst1 == 0 or #lst2 == 0 then\n    return \"NO\"\n  end\n  -- Initialize the result variable\n  local result = \"\"\n  -- Iterate through the tables\n  for I = 1, #lst1 do\n    -- Check if the current element of lst1 is even\n    if lst1[i] % 2 == 0 then\n      -- If it is, swap it with the next element\n      local temp = lst1[i]\n      lst1[i] = lst2[i]\n      lst2[i] = temp\n      -- Check if the result is still \"YES\"\n      if exchange(lst1, lst2) == \"YES\" then\n        -- If it is, return \"YES\"\n        return \"YES\"\n      end\n    end\n  end\n  -- If the result is still \"NO\", return \"NO\"\n  return \"NO\"\nend"], ["-- Given a string representing a space separated lowercase letters, return a table\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- >>> histogram('a b c')\n-- {['a'] = 1, ['b'] = 1, ['c'] = 1}\n-- >>> histogram('a b b a')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('a b c a b')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('b b b b a')\n-- {['b'] = 4}\n-- >>> histogram('')\n-- {}\nlocal function histogram(test)\n  local table = {}\n  local count = 0\n  for char in test:gmatch('%w+') do\n    table[char] = table[char] or 1\n    table[char] = table[char] + 1\n    count = count + table[char]\n  end\n  return table, count\nend\n```"], ["-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a table containing the result string and true/false for the check.\n-- Example\n-- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n-- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba', 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n  local result = {}\n  local function delete_char(s, c)\n    if s[c] == c then\n      result[#result+1] = s:sub(1, c-1)\n      s = s:sub(c+1)\n    end\n  end\n  for I, v in ipairs(s) do\n    if v == c then\n      delete_char(s, i)\n    end\n  end\n  if #result > 0 then\n    result[#result+1] = s\n  end\n  return result, true\nend\n```"], ["-- Given a table of strings, where each string consists of only digits, return a table.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count({'1234567'})\n-- {'the number of odd elements 4n the str4ng 4 of the 4nput.'}\n-- >>> odd_count({'3', '11111111'})\n-- {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'}\nlocal function odd_count(lst)\n  local count = {}\n  for I, v in ipairs(lst) do\n    if v:match('^%d+$') then\n      count[#count+1] = I\n    end\n  end\n  return count\nend"], ["-- Given a table of integers nums, find the minimum sum of any non-empty sub-table\n-- of nums.\n-- Example\n-- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n-- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n  if not nums or not next(nums) or #nums < 2 then\n    return 0\n  end\n  local minSum = math.max(nums[1], nums[2])\n  for I = 3, #nums do\n    local sum = nums[i]\n    if sum < minSum then\n      minSum = sum\n    end\n    if sum > minSum then\n      minSum = sum\n    end\n  end\n  return minSum\nend\n```"], ["-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it, \n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local buckets = {}\n  for I = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j] == 1 then\n        buckets[#buckets+1] = {grid[i][j], j}\n      end\n    end\n  end\n  local max_fill = 0\n  for I = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j] == 0 and buckets[#buckets] and buckets[#buckets][1] == j then\n        buckets[#buckets][2] = j\n        max_fill = math"], ["-- In this Kata, you have to sort a table of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2, -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n-- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n  local sorted_arr = {}\n  for I, num in ipairs(arr) do\n    if num > 0 then\n      sorted_arr[#sorted_arr+1] = num\n    end\n  end\n  return sorted_arr\nend"], ["-- Given a string s and a natural number n, you have been tasked to implement \n-- a function that returns a table of all words from string s that contain exactly \n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty table.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- >>> select_words('Mary had a little lamb', 4)\n-- {'little'}\n-- >>> select_words('Mary had a little lamb', 3)\n-- {'Mary', 'lamb'}\n-- >>> select_words('simple white space', 2)\n-- {}\n-- >>> select_words('Hello world', 4)\n-- {'world'}\n-- >>> select_words('Uncle sam', 3)\n-- {'Uncle'}\nlocal function select_words(s, n)\n  local result = {}\n  for I = 1, #s do\n    local word = s:sub(i, i)\n    if word:match('^%a') then\n      local consonants = {}\n      for I = 1, n do\n        consonants[#consonants+1] = word:sub(i, i)\n      end\n      table.insert(result, {word, consonants})\n    end\n  end\n  return result\nend\n```"], ["-- You are given a word. Your task is to find the closest vowel that stands between \n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition. \n-- You may assume that the given string contains English letter only.\n-- Example:\n-- >>> get_closest_vowel('yogurt')\n-- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n-- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n  local vowels = {'.', 'a', 'e', 'i', 'o', 'u'}\n  local closest_vowel = ''\n  for I, vowel in ipairs(vowels) do\n    if word:sub(i, i) == vowel then\n      closest_vowel = vowel\n      break\n    end\n  end\n  return closest_vowel\nend"], ["-- You are given a table of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(', ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n  if #lst == 1 then\n    return true\n  end\n  local open, close = lst[1], lst[#lst]\n  if open == '(' and close == ')' then\n    return true\n  end\n  if open == '(' and close == '(' then\n    return match_parens(lst[2]) and match_parens(lst[3])\n  end\n  if open == ')' and close == '(' then\n    return match_parens(lst[1]) and match_parens(lst[2])\n  end\n  if open == '(' and close == ')' then\n    return match_parens(lst[1]) and match_parens(lst[2]) and match_parens(lst[3])\n  end\n  return false\nend"], ["-- Given a table arr of integers and a positive integer k, return a sorted table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>> maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4, 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n-- {2}\n-- Note:\n--     1. The length of the table will be in the range of [1, 1000].\n--     2. The elements in the table will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n  local max_arr = {}\n  for I = 1, #arr do\n    local max_val = arr[i]\n    for j = 1, k do\n      if max_val > arr[i + j] then\n        max_arr[#max_arr + 1] = arr[i + j]\n      end\n    end\n  end\n  return max_arr\nend\n```"], ["-- Given a non-empty table of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- >>> solution({5, 8, 7, 1})\n-- 12\n-- >>> solution({3, 3, 3, 3, 3})\n-- 9\n-- >>> solution({30, 13, 24, 321})\n-- 0\nlocal function solution(lst)\n  local sum = 0\n  for I, num in ipairs(lst) do\n    if num % 2 ~= 0 then\n      sum = sum + num\n    end\n  end\n  return sum\nend\n```"], ["-- Given a non-empty table of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n-- 24\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nlocal function add_elements(arr, k)\n  if k == 0 then\n    return 0\n  end\n  local sum = 0\n  for I = 1, #arr do\n    local digit = arr[i]\n    if digit > 9 then\n      return 0\n    end\n    local digit_sum = digit + add_elements(arr, k - 1)\n    if digit_sum > 9 then\n      return 0\n    end\n    sum = sum + digit_sum\n  end\n  return sum\nend\n```"], ["-- Given a positive integer n, return a sorted table that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the \n-- previous term as follows: if the previous term is even, the next term is one half of \n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note: \n--     1. Collatz(1) is [1].\n--     2. returned table sorted in increasing order.\n-- For example:\n-- get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n-- >>> get_odd_collatz(5)\n-- {1, 5}\nlocal function get_odd_collatz(n)\n  local collatz_table = {}\n  local odd_num = 1\n  local prev_num = n\n  while prev_num ~= 1 do\n    local next_num = 3 * prev_num + 1\n    if next_num ~= prev_num then\n      collatz_table[#collatz_table+1] = next_num\n    end\n    prev_num = next_num\n  end\n  collatz_table[#collatz_table+1] = prev_num\n  return collatz_table\nend"], ["-- You have to write a function which validates a given date string and\n-- returns true if the date is valid otherwise false.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- >>> valid_date('03-11-2000')\n-- true\n-- >>> valid_date('15-01-2012')\n-- false\n-- >>> valid_date('04-0-2040')\n-- false\n-- >>> valid_date('06-04-2020')\n-- true\n-- >>> valid_date('06/04/2020')\n-- false\nlocal function valid_date(date)\n  local month = string.match(date, \"%d%d%d-%d-%d\")\n  local day = string.match(date, \"%d%d%d-%d-%d\")\n  local year = string.match(date, \"%d%d%d-%d-%d\")\n  if month and day and year then\n    local days = tonumber(month) + 1 + tonumber(day)\n    if days < 1 or days > 31 then\n      return false\n    end\n    if days < 1 or days > 30 then\n      return false\n    end\n    if month:match(\"^%d\") then\n      month = month:gsub(\"%d\", \"\")\n    end\n    if year:match(\"^%d\") then\n      year = year:gsub(\"%d\", \"\")\n    end\n    if month:match(\"^%d\") and year:match(\"^%d\")"], ["-- Given a string of words, return a table of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n  local words = {}\n  local I = 1\n  local j = 1\n  while I <= #txt do\n    local c = txt:sub(i, i)\n    if c == ' ' then\n      table.insert(words, txt:sub(j, j))\n      j = j + 1\n    elseif c == ', ' then\n      table.insert(words, txt:sub(j, j))\n      j = j + 1\n    elseif c:match('^[a-z]+$') then\n      table.insert(words, txt:sub(j, j))\n      j = j + 1\n    else\n      table.insert(words, txt:sub(j, j))\n      j = j + 1\n    end\n    I = I + 1\n  end\n  return words\nend"], ["-- Given a table of numbers, return whether or not they are sorted\n-- in ascending order. If table has more than 1 duplicate of the same\n-- number, return false. Assume no negative numbers and only integers.\n-- Examples\n-- >>> is_sorted({5})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n-- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3, 4})\n-- false\nlocal function is_sorted(lst)\n  if #lst == 0 then\n    return true\n  end\n  local n = #lst\n  for I = 1, n do\n    local a, b = lst[i], lst[i+1]\n    if a ~= b then\n      return false\n    end\n  end\n  return true\nend\n```"], ["-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two \n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1, interval2)\n  if interval1.start > interval2.end then\n    return \"NO\"\n  end\n  if interval1.end > interval2.start then\n    return \"NO\"\n  end\n  local start1 = interval1.start\n  local end1 = interval1.end\n  local start2 = interval2.start\n  local end2 = interval2.end\n  while start1 <= end1 and start2 <= end2 do\n    if start1 == start2 then\n      return \"YES\"\n    end\n    if start1 > end1 then\n      start1 = start1 + 1\n    elseif start2 > end2 then\n      start2 = start2 + 1\n    end\n  end\n  return \"NO\"\nend"], ["-- You are given a table arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the table, represented by 1, -1 or 0.\n-- Note: return nil for empty arr.\n-- Example:\n-- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n-- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n  if #arr == 0 then\n    return nil\n  end\n  local prod = 1\n  for I, v in ipairs(arr) do\n    prod = prod * v\n    if v == -1 then\n      prod = -prod\n    end\n  end\n  return prod\nend\n```"], ["-- Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered tables of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered table of the values on the cells that the minimum path go through.\n-- Examples:    \n-- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid, k)\n  local visited = {}\n  local visited_count = {}\n  local visited_count_max = 0\n  local visited_count_min = 0\n  local visited_count_max_min = 0\n  local visited_count_min_max = 0\n  local visited_count_min_min = 0\n  local visited_count_max_max ="], ["-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri(1) = 3\n-- tri(n) = 1 + n / 2, if n is even.\n-- tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n-- For example:\n-- tri(2) = 1 + (2 / 2) = 2\n-- tri(4) = 3\n-- tri(3) = tri(2) + tri(1) + tri(4)\n--        = 2 + 3 + 3 = 8 \n-- You are given a non-negative integer number n, you have to a return a table of the \n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- >>> tri(3)\n-- {1, 3, 2, 8}\nlocal function tri(n)\n  if n <= 1 then\n    return {1}\n  elseif n == 2 then\n    return {1, 1}\n  elseif n == 3 then\n    return {1, 2, 1}\n  else\n    local result = {}\n    for I = 1, n do\n      result[i] = tri(n - I) + tri(n - I - 1) + tri(n - I + 1)\n    end\n    return result\n  end\nend"], ["-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- >>> digits(1)\n-- 1\n-- >>> digits(4)\n-- 0\n-- >>> digits(235)\n-- 15\nlocal function digits(n)\n  if n < 0 then\n    return 0\n  end\n  local result = 1\n  for I = 1, math.floor(math.log10(n)) do\n    local digit = n % 10\n    result = result * digit\n    n = math.floor(n / 10)\n  end\n  return result\nend\n```"], ["-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return true if and only if there is a valid subsequence of brackets \n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n-- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n-- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal function is_nested(string)\n  local brackets = {}\n  for I, char in ipairs(string) do\n    if char == '[' then\n      table.insert(brackets, i)\n    elseif char == ']' then\n      if table.count(brackets) > 0 then\n        return true\n      end\n    end\n  end\n  return false\nend\n```"], ["-- You are given a table of numbers.\n-- You need to return the sum of squared numbers in the given table,\n-- round each element in the table to the upper int(Ceiling) first.\n-- Examples:\n-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0, 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n-- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n  local sum = 0\n  for I, num in ipairs(lst) do\n    sum = sum + num * num\n  end\n  return math.ceil(sum / 2)\nend"], ["-- Create a function that returns true if the last character\n-- of a given string is an alphabetical character and is not\n-- a part of a word, and false otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n-- Examples:\n-- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>> check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal function check_if_last_char_is_a_letter(txt)\n  local last_char = txt:sub(-1)\n  local is_letter = last_char:match(\"^[a-zA-Z]$\")\n  return is_letter and not is_letter:match(\"^%s*$\")\nend\n```"], ["-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given table will not contain\n-- duplicate values.\n-- Examples:\n-- >>> can_arrange({1, 2, 4, 3, 5})\n-- 3\n-- >>> can_arrange({1, 2, 3})\n-- -1\nlocal function can_arrange(arr)\n  local largest_index = 0\n  for I = 1, #arr do\n    local current_index = I\n    while arr[current_index] <= arr[i] do\n      current_index = current_index - 1\n    end\n    if current_index ~= largest_index then\n      largest_index = current_index\n    end\n  end\n  return largest_index\nend\n```"], ["-- Create a function that returns a table (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n-- If there is no negative or positive integers, return them as nil.\n-- Examples:\n-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n-- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function largest_smallest_integers(lst)\n  if #lst == 0 then\n    return {nil, nil}\n  end\n  local largest = lst[#lst]\n  local smallest = lst[#lst + 1]\n  return {largest, smallest}\nend"], ["-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return nil if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one(1, 2.5)\n-- 2.5\n-- >>> compare_one(1, '2,3')\n-- '2,3'\n-- >>> compare_one('5,1', '6')\n-- '6'\n-- >>> compare_one('1', 1)\n-- None\nlocal function compare_one(a, b)\n  if type(a) ~= 'number' or type(b) ~= 'number' then\n    return nil\n  end\n  if a == b then\n    return a\n  elseif a > b then\n    return a\n  else\n    return b\n  end\nend"], ["-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even(4)\n-- false\n-- >>> is_equal_to_sum_even(6)\n-- false\n-- >>> is_equal_to_sum_even(8)\n-- true\nlocal function is_equal_to_sum_even(n)\n  if n < 0 then\n    return false\n  end\n  if n == 0 then\n    return true\n  end\n  if n % 2 == 0 then\n    return true\n  else\n    return is_equal_to_sum_even(n / 2)\n  end\nend\n```"], ["-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial(4)\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nlocal function special_factorial(n)\n  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n  else\n    return n * special_factorial(n-1)\n  end\nend"], ["-- Given a string text, replace all spaces in it with underscores, \n-- and if a string has more than 2 consecutive spaces, \n-- then replace all consecutive spaces with - \n-- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces(' Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n-- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n  local new_text = \"\"\n  for I = 1, #text do\n    local char = text:sub(i, i)\n    if char == \" \" then\n      new_text = new_text .. \"_\"\n    else\n      new_text = new_text .. char\n    end\n  end\n  return new_text\nend\n```"], ["-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions \n-- are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from \n-- the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check('example.txt')\n-- 'Yes'\n-- >>> file_name_check('1example.dll')\n-- 'No'\nlocal function file_name_check(file_name)\n  local valid = true\n  local dot_index = string.find(file_name, '.')\n  if not dot_index then\n    return 'No'\n  end\n  local before_dot = string.sub(file_name, 1, dot_index - 1)\n  if not before_dot:match('^[a-z]+$') then\n    return 'No'\n  end\n  local after_dot = string.sub(file_name, dot_index + 1)\n  if not after_dot:match('^[a-z]+$') then\n    return 'No'\n  end\n  return 'Yes'\nend"], ["-- \"\n-- This function will take a table of integers. For all entries in the table, the function shall square the integer entry if its index is a \n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n-- change the entries in the table whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n-- Examples:\n-- >>> lst\n-- {1, 2, 3}\n-- >>> lst\n-- {}\n-- >>> lst\n-- {-1, -5, 2, -1, -5}\nlocal function sum_squares(lst)\n  local sum = 0\n  for I, num in ipairs(lst) do\n    if num % 3 == 0 and num % 4 ~= 0 then\n      sum = sum + num * num\n    elseif num % 3 ~= 0 then\n      sum = sum + num * num\n    elseif num % 4 ~= 0 then\n      sum = sum + num * num\n    end\n  end\n  return sum\nend"], ["-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n-- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n--     * 1 <= len(sentence) <= 100\n--     * sentence contains only letters\nlocal function words_in_sentence(sentence)\n    local words = {}\n    for word in sentence:gmatch(\"([^%s]+)\") do\n        local length = #word\n        if length > 1 and string.sub(word, 1, 1) ~= ' ' then\n            table.insert(words, word:sub(2))\n        end\n    end\n    return table.concat(words, ' ')\nend\n```"], ["-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns true if x * n evaluates to a whole number and false\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n-- >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\nlocal function simplify(x, n)\n  if x == '0' then\n    return false\n  end\n  if n == '0' then\n    return true\n  end\n  local numerator, denominator = string.match(x, '([%d]+)/([%d]+)')\n  if numerator == nil then\n    return false\n  end\n  local numerator_int = tonumber(numerator)\n  local denominator_int = tonumber(denominator)\n  if numerator_int == 0 then\n    return false\n  end\n  local numerator_float = tonumber(numerator) / tonumber(denominator)\n  if numerator_float == 0 then\n    return false\n  end\n  local result = string.format('%.2f', numerator_float)\n  return result\nend"], ["-- Write a function which sorts the given table of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original table.\n-- For example:\n-- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1, -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n  local sorted_nums = {}\n  for _, num in ipairs(nums) do\n    local sum = 0\n    for I, digit in ipairs(num) do\n      sum = sum + digit\n    end\n    sorted_nums[#sorted_nums+1] = sum\n  end\n  return sorted_nums\nend"], ["-- Write a function that takes a table of numbers as input and returns \n-- the number of elements in the table that are greater than 10 and both \n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter({15, -73, 14, -15})\n-- 1\n-- >>> specialFilter({33, -2, -3, 45, 21, 109})\n-- 2\nlocal function specialFilter(nums)\n  local count = 0\n  for I, num in ipairs(nums) do\n    if num > 10 and (num:match(\"%d%d%d\") and (num:match(\"%d%d\") ~= num:match(\"%d%d\"))) then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["-- You are given a positive integer n. You have to create an integer table a of length n.\n-- For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n--     and a[i] + a[j] + a[k] is a multiple of 3.\n--     Example :\n--     >>> get_max_triples(5)\n--     1\n-- Explanation: \n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nlocal function get_max_triples(n)\n    local a = {}\n    for I = 1, n do\n        a[i] = i * i - i + 1\n    end\n    local max_triples = 0\n    for I = 1, n do\n        for j = I + 1, n do\n            for k = j + 1, n do\n                if a[i] + a[j] + a[k] == 3 * (i + j + k) then\n                    max_triples = max_triples + 1\n                end\n            end\n        end\n    end\n    return max_triples\nend"], ["-- There are eight planets in our solar system: the closerst to the Sun \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2. \n-- The function should return a table containing all planets whose orbits are \n-- located between the orbit of planet1 and the orbit of planet2, sorted by \n-- the proximity to the sun. \n-- The function should return an empty table if planet1 or planet2\n-- are not correct planet names. \n-- Examples\n-- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n-- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\nlocal function bf(planet1, planet2)\n  local planets = {}\n  for I, planet in ipairs(planet2) do\n    if string.match(planet, planet1) then\n      table.insert(planets, planet)\n    end\n  end\n  return planets\nend"], ["-- Write a function that accepts a table of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted table with a sorted order,\n-- The table is always a table of strings and never a table of numbers,\n-- and it may contain duplicates.\n-- The order of the table should be ascending by length of each word, and you\n-- should return the table sorted by that rule.\n-- If two words have the same length, sort the table alphabetically.\n-- The function should return a table of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> list_sort({'aa', 'a', 'aaa'})\n-- {'aa'}\n-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})\n-- {'ab', 'cd'}\nlocal function sorted_list_sum(lst)\n  local result = {}\n  for word in lst:gmatch(\"%S+\") do\n    local len = tonumber(word)\n    if len ~= nil and len ~= 0 then\n      table.insert(result, word)\n    end\n  end\n  return result\nend"], ["-- A simple program which should return the value of x if n is \n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y(7, 34, 12)\n-- 34\n-- >>> x_or_y(15, 8, 5)\n-- 5\nlocal function x_or_y(n, x, y)\n  if n == 2 then\n    return x\n  elseif n == 3 or n == 5 then\n    return y\n  else\n    return x_or_y(n-1, x, y)\n  end\nend"], ["-- Given a table of numbers, return the sum of squares of the numbers\n-- in the table that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference({1, 3, 2, 0})\n-- 10\n-- >>> double_the_difference({-1, -2, 0})\n-- 0\n-- >>> double_the_difference({9, -2})\n-- 81\n-- >>> double_the_difference({0})\n-- 0\n-- If the input table is empty, return 0.\nlocal function double_the_difference(lst)\n  if #lst == 0 then\n    return 0\n  end\n  local sum = 0\n  for I, num in ipairs(lst) do\n    if num ~= 0 and num ~= -1 and num ~= -2 and num ~= 9 and num ~= 0 then\n      sum = sum + num * num\n    end\n  end\n  return sum\nend\n```"], ["-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two tables of scores and guesses of equal length, where each index shows a match. \n-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})\n-- {0, 0, 0, 0, 3, 3}\n-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})\n-- {4, 4, 1, 0, 0, 6}\nlocal function compare(game, guess)\n  local score = 0\n  for I, v in ipairs(game) do\n    score = score + v\n  end\n  local diff = score - guess\n  return {\n    {0, diff < 0},\n    {diff < 0, diff > 0},\n    {diff > 0, diff < 0},\n    {diff < 0, diff > 0},\n    {diff == 0, diff == 0}\n  }\nend"], ["-- You will be given the name of a class (a string) and a table of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters \n-- in the extension's name, the strength is given by the fraction CAP - SM. \n-- You should find the strongest extension and return a string in this \n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the table.\n-- For example, if you are given \"Slices\" as the class and a table of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n-- (its strength is -1).\n-- Example:\n-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name, extensions)\n  local strongest_extension = \"\"\n  local strength_counter = {}\n  for _, extension in ipairs(extensions) do\n    local strength = 0\n    for I = 1, #extension do\n      if extension:sub(i, i) == uppercase_letters[i] then\n        strength = strength + 1\n      elseif extension:sub(i, i) == lowercase_letters[i] then\n        strength = strength + 1\n      end\n    end\n    if strength > strength_counter[extension] then\n      strongest_extension = extension\n      strength_counter[extension] = strength\n    end\n  end\n  return strongest_extension\nend"], ["-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check('abcd', 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup', 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef', 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal function cycpattern_check(a, b)\n  if a == b then\n    return true\n  elseif type(a) == 'string' and type(b) == 'string' then\n    local a_len = #a\n    local b_len = #b\n    if a_len == b_len then\n      for I = 1, a_len do\n        if a:sub(i, i) ~= b:sub(i, i) then\n          return false\n        end\n      end\n      return true\n    else\n      return false\n    end\n  else\n    return false\n  end\nend\n```"], ["-- Given an integer. return a table that has the number of even and odd digits respectively.\n-- Example:\n--     >>> even_odd_count(-12)\n--     {1, 1}\n--     >>> even_odd_count(123)\n--     {1, 2}\nlocal function even_odd_count(num)\n    local even_count = {}\n    local odd_count = {}\n    for I = 1, math.floor(math.log(num, 2)) do\n        local even_digit = num % 2\n        even_count[even_digit] = even_count[even_digit] or 1\n        num = math.floor(num / 2)\n    end\n    for I = math.floor(math.log(num, 2)), 1, -1 do\n        local odd_digit = num % 2\n        odd_count[odd_digit] = odd_count[odd_digit] or 1\n        num = math.floor(num / 2)\n    end\n    return even_count, odd_count\nend\n```"], ["-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n  local result = \"\"\n  local digits = {}\n  for I = 1, math.floor(number / 100) do\n    table.insert(digits, \"M\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"CM\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"D\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"CD\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"C\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"XC\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"L\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"XL\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"X\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"IX\")\n  end\n  for I = number % 100, 1, -1 do\n    table.insert(digits, \"V\")\n  end\n "], ["-- Given the lengths of the three sides of a triangle. Return true if the three\n-- sides form a right-angled triangle, false otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or \n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle(3, 4, 5)\n-- true\n-- >>> right_angle_triangle(1, 2, 3)\n-- false\nlocal function right_angle_triangle(a, b, c)\n  if a == b and b == c then\n    return true\n  elseif a == b and c == a then\n    return true\n  elseif a == c and b == a then\n    return true\n  elseif a == c and b == b then\n    return true\n  elseif b == c and a == b then\n    return true\n  elseif a == c and b == c then\n    return true\n  end\n  return false\nend\n```"], ["-- Write a function that accepts a table of strings.\n-- The table contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max({'name', 'of', 'string'})\n-- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n  local max_char = 0\n  local max_word = {}\n  for word, count in pairs(words) do\n    if count > max_char then\n      max_char = count\n      max_word = word\n    end\n  end\n  return max_word\nend\n```"], ["-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return a table of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat(5, 6, 10)\n-- {11, 4}\n-- >>> eat(4, 8, 9)\n-- {12, 1}\n-- >>> eat(1, 10, 10)\n-- {11, 0}\n-- >>> eat(2, 11, 5)\n-- {7, 0}\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n  if number < 0 or need < 0 or remaining < 0 then\n    error(\"Invalid input\")\n  end\n  if number > need or need > remaining then\n    error(\"Not enough carrots\")\n  end\n  if number == need then\n    return {need, 0}\n  end\n  local result = {need, number}\n  while result.need > 0 do\n    local carrot = math.random(1, 10)\n    if result.need <= carrot then\n      result.need = result.need - carrot\n      result.remaining = result.remaining - carrot\n    else\n      result.need = result.need - carrot\n      result.remaining = result.remaining + carrot\n    end"], ["-- Given two tables operator, and operand. The first table has basic algebra operations, and \n-- the second table is a table of integers. Use the two given tables to build the algebric \n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + ) \n-- Subtraction ( - ) \n-- Multiplication ( * ) \n-- Floor division ( // ) \n-- Exponentiation ( ** ) \n-- Example:\n-- operator['+', '*', '-']\n-- table = [2, 3, 4, 5]\n-- result = 2 + 3 * 4 - 5\n-- => result = 9\n-- Note:\n--     The length of operator table is equal to the length of operand table minus one.\n--     Operand is a table of of non-negative integers.\n--     Operator table has at least one operator, and operand table has at least two operands.\nlocal function do_algebra(operator, operand)\n    local result = 0\n    for I, v in ipairs(operand) do\n        if type(v) == \"number\" then\n            result = result + v\n        elseif type(v) == \"table\" then\n            for j, w in ipairs(v) do\n                result = result + operator[j] * operand[j]\n            end\n        end\n    end\n    return result\nend"], ["-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa, \n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve('1234')\n-- '4321'\n-- >>> solve('ab')\n-- 'AB'\n-- >>> solve('#a@C')\n-- '#A@c'\nlocal function solve(s)\n  local result = ''\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    if c == 'a' or c == 'A' then\n      result = result .. string.upper(c)\n    else\n      result = result .. string.lower(c)\n    end\n  end\n  return result\nend\n```"], ["-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return nil.\n-- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\nlocal function string_to_md5(text)\n  if text == '' then\n    return nil\n  end\n  local hash = {}\n  for I = 1, #text do\n    local char = text:sub(i, i)\n    table.insert(hash, string.byte(char))\n  end\n  local md5 = table.concat(hash, '')\n  return md5:gsub('^%x{2}%x{2}$', '%%%1')\nend\n```"], ["-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers(2, 8)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10, 14)\n-- {}\nlocal function generate_integers(a, b)\n  local result = {}\n  for I = a, b, 1 do\n    local digit = tostring(i)\n    if digit:len() == 2 then\n      result[#result+1] = digit\n    end\n  end\n  return result\nend\n```"]]