[["(**Check if in given list of numbers, are any two numbers closer to each other than\n * given threshold.\n * >>> has_close_elements [1.0; 2.0; 3.0] 0.5\n * false\n * >>> has_close_elements [1.0; 2.8; 3.0; 4.0; 5.0; 2.0] 0.3\n * true\n*)\nlet has_close_elements (numbers : float list) (threshold : float) : bool =\n  let rec loop (numbers, threshold) = function\n    | [] -> true\n    | hd :: tl ->\n        let diff = hd - threshold in\n        if diff < 0.0 || diff > 1.0 then false\n        else if Array.length tl = 1 then loop numbers threshold tl\n        else if Array.length tl = 2 then\n          let (a, b) = Array.split tl in\n          let diff = a - b in\n          if diff < 0.0 || diff > 1.0 then false\n          else loop numbers threshold a\n        else loop (numbers, threshold) tl tl\n  in\n  loop numbers threshold numbers\n"], ["(**Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n * separate those group into separate strings and return the list of those.\n * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n * Ignore any spaces in the input string.\n * >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n * [\"()\"; \"(())\"; \"(()())\"]\n*)\nlet separate_paren_groups (paren_string : string) : string list =\n  let rec separate_groups (paren_string : string) : string list =\n    match paren_string with\n    | \"\" -> []\n    | '(' :: rest ->\n        let open_braces = String.split_on_char '(' rest\n        let open_braces_len = String.length open_braces\n        let open_braces_with_spaces = open_braces |> String.trim |> String.split_on_char ' '\n        let open_braces_with_spaces_len = String.length open_braces_with_spaces\n        let open_braces_with_spaces_with_spaces = open_braces_with_spaces |> String.trim |> String.split_on_char ' '\n        let open_braces_with_spaces_with_spaces_len = String.length open_braces_with_spaces_with_spaces\n        let open_braces_with_spaces_with_spaces_with_spaces = open_braces_with_spaces_with_spaces |> String.trim |> String.split_on_char ' '\n        let open_braces_with_spaces_with_spaces_with_spaces_len = String.length open_braces_with_spaces_with_spaces_with_spaces\n        let open_braces_with_spaces_with_spaces_with_spaces_with_spaces_len = String.length open_braces_with_spaces_with_spaces_with_spaces_with_spaces\n        let open_braces_with_spaces_with_spaces_with_spaces_with_spaces_with_spaces_len = String.length open_braces_with_spaces_with_"], ["(**Given a positive floating point number, it can be decomposed into\n * and integer part (largest integer smaller than given number) and decimals\n * (leftover part always smaller than 1).\n * Return the decimal part of the number.\n * >>> truncate_number 3.5\n * 0.5\n*)\nlet truncate_number (number : float) : float =\n  let rec decimal_part_rec (n : float) : float =\n    match n with\n    | 0.0 -> 0.0\n    | n when n > 0.0 -> n\n    | n when n < 0.0 -> n + 1.0\n    | n -> n\n  in\n  let rec decimals_part_rec (n : float) : float =\n    match n with\n    | 0.0 -> 0.0\n    | n when n > 0.0 -> n\n    | n when n < 0.0 -> n - 1.0\n    | n -> n\n  in\n  let rec decimal_part_decimals_part_rec (n : float) : float =\n    match n with\n    | 0.0 -> 0.0\n    | n when n > 0.0 -> n\n    | n when n < 0.0 -> n - 1.0\n    | n -> n\n  in\n  let rec decimal_part_decimals_part_decimals_part_rec (n : float) : float =\n    match n with\n    | 0.0 -> 0.0\n    | n when n > 0.0 -> n\n    | n when n < 0.0 -> n - 1.0\n    | n -> n\n  in\n  let rec decimal_part_decimals_part_decimals_part_decimals_part_rec (n : float) : float =\n    match n with\n    | 0.0 -> 0.0\n    | n when n > 0.0 -> n\n    | n when n < 0.0 -> n - 1.0\n    | n -> n\n  in\n  let rec decimal_part_decimals_part_"], ["(**You're given a list of deposit and withdrawal operations on a bank account that starts with\n * zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n * at that point function should return true. Otherwise it should return false.\n * >>> below_zero [1; 2; 3]\n * false\n * >>> below_zero [1; 2; (~4); 5]\n * true\n*)\nlet below_zero (operations : int list) : bool =\n  let rec check acc = function\n    | [] -> true\n    | (x, y) :: xs ->\n        if x < 0 && y < 0\n        then check (acc + x) xs\n        else check acc xs\n  in\n  check 0 operations"], ["(**For a given list of input numbers, calculate Mean Absolute Deviation\n * around the mean of this dataset.\n * Mean Absolute Deviation is the average absolute difference between each\n * element and a centerpoint (mean in this case):\n * MAD = average | x - x_mean |\n * >>> mean_absolute_deviation [1.0; 2.0; 3.0; 4.0]\n * 1.0\n*)\nlet mean_absolute_deviation (numbers : float list) : float =\n  let mean = List.fold_left (fun acc x -> acc +. x) 0 numbers\n  let mean_squared_deviation =\n    List.fold_left (fun acc x -> acc +. (x -. mean) *. (x -. mean)) 0 numbers\n  let mean_absolute_deviation =\n    List.fold_left (fun acc x -> acc +. abs x) 0 numbers\n  mean_squared_deviation /. (List.length numbers)"], ["(**Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n * >>> intersperse [] 4\n * []\n * >>> intersperse [1; 2; 3] 4\n * [1; 4; 2; 4; 3]\n*)\nlet intersperse (numbers : int list) (delimeter : int) : int list =\n  let rec intersperse_helper (acc : int list) (num : int) : int list =\n    match num with\n    | 0 -> acc\n    | _ -> intersperse_helper (num :: acc) (num / 2)\n  in\n  intersperse_helper [] delimeter"], ["(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n * For each of the group, output the deepest level of nesting of parentheses.\n * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n * >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n * [2; 3; 1; 3]\n*)\nlet parse_nested_parens (paren_string : string) : int list =\n  let rec parse_nested_parens_helper (paren_string : string) : int list =\n    match paren_string with\n    | \"(\" :: rest ->\n        let (nested_parens, rest) = parse_nested_parens rest in\n        nested_parens :: parse_nested_parens_helper rest\n    | _ :: rest ->\n        let (nested_parens, rest) = parse_nested_parens rest in\n        nested_parens :: parse_nested_parens_helper rest\n    | _ ->\n        []\n  in\n  parse_nested_parens_helper paren_string"], ["(**Filter an input list of strings only for ones that contain given substring\n * >>> filter_by_substring [] \"a\"\n * []\n * >>> filter_by_substring [\"abc\"; \"bacd\"; \"cde\"; \"array\"] \"a\"\n * [\"abc\"; \"bacd\"; \"array\"]\n*)\nlet filter_by_substring (strings : string list) (substring : string) : string list =\n  let rec filter_by_substring_aux (strings : string list) (substring : string) : string list =\n    match strings with\n    | [] -> []\n    | hd :: tl ->\n        let rec filter_by_substring_aux_aux (strings : string list) (substring : string) : string list =\n          match strings with\n          | [] -> []\n          | hd :: tl ->\n              if hd = substring then tl else filter_by_substring_aux_aux tl substring\n        in\n        filter_by_substring_aux_aux strings substring\n  in\n  filter_by_substring_aux strings substring"], ["(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n * >>> sum_product []\n * (0, 1)\n * >>> sum_product [1; 2; 3; 4]\n * (10, 24)\n*)\nlet sum_product (numbers : int list) :  int * int =\n  let rec sum_product_helper (numbers : int list) : int * int =\n    match numbers with\n    | [] -> (0, 1)\n    | _ :: tail ->\n        let sum = sum_product_helper tail\n        let product = product_helper sum\n        sum, product\n  in\n  sum_product_helper numbers"], ["(**From a given list of integers, generate a list of rolling maximum element found until given moment\n * in the sequence.\n * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]\n * [1; 2; 3; 3; 3; 4; 4]\n*)\nlet rolling_max (numbers : int list) : int list =\n  let rec max_so_far max_so_far_list =\n    match numbers with\n    | [] -> max_so_far []\n    | head :: tail ->\n        if head > max_so_far_list then max_so_far_list\n        else max_so_far (head :: max_so_far_list)\n  in\n  max_so_far []"], ["(**Find the shortest palindrome that begins with a supplied string.\n * Algorithm idea is simple:\n * - Find the longest postfix of supplied string that is a palindrome.\n * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n * >>> make_palindrome \"\"\n * \"\"\n * >>> make_palindrome \"cat\"\n * \"catac\"\n * >>> make_palindrome \"cata\"\n * \"catac\"\n*)\nlet make_palindrome (string : string) : string =\n  let rec find_palindrome prefix suffix =\n    match prefix, suffix with\n    | \"\", \"\" -> \"\"\n    | prefix, \"\" -> prefix\n    | prefix, suffix ->\n      let postfix = prefix ^ suffix in\n      if postfix = prefix ^ suffix then postfix else postfix ^ \" \"\n  in\n  let rec reverse_prefix prefix =\n    match prefix with\n    | \"\" -> \"\"\n    | prefix :: prefixes ->\n      let suffix = prefix ^ prefixes.[0] in\n      if prefixes = [] then prefix else prefix ^ \" \" ^ reverse_prefix suffix\n  in\n  let rec reverse_suffix suffix =\n    match suffix with\n    | \"\" -> \"\"\n    | suffix :: suffixes ->\n      let prefix = suffix ^ suffixes.[0] in\n      if suffixes = [] then prefix else prefix ^ \" \" ^ reverse_suffix prefix\n  in\n  let prefix = string.Substring 0 1 in\n  let suffix = string.Substring string.Length 1 in\n  let prefix_postfix = find_palindrome prefix suffix in\n  let prefix_postfix_reverse = reverse_prefix prefix_postfix in\n  let suffix_postfix = reverse_suffix suffix in\n  prefix_postfix_reverse ^ suffix_postfix"], ["(**Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return result also as a string.\n * >>> string_xor \"010\" \"110\"\n * \"100\"\n*)\nlet string_xor (a : string) (b : string) : string =\n  let rec string_xor_helper (a : string) (b : string) : string =\n    match a, b with\n    | \"\", \"\" -> \"\"\n    | a, \"\" -> b\n    | \"\", b -> a\n    | a, b -> a ^ b\n  in\n  string_xor_helper a b\n;;"], ["(**Out of list of strings, return the longest one. Return the first one in case of multiple\n * strings of the same length. Return None in case the input list is empty.\n * >>> longest []\n * Some(None)\n * >>> longest [\"a\"; \"b\"; \"c\"]\n * Some(\"a\")\n * >>> longest [\"a\"; \"bb\"; \"ccc\"]\n * Some(\"ccc\")\n*)\nlet longest (strings : string list) : string option =\n  let rec longest_helper (strings : string list) (max_length : int) : string option =\n    match strings with\n    | [] -> None\n    | _ :: _ ->\n        let longest_length = max_length\n        in\n        if longest_length > max_length then longest_helper (strings @ []) longest_length\n        else Some longest_length\n  in\n  longest_helper strings 0"], ["(**Return a greatest common divisor of two integers a and b\n * >>> greatest_common_divisor 3 5\n * 1\n * >>> greatest_common_divisor 25 15\n * 5\n*)\nlet greatest_common_divisor (a : int) (b : int) : int =\n  let rec gcd_helper a b =\n    match b with\n    | 0 -> a\n    | _ -> gcd_helper a (b mod a)\n  in\n  gcd_helper a b\n;;"], ["(**Return list of all prefixes from shortest to longest of the input string\n * >>> all_prefixes \"abc\"\n * [\"a\"; \"ab\"; \"abc\"]\n*)\nlet all_prefixes (string : string) : string list =\n  let rec aux acc (string : string) : string list =\n    match string with\n    | \"\" -> acc\n    | c :: rest ->\n        if String.is_prefix c string then aux (c :: acc) rest\n        else aux acc rest\n  in aux [] string"], ["(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * >>> string_sequence 0\n * \"0\"\n * >>> string_sequence 5\n * \"0 1 2 3 4 5\"\n*)\nlet string_sequence (n : int) : string =\n  let rec string_sequence_helper n acc =\n    if n = 0 then acc\n    else string_sequence_helper (n - 1) (n::acc)\n  in\n  string_sequence_helper n []"], ["(**Given a string, find out how many distinct characters (regardless of case) does it consist of\n * >>> count_distinct_characters \"xyzXYZ\"\n * 3\n * >>> count_distinct_characters \"Jerry\"\n * 4\n*)\nlet count_distinct_characters (string : string) : int =\n  let rec count_distinct_characters_helper (string : string) (count : int) : int =\n    match string with\n    | \"\" -> count\n    | _ ->\n        let count_of_char = function\n            | 'a' -> 1\n            | 'A' -> 1\n            | 'e' -> 1\n            | 'E' -> 1\n            | 'i' -> 1\n            | 'I' -> 1\n            | 'o' -> 1\n            | 'O' -> 1\n            | 'u' -> 1\n            | 'U' -> 1\n            | _ -> 0\n        in\n        count_of_char string\n        + count_distinct_characters_helper string (count + 1)\n  in\n  count_distinct_characters_helper string 0"], ["(**Input to this function is a string representing musical notes in a special ASCII format.\n * Your task is to parse this string and return list of integers corresponding to how many beats does each\n * not last.\n * Here is a legend:\n * 'o' - whole note, lasts four beats\n * 'o|' - half note, lasts two beats\n * '.|' - quater note, lasts one beat\n * >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]\n*)\nlet parse_music (music_string : string) : int list =\n  let rec parse_note (note : char) : int =\n    match note with\n    | 'o' -> 1\n    | 'o' | '|' -> 2\n    | '.|' -> 1\n    | _ -> failwith (\"Invalid note: \" ^ note)\n  in\n  let rec parse_beat (beat : int) : int =\n    match beat with\n    | 4 -> 4\n    | 2 -> 2\n    | 1 -> 1\n    | 2 -> 2\n    | 2 -> 1\n    | _ -> failwith (\"Invalid beat: \" ^ beat)\n  in\n  let rec parse_notes (notes : string) : int list =\n    match notes with\n    | \"\" -> []\n    | note :: rest ->\n      let beat = parse_beat (parse_note note) in\n      let next_note = parse_note (List.nth rest 0) in\n      if next_note = note then parse_notes rest else [beat; next_note]\n  in\n  parse_notes music_string"], ["(**Find how many times a given substring can be found in the original string. Count overlaping cases.\n * >>> how_many_times \"\" \"a\"\n * 0\n * >>> how_many_times \"aaa\" \"a\"\n * 3\n * >>> how_many_times \"aaaa\" \"aa\"\n * 3\n*)\nlet how_many_times (string : string) (substring : string) : int =\n  let rec count_overlaping_cases (string : string) (substring : string) : int =\n    match string, substring with\n    | \"\", \"\" -> 0\n    | \"\", _ -> 1\n    | _, \"\" -> 1\n    | s, _ when s = substring -> 1\n    | s, _ when s = substring || s = substring ^ substring -> 2\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 3\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 4\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 5\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 6\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 7\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 8\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 9\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 10\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 11\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 12\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 13\n    | s, _ when s = substring || s = substring ^ substring || s = substring ^ substring ^ substring -> 1"], ["(**Input is a space-delimited string of numberals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n * Return the string with numbers sorted from smallest to largest\n * >>> sort_numbers \"three one five\"\n * \"one three five\"\n*)\nlet sort_numbers (numbers : string) : string =\n  let rec sort_numbers_aux (numbers : string) : string =\n    match numbers with\n    | \"\" -> \"\"\n    | \" \" :: rest ->\n        sort_numbers_aux rest\n    | n :: rest ->\n        if n < \"zero\" || n > \"nine\" then\n            sort_numbers_aux rest\n        else\n            n :: sort_numbers_aux rest\n  in\n  sort_numbers_aux numbers\n;;"], ["(**From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n * other and return them in order (smaller number, larger number).\n * >>> find_closest_elements [1.0; 2.0; 3.0; 4.0; 5.0; 2.2]\n * (2.0, 2.2)\n * >>> find_closest_elements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0]\n * (2.0, 2.0)\n*)\nlet find_closest_elements (numbers : float list) :  float * float =\n  let rec find_closest_element_helper (numbers : float list) (closest_element : float) (closest_index : int) : float * float =\n    match numbers with\n    | [] -> (closest_element, closest_index)\n    | _ :: rest ->\n        let current_element = numbers.(closest_index) in\n        let current_index = closest_index + 1 in\n        if current_element < closest_element then\n          find_closest_element_helper rest (current_element) current_index\n        else\n          find_closest_element_helper rest current_element (closest_index + 1)\n    in\n    find_closest_element_helper [] closest_element 0\n  in\n  find_closest_element_helper numbers 0 0\n;;"], ["(**Given list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1\n * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]\n * [0.0; 0.25; 0.5; 0.75; 1.0]\n*)\nlet rescale_to_unit (numbers : float list) : float list =\n  let rec rescale_to_unit_helper (numbers : float list) (min_value : float) (max_value : float) : float list =\n    match numbers with\n    | [] -> []\n    | hd :: tl ->\n        let (min_value, max_value) = hd in\n        let (min_value_new, max_value_new) = rescale_to_unit_helper tl min_value max_value in\n        let min_value_new = if min_value_new < min_value then min_value_new else min_value in\n        let max_value_new = if max_value_new > max_value then max_value_new else max_value in\n        let min_value_new, max_value_new = if min_value_new < max_value_new then (min_value_new, max_value_new) else (max_value_new, min_value_new) in\n        min_value_new :: max_value_new :: min_value_new :: max_value_new :: tl\n  in\n  rescale_to_unit_helper numbers min_value max_value"], ["(**Return length of given string\n * >>> strlen \"\"\n * 0\n * >>> strlen \"abc\"\n * 3\n*)\nlet strlen (string : string) : int =\n  let rec helper acc str =\n    match str with\n    | \"\" -> acc\n    | c :: rest ->\n        helper (acc + 1) rest\n  in\n  helper 0 string"], ["(**For a given number n, find the largest number that divides n evenly, smaller than n\n * >>> largest_divisor 15\n * 5\n*)\nlet largest_divisor (n : int) : int =\n  let rec find_divisor n acc =\n    match n with\n    | 0 -> acc\n    | _ -> if n mod n = 0 then n / n else find_divisor (n / n) (n / n)\n  in\n  find_divisor n 1\n;;"], ["(**Return list of prime factors of given integer in the order from smallest to largest.\n * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n * Input number should be equal to the product of all factors\n * >>> factorize 8\n * [2; 2; 2]\n * >>> factorize 25\n * [5; 5]\n * >>> factorize 70\n * [2; 5; 7]\n*)\nlet factorize (n : int) : int list =\n  let rec factorize_helper n acc =\n    if n = 1 then acc\n    else if n mod 2 = 0 then factorize_helper n (n :: acc)\n    else factorize_helper (n / 2) (n :: acc)\n  in\n  factorize_helper n []"], ["(**From a list of integers, remove all elements that occur more than once.\n * Keep order of elements left the same as in the input.\n * >>> remove_duplicates [1; 2; 3; 2; 4]\n * [1; 3; 4]\n*)\nlet remove_duplicates (numbers : int list) : int list =\n  let rec remove_duplicates_helper (numbers : int list) (count : int) : int list =\n    match numbers with\n    | [] -> []\n    | head :: tail ->\n        if count > 1 then\n            head :: remove_duplicates_helper tail (count - 1)\n        else\n            head :: []\n  in\n  remove_duplicates_helper numbers 0\n;;"], ["(**For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * >>> flip_case \"Hello\"\n * \"hELLO\"\n*)\nlet flip_case (string : string) : string =\n  let rec flip_case_aux (string : string) : string =\n    match string with\n    | \"\" -> \"\"\n    | _ ->\n        let first_char = string.[0] in\n        let rest_of_string = string.[1..] in\n        let reversed_string = String.reverse rest_of_string in\n        let reversed_first_char = reversed_string.[0] in\n        let reversed_rest_of_string = reversed_string.[1..] in\n        let reversed_string = String.concat \"\" reversed_rest_of_string in\n        let reversed_first_char = reversed_string.[0] in\n        let reversed_rest_of_string = reversed_string.[1..] in\n        let reversed_rest_of_string = String.reverse reversed_rest_of_string in\n        let reversed_string = String.concat \"\" reversed_rest_of_string in\n        let reversed_first_char = reversed_string.[0] in\n        let reversed_rest_of_string = reversed_string.[1..] in\n        let reversed_rest_of_string = String.reverse reversed_rest_of_string in\n        let reversed_string = String.concat \"\" reversed_rest_of_string in\n        let reversed_first_char = reversed_string.[0] in\n        let reversed_rest_of_string = reversed_string.[1..] in\n        let reversed_rest_of_string = String.reverse reversed_rest_of_string in\n        let reversed_string = String.concat \"\" reversed_rest_of_string in\n        let reversed_first_char = reversed_string.[0] in\n        let reversed_rest_of_string = reversed_string.[1..] in\n        let reversed_rest_of_string = String.reverse reversed_rest_of_string in\n        let"], ["(**Concatenate list of strings into a single string\n * >>> concatenate []\n * \"\"\n * >>> concatenate [\"a\"; \"b\"; \"c\"]\n * \"abc\"\n*)\nlet concatenate (strings : string list) : string =\n  let rec concatenate_rec acc = function\n    | [] -> acc\n    | h :: t -> concatenate_rec (h :: acc) t\n  in\n  concatenate_rec [] strings"], ["(**Filter an input list of strings only for ones that start with a given prefix.\n * >>> filter_by_prefix [] \"a\"\n * []\n * >>> filter_by_prefix [\"abc\"; \"bcd\"; \"cde\"; \"array\"] \"a\"\n * [\"abc\"; \"array\"]\n*)\nlet filter_by_prefix (strings : string list) (prefix : string) : string list =\n  let rec filter_prefix_helper (prefix : string) (acc : string list) (strings : string list) : string list =\n    match strings with\n    | [] -> acc\n    | hd :: tl -> if hd = prefix then filter_prefix_helper prefix acc tl else hd :: acc\n  in\n  filter_prefix_helper prefix [] strings"], ["(**Return only positive numbers in the list.\n * >>> get_positive [(~1); 2; (~4); 5; 6]\n * [2; 5; 6]\n * >>> get_positive [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]\n * [5; 3; 2; 3; 9; 123; 1]\n*)\nlet get_positive (l : int list) : int list =\n  let rec aux l =\n    match l with\n    | [] -> []\n    | hd :: tl ->\n        if hd > 0 then aux tl else hd :: aux tl\n  in aux l"], ["(**Return true if a given number is prime, and false otherwise.\n * >>> is_prime 6\n * false\n * >>> is_prime 101\n * true\n * >>> is_prime 11\n * true\n * >>> is_prime 13441\n * true\n * >>> is_prime 61\n * true\n * >>> is_prime 4\n * false\n * >>> is_prime 1\n * false\n*)\nlet is_prime (n : int) : bool =\n  let rec is_prime_rec n =\n    match n with\n    | 2 | 3 -> true\n    | _ -> if n % 2 = 0 then false else is_prime_rec (n / 2)\n  in\n  is_prime_rec n"], ["(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n * to the values of the corresponding indicies of l, but sorted.\n * >>> sort_third [1; 2; 3]\n * [1; 2; 3]\n * >>> sort_third [5; 6; 3; 4; 8; 9; 2]\n * [2; 6; 3; 4; 8; 9; 5]\n*)\nlet sort_third (l : int list) : int list =\n  let rec sort_third_aux l acc =\n    match l with\n    | [] -> acc\n    | hd :: tl ->\n        let (l', r) = List.partition (fun x -> x mod 3 = 0) tl in\n        sort_third_aux l' (hd :: acc)\n  in\n  sort_third_aux l []"], ["(**Return sorted unique elements in a list\n * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]\n * [0; 2; 3; 5; 9; 123]\n*)\nlet unique (l : int list) : int list =\n  let rec aux l =\n    match l with\n    | [] -> []\n    | hd :: tl ->\n        if hd = head l then aux tl\n        else if hd = tail l then aux tl\n        else hd :: aux tl\n  in aux l"], ["(**Return maximum element in the list.\n * >>> max_element [1; 2; 3]\n * 3\n * >>> max_element [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]\n * 123\n*)\nlet max_element (l : int list) : int =\n  let rec max_helper l acc =\n    match l with\n    | [] -> acc\n    | h :: t ->\n        if h > acc\n        then max_helper t (h :: acc)\n        else acc\n  in\n  max_helper l []"], ["(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n * >>> fizz_buzz 50\n * 0\n * >>> fizz_buzz 78\n * 2\n * >>> fizz_buzz 79\n * 3\n*)\nlet fizz_buzz (n : int) : int =\n  let rec fizz_buzz_loop n =\n    match n with\n    | 1 -> 1\n    | 2 -> 2\n    | 3 -> 3\n    | 4 -> 4\n    | _ ->\n        if n mod 11 = 7 || n mod 13 = 1 then 1\n        else 0\n  in\n  fizz_buzz_loop n\n;;"], ["(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n * to the values of the even indicies of l, but sorted.\n * >>> sort_even [1; 2; 3]\n * [1; 2; 3]\n * >>> sort_even [5; 6; 3; 4]\n * [3; 6; 5; 4]\n*)\nlet sort_even (l : int list) : int list =\n  let rec sort_even_aux l =\n    match l with\n    | [] -> []\n    | hd :: tl ->\n        let even_indices = List.filter (fun x -> x mod 2 = 0) tl in\n        let even_values = List.map (fun x -> x mod 2) tl in\n        let even_indices_sorted = List.sort (fun x y -> compare even_indices x even_indices y) even_indices in\n        let even_values_sorted = List.sort (fun x y -> compare even_values x even_values y) even_values in\n        let even_indices_sorted = List.map (fun x -> x) even_indices_sorted in\n        let even_values_sorted = List.map (fun x -> x) even_values_sorted in\n        even_indices_sorted @ even_values_sorted\n  in\n  sort_even_aux l"], ["(**prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n * >>> prime_fib 1\n * 2\n * >>> prime_fib 2\n * 3\n * >>> prime_fib 3\n * 5\n * >>> prime_fib 4\n * 13\n * >>> prime_fib 5\n * 89\n*)\nlet prime_fib (n : int) : int =\n  let rec fib n =\n    if n < 2 then n\n    else if n mod 2 = 0 then n\n    else fib (n div 2) + fib (n div 2)\n  in fib n"], ["(**triples_sum_to_zero takes a list of integers as an input.\n * it returns true if there are three distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> triples_sum_to_zero [1; 3; 5; 0]\n * false\n * >>> triples_sum_to_zero [1; 3; (~2); 1]\n * true\n * >>> triples_sum_to_zero [1; 2; 3; 7]\n * false\n * >>> triples_sum_to_zero [2; 4; (~5); 3; 9; 7]\n * true\n * >>> triples_sum_to_zero [1]\n * false\n*)\nlet triples_sum_to_zero (l : int list) : bool =\n  let rec sum_to_zero_helper (acc : int list) (sum : int) : bool =\n    match l with\n    | [] -> true\n    | hd :: tl ->\n        if sum = 0 then\n          true\n        else if hd = sum then\n          sum_to_zero_helper acc (sum + hd)\n        else\n          false\n    | _ -> false\n  in\n  sum_to_zero_helper [] 0"], ["(**Imagine a road that's a perfectly straight infinitely long line.\n * n cars are driving left to right;  simultaneously, a different set of n cars\n * are driving right to left.   The two sets of cars start out being very far from\n * each other.  All cars move in the same speed.  Two cars are said to collide\n * when a car that's moving left to right hits a car that's moving right to left.\n * However, the cars are infinitely sturdy and strong; as a result, they continue moving\n * in their trajectory as if they did not collide.\n * This function outputs the number of such collisions.\n*)\nlet car_race_collision (n : int) : int =\n  let cars = Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) (Array.of_list (List.map (fun x -> x + 1) ("], ["(**Return list with elements incremented by 1.\n * >>> incr_list [1; 2; 3]\n * [2; 3; 4]\n * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]\n * [6; 4; 6; 3; 4; 4; 10; 1; 124]\n*)\nlet incr_list (l : int list) : int list =\n  let rec incr_list_aux acc n =\n    if n < 0 then acc else\n    if n = 0 then acc\n    else if n mod 2 = 1 then incr_list_aux (n :: acc) (n / 2)\n    else acc\n  in\n  incr_list_aux [] 0"], ["(**pairs_sum_to_zero takes a list of integers as an input.\n * it returns true if there are two distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> pairs_sum_to_zero [1; 3; 5; 0]\n * false\n * >>> pairs_sum_to_zero [1; 3; (~2); 1]\n * false\n * >>> pairs_sum_to_zero [1; 2; 3; 7]\n * false\n * >>> pairs_sum_to_zero [2; 4; (~5); 3; 5; 7]\n * true\n * >>> pairs_sum_to_zero [1]\n * false\n*)\nlet pairs_sum_to_zero (l : int list) : bool =\n  let rec pairs_sum_to_zero_aux (l : int list) : bool =\n    match l with\n    | [] -> true\n    | hd :: tl ->\n        let sum = List.fold_left (fun acc x -> acc + x) 0 tl in\n        if sum = 0 then true else pairs_sum_to_zero_aux tl\n  in\n  pairs_sum_to_zero_aux l"], ["(**Change numerical base of input number x to base.\n * return string representation after the conversion.\n * base numbers are less than 10.\n * >>> change_base 8 3\n * \"22\"\n * >>> change_base 8 2\n * \"1000\"\n * >>> change_base 7 2\n * \"111\"\n*)\nlet change_base (x : int) (base : int) : string =\n  let rec change_base_helper x base =\n    match x with\n    | 0 -> \"0\"\n    | _ ->\n        let y = x / base in\n        let z = x mod base in\n        if y = 0 then z else change_base_helper y base\n  in\n  change_base_helper x base\n;;"], ["(**Given length of a side and high return area for a triangle.\n * >>> triangle_area 5 3\n * 7.5\n*)\nlet triangle_area (a : int) (h : int) : float =\n  let rec triangle_area_rec (a : int) (h : int) : float =\n    match (a, h) with\n    | (0, _) -> 0.0\n    | (_, 0) -> 0.0\n    | (a, h) -> a * h / 2.0\n  in\n  triangle_area_rec a h"], ["(**The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n * >>> fib4 5\n * 4\n * >>> fib4 6\n * 8\n * >>> fib4 7\n * 14\n*)\nlet fib4 (n : int) : int =\n  if n < 1 then 0\n  else if n = 1 then 0\n  else if n = 2 then 2\n  else fib4 (n - 1) + fib4 (n - 2) + fib4 (n - 3) + fib4 (n - 4)"], ["(**Return median of elements in the list l.\n * >>> median [3; 1; 2; 4; 5]\n * 3.0\n * >>> median [(~10); 4; 6; 1000; 10; 20]\n * 15.0\n*)\nlet median (l : int list) : float =\n  let rec helper l acc =\n    match l with\n    | [] -> acc\n    | hd :: tl ->\n        if acc = 0.0 then hd\n        else if acc > 0.0 then acc\n        else if acc < 0.0 then acc\n        else helper tl (acc + hd)\n  in\n  helper l 0.0\n;;"], ["(**Checks if given string is a palindrome\n * >>> is_palindrome \"\"\n * true\n * >>> is_palindrome \"aba\"\n * true\n * >>> is_palindrome \"aaaaa\"\n * true\n * >>> is_palindrome \"zbcd\"\n * false\n*)\nlet is_palindrome (text : string) : bool =\n  let rec is_palindrome_helper (text : string) : bool =\n    match text with\n    | \"\" -> true\n    | _ ->\n        let reversed_text = String.reverse text\n        if text = reversed_text then true else is_palindrome_helper reversed_text\n  in\n  is_palindrome_helper text"], ["(**Return 2^n modulo p (be aware of numerics).\n * >>> modp 3 5\n * 3\n * >>> modp 1101 101\n * 2\n * >>> modp 0 101\n * 1\n * >>> modp 3 11\n * 8\n * >>> modp 100 101\n * 1\n*)\nlet modp (n : int) (p : int) : int =\n  let rec modp_rec n p acc =\n    if n = 0 then\n      acc\n    else\n      if n mod p = 0 then n / p\n      else\n        modp_rec (n / p) p (n mod p)\n  in\n  modp_rec n p 1"], ["(**remove_vowels is a function that takes string and returns string without vowels.\n * >>> remove_vowels \"\"\n * \"\"\n * >>> remove_vowels \"abcdef\"\n * \"bcdf\"\n * >>> remove_vowels \"aaaaa\"\n * \"\"\n * >>> remove_vowels \"aaBAA\"\n * \"B\"\n * >>> remove_vowels \"zbcd\"\n * \"zbcd\"\n*)\nlet remove_vowels (text : string) : string =\n  let remove_vowels_helper (text, vowels : string list) : string list =\n    match text with\n    | \"\" -> []\n    | _ when List.exists (fun c -> List.mem c vowels) text ->\n        text :: remove_vowels_helper (text, vowels)\n    | _ -> text :: remove_vowels_helper (text, vowels)\n  in\n  remove_vowels_helper (text, [])"], ["(**Return true if all numbers in the list l are below threshold t.\n * >>> below_threshold [1; 2; 4; 10] 100\n * true\n * >>> below_threshold [1; 20; 4; 10] 5\n * false\n*)\nlet below_threshold (l : int list) (t : int) : bool =\n  List.exists (fun n -> n <= t) l"], ["(**Add two numbers x and y\n * >>> add 2 3\n * 5\n * >>> add 5 7\n * 12\n*)\nlet add (x : int) (y : int) : int =\n  x + y"], ["(**Check if two words have the same characters.\n * >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n * true\n * >>> same_chars \"abcd\" \"dddddddabc\"\n * true\n * >>> same_chars \"dddddddabc\" \"abcd\"\n * true\n * >>> same_chars \"eabcd\" \"dddddddabc\"\n * false\n * >>> same_chars \"abcd\" \"dddddddabce\"\n * false\n * >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n * false\n*)\nlet same_chars (s0 : string) (s1 : string) : bool =\n  let rec aux (s0 : string) (s1 : string) : bool =\n    match s0, s1 with\n    | \"\", \"\" -> true\n    | _ ->\n        let c0 = Char.code s0.[0]\n        let c1 = Char.code s1.[0]\n        if c0 <> c1 then false\n        else if s0.Length <> s1.Length then false\n        else aux s0 (s1 [1..])\n  in aux s0 s1"], ["(**Return n-th Fibonacci number.\n * >>> fib 10\n * 55\n * >>> fib 1\n * 1\n * >>> fib 8\n * 21\n*)\nlet fib (n : int) : int =\n  if n < 2 then n\n  else fib (n - 1) + fib (n - 2)"], ["(**brackets is a string of \"<\" and \">\".\n * return true if every opening bracket has a corresponding closing bracket.\n * >>> correct_bracketing \"<\"\n * false\n * >>> correct_bracketing \"<>\"\n * true\n * >>> correct_bracketing \"<<><>>\"\n * true\n * >>> correct_bracketing \"><<>\"\n * false\n*)\nlet correct_bracketing (brackets : string) : bool =\n  let rec loop (opening : string) (closing : string) : bool =\n    match brackets with\n    | \"\" -> true\n    | _ ->\n        if opening = closing then loop opening closing else false\n  in\n  loop \"\" \"\"\n;;"], ["(**Return true is list elements are monotonically increasing or decreasing.\n * >>> monotonic [1; 2; 4; 20]\n * true\n * >>> monotonic [1; 20; 4; 10]\n * false\n * >>> monotonic [4; 1; 0; (~10)]\n * true\n*)\nlet monotonic (l : int list) : bool =\n  let rec loop (l : int list) : bool =\n    match l with\n    | [] -> true\n    | hd :: tl ->\n        if hd > hd || hd < hd then loop tl else loop tl\n  in\n  loop l"], ["(**Return sorted unique common elements for two lists.\n * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]\n * [1; 5; 653]\n * >>> common [5; 3; 2; 8] [3; 2]\n * [2; 3]\n*)\nlet common (l1 : int list) (l2 : int list) : int list =\n  let rec common_helper l1 l2 =\n    match l1, l2 with\n    | [], _ -> []\n    | _, [] -> []\n    | h1::t1, h2::t2 ->\n      if h1 = h2 then common_helper t1 t2\n      else if h1 < h2 then h1::common_helper t1 (h2::l2)\n      else h2::common_helper (h1::l1) t2\n  in\n  common_helper l1 l2"], ["(**Return the largest prime factor of n. Assume n > 1 and is not a prime.\n * >>> largest_prime_factor 13195\n * 29\n * >>> largest_prime_factor 2048\n * 2\n*)\nlet largest_prime_factor (n : int) : int =\n  let rec prime_factor_rec n =\n    match n with\n    | 1 -> 1\n    | 2 -> 2\n    | _ ->\n      let rem = n mod 2 in\n      if rem = 0 then n\n      else if rem < 2 then n\n      else prime_factor_rec (n / 2)\n  in\n  prime_factor_rec n\n;;"], ["(**sum_to_n is a function that sums numbers from 1 to n.\n * >>> sum_to_n 30\n * 465\n * >>> sum_to_n 100\n * 5050\n * >>> sum_to_n 5\n * 15\n * >>> sum_to_n 10\n * 55\n * >>> sum_to_n 1\n * 1\n*)\nlet sum_to_n (n : int) : int =\n  let rec sum_to_n_helper n acc =\n    if n <= 0 then acc\n    else sum_to_n_helper (n - 1) (n * acc)\n  in\n  sum_to_n_helper n 1"], ["(**brackets is a string of \"(\" and \")\".\n * return true if every opening bracket has a corresponding closing bracket.\n * >>> correct_bracketing \"(\"\n * false\n * >>> correct_bracketing \"()\"\n * true\n * >>> correct_bracketing \"(()())\"\n * true\n * >>> correct_bracketing \")(()\"\n * false\n*)\nlet correct_bracketing (brackets : string) : bool =\n  let rec loop (opening_brackets : string list) (closing_brackets : string list) : bool =\n    match brackets with\n    | \"\" -> true\n    | _ ->\n        let open_bracket = List.find (fun (opening, _) -> opening = opening_brackets.(0)) opening_brackets\n        let close_bracket = List.find (fun (_, closing) -> closing = closing_brackets.(0)) closing_brackets\n        if open_bracket = close_bracket then loop opening_brackets (close_bracket :: closing_brackets)\n        else false\n  in\n  loop [] []"], ["(**xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * Return derivative of this polynomial in the same form.\n * >>> derivative [3; 1; 2; 4; 5]\n * [1; 4; 12; 20]\n * >>> derivative [1; 2; 3]\n * [2; 6]\n*)\nlet derivative (xs : int list) : int list =\n  let rec helper xs acc =\n    match xs with\n    | [] -> acc\n    | x :: xs' ->\n        let diff = x - acc in\n        helper xs' (x + diff :: acc)\n  in\n  helper xs []"], ["(**The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n * >>> fibfib 1\n * 0\n * >>> fibfib 5\n * 4\n * >>> fibfib 8\n * 24\n*)\nlet fibfib (n : int) : int =\n  let rec fibfib_helper n acc =\n    match n with\n    | 0 -> acc\n    | 1 -> acc\n    | _ -> fibfib_helper (n - 1) (acc + fibfib_helper (n - 2) (acc + fibfib_helper (n - 3)))\n  in\n  fibfib_helper n 0"], ["(**Write a function vowels_count which takes a string representing\n * a word as input and returns the number of vowels in the string.\n * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n * vowel, but only when it is at the end of the given word.\n * Example:\n * >>> vowels_count \"abcde\"\n * 2\n * >>> vowels_count \"ACEDY\"\n * 3\n*)\nlet vowels_count (s : string) : int =\n  let rec vowels_count_inner acc = function\n    | [] -> acc\n    | 'a' .. 'z' :: rest -> vowels_count_inner (acc + 1) rest\n    | 'A' .. 'Z' :: rest -> vowels_count_inner (acc + 1) rest\n    | '0' .. '9' :: rest -> vowels_count_inner (acc + 1) rest\n    | 'y' :: rest -> vowels_count_inner (acc + 1) rest\n    | _ :: rest -> vowels_count_inner acc rest\n  in\n  vowels_count_inner 0 s"], ["(**Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n * If shift > number of digits, return digits reversed.\n * >>> circular_shift 12 1\n * \"21\"\n * >>> circular_shift 12 2\n * \"12\"\n*)\nlet circular_shift (x : int) (shift : int) : string =\n  let rec shift_digits n =\n    match n with\n    | 0 -> \"\"\n    | _ ->\n        let digits = String.init n (fun _ -> char_of_int (x % 10)) in\n        let reversed_digits = String.init (n - 1) (fun _ -> char_of_int (x / 10)) in\n        digits @ reversed_digits\n  in\n  match shift with\n  | 0 -> shift_digits 0\n  | _ -> shift_digits (shift - 1)"], ["(**Task\n * Write a function that takes a string as input and returns the sum of the upper characters only'\n * ASCII codes.\n * Examples:\n * >>> digitSum \"\"\n * 0\n * >>> digitSum \"abAB\"\n * 131\n * >>> digitSum \"abcCd\"\n * 67\n * >>> digitSum \"helloE\"\n * 69\n * >>> digitSum \"woArBld\"\n * 131\n * >>> digitSum \"aAaaaXa\"\n * 153\n*)\nlet digitSum (s : string) : int =\n  let rec sumDigits (s : string) : int =\n    match s with\n    | \"\" -> 0\n    | _ ->\n        let c = char_of_string s.[0]\n        let c' = char_of_string s.[1]\n        if c = c' then sumDigits (s.[1..]) else c + sumDigits (s.[..])\n  in\n  sumDigits s"], ["(**In this task, you will be given a string that represents a number of apples and oranges \n * that are distributed in a basket of fruit this basket contains \n * apples, oranges, and mango fruits. Given the string that represents the total number of \n * the oranges and apples and an integer that represent the total number of the fruits \n * in the basket return the number of the mango fruits in the basket.\n * for examble:\n * >>> fruit_distribution \"5 apples and 6 oranges\" 19\n * 8\n * >>> fruit_distribution \"0 apples and 1 oranges\" 3\n * 2\n * >>> fruit_distribution \"2 apples and 3 oranges\" 100\n * 95\n * >>> fruit_distribution \"100 apples and 1 oranges\" 120\n * 19\n*)\nlet fruit_distribution (s : string) (n : int) : int =\n  let rec count_fruits n fruits =\n    match fruits with\n    | [] -> 0\n    | hd :: t ->\n        if hd = 'o' then n - 1\n        else if hd = 'a' then n - 2\n        else n\n  in\n  let rec count_apples n fruits =\n    match fruits with\n    | [] -> 0\n    | hd :: t ->\n        if hd = 'a' then n - 1\n        else if hd = 'o' then n - 2\n        else n\n  in\n  let rec count_oranges n fruits =\n    match fruits with\n    | [] -> 0\n    | hd :: t ->\n        if hd = 'o' then n - 1\n        else if hd = 'a' then n - 2\n        else n\n  in\n  let rec count_mangoes n fruits =\n    match fruits with\n    | [] -> 0\n    | hd :: t ->\n        if hd = 'm' then n - 1\n        else if hd = 'a' then n - 2\n        else n\n  in\n  let rec count_total n fruits =\n"], ["(**\"Given a list representing a branch of a tree that has non-negative integer nodes\n * your task is to pluck one of the nodes and return it.\n * The plucked node should be the node with the smallest even value.\n * If multiple nodes with the same smallest even value are found return the node that has smallest index.\n * The plucked node should be returned in a list, [ smalest_value, its index ],\n * If there are no even values or the given list is empty, return [].\n * Example 1:\n * >>> pluck [4; 2; 3]\n * [2; 1]\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 2:\n * >>> pluck [1; 2; 3]\n * [2; 1]\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 3:\n * >>> pluck []\n * []\n * Example 4:\n * >>> pluck [5; 0; 3; 0; 4; 2]\n * [0; 1]\n * Explanation: 0 is the smallest value, but  there are two zeros,\n * so we will choose the first zero, which has the smallest index.\n * Constraints:\n * * 1 <= nodes.length <= 10000\n * * 0 <= node.value\n*)\nlet pluck (arr : int list) : int list =\n  let rec pluck_helper (arr : int list) (n : int) (acc : int list) : int list =\n    match arr with\n    | [] -> acc\n    | hd :: tl ->\n        if n < hd.value then\n          pluck_helper tl (n + 1) (hd :: acc)\n        else if n > hd.value then\n          pluck_helper tl (n - hd.value) (hd :: acc)\n        else\n          hd :: acc\n  in\n  pluck_helper arr 0 []"], ["(**You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n * zero, and has a frequency greater than or equal to the value of the integer itself. \n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exist, return -1.\n * Examples:\n * >>> search [4; 1; 2; 2; 3; 1]\n * 2\n * >>> search [1; 2; 2; 3; 3; 3; 4; 4; 4]\n * 3\n * >>> search [5; 5; 4; 4; 4]\n * (~1)\n*)\nlet search (lst : int list) : int =\n  let rec search_aux lst n =\n    match lst with\n    | [] -> -1\n    | hd :: tl ->\n        if n = 0 then hd\n        else if n = 1 then hd\n        else if n = 2 then if tl = [] then hd\n        else if n = 3 then if tl = [] then hd\n        else if n = 4 then if tl = [] then hd\n        else if n = 5 then if tl = [] then hd\n        else if n = 6 then if tl = [] then hd\n        else if n = 7 then if tl = [] then hd\n        else if n = 8 then if tl = [] then hd\n        else if n = 9 then if tl = [] then hd\n        else if n = 10 then if tl = [] then hd\n        else if n = 11 then if tl = [] then hd\n        else if n = 12 then if tl = [] then hd\n        else if n = 13 then if tl = [] then hd\n        else if n = 14 then if tl = [] then hd\n        else if n = 15 then if tl = [] then hd\n        else if n = 16 then if tl = [] then hd\n        else if n = 17 then if tl = [] then hd"], ["(**Given list of integers, return list in strange order.\n * Strange sorting, is when you start with the minimum value,\n * then maximum of the remaining integers, then minimum and so on.\n * Examples:\n * >>> strange_sort_list [1; 2; 3; 4]\n * [1; 4; 2; 3]\n * >>> strange_sort_list [5; 5; 5; 5]\n * [5; 5; 5; 5]\n * >>> strange_sort_list []\n * []\n*)\nlet strange_sort_list (lst : int list) : int list =\n  let rec sort_list_helper lst =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let min_val = hd\n        in\n        let max_val = hd\n        in\n        let min_idx = List.find_index (fun x -> x < min_val) lst\n        in\n        let max_idx = List.find_index (fun x -> x > max_val) lst\n        in\n        let min_val_idx = List.find_index (fun x -> x < min_val) tl\n        in\n        let max_val_idx = List.find_index (fun x -> x > max_val) tl\n        in\n        let min_val_idx_max_val = List.nth lst min_val_idx\n        in\n        let max_val_idx_min_val = List.nth lst max_val_idx\n        in\n        let min_val_idx_min_val = List.nth lst min_val_idx\n        in\n        let max_val_idx_max_val = List.nth lst max_val_idx\n        in\n        let min_val_idx_max_val_min_val = List.nth lst min_val_idx_max_val\n        in\n        let max_val_idx_min_val_min_val = List.nth lst max_val_idx_min_val\n        in\n        let min_val_idx_min_val_min_val = List.nth lst min_val_idx_min_val\n        in"], ["(**Given the lengths of the three sides of a triangle. Return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n * Otherwise return -1\n * Three sides make a valid triangle when the sum of any two sides is greater \n * than the third side.\n * Example:\n * >>> triangle_area 3 4 5\n * 6.0\n * >>> triangle_area 1 2 10\n * (~1).0\n*)\nlet triangle_area (a : int) (b : int) (c : int) : float =\n  let rec area_rec (a, b, c) : float =\n    match (a, b, c) with\n    | (a, _, _) | (_, a, _) | (_, _, b) | (_, _, b) ->\n        let (d, e) = (a + b, a + c) in\n        if d = c then (d * e) / 2.0\n        else if d = a then (d * e) / 2.0\n        else if d = b then (d * e) / 2.0\n        else -1.0\n    | _ -> -1.0\n  in\n  area_rec (a, b, c)"], ["(**Write a function that returns true if the object q will fly, and false otherwise.\n * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n * Example:\n * >>> will_it_fly [1; 2] 5\n * false\n * # 1+2 is less than the maximum possible weight, but it's unbalanced.\n * >>> will_it_fly [3; 2; 3] 1\n * false\n * # it's balanced, but 3+2+3 is more than the maximum possible weight.\n * >>> will_it_fly [3; 2; 3] 9\n * true\n * # 3+2+3 is less than the maximum possible weight, and it's balanced.\n * >>> will_it_fly [3] 5\n * true\n * # 3 is less than the maximum possible weight, and it's balanced.\n*)\nlet will_it_fly (q : int list) (w : int) : bool =\n  let rec balanced_sum (q : int list) : bool =\n    match q with\n    | [] -> true\n    | _ :: rest ->\n        let rec sum_of_rest (rest : int list) : int =\n          match rest with\n          | [] -> 0\n          | _ :: rest ->\n              let sum = rest |> List.fold_left (fun acc x -> acc + x) 0 in\n              sum + sum_of_rest rest\n        in\n        sum_of_rest q <= w\n  in\n  balanced_sum q <= w"], ["(**Given a list arr of integers, find the minimum number of elements that\n * need to be changed to make the list palindromic. A palindromic list is a list that\n * is read the same backwards and forwards. In one change, you can change one element to any other element.\n * For example:\n * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]\n * 4\n * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]\n * 1\n * >>> smallest_change [1; 2; 3; 2; 1]\n * 0\n*)\nlet smallest_change (arr : int list) : int =\n  let rec smallest_change_helper arr =\n    match arr with\n    | [] -> 0\n    | hd :: tl ->\n        if hd = tl then 1\n        else if hd < tl then smallest_change_helper tl\n        else smallest_change_helper (hd :: tl)\n  in\n  smallest_change_helper arr"], ["(**Write a function that accepts two lists of strings and returns the list that has \n * total number of chars in the all strings of the list less than the other list.\n * if the two lists have the same number of chars, return the first list.\n * Examples\n * >>> total_match [] []\n * []\n * >>> total_match [\"hi\"; \"admin\"] [\"hI\"; \"Hi\"]\n * [\"hI\"; \"Hi\"]\n * >>> total_match [\"hi\"; \"admin\"] [\"hi\"; \"hi\"; \"admin\"; \"project\"]\n * [\"hi\"; \"admin\"]\n * >>> total_match [\"hi\"; \"admin\"] [\"hI\"; \"hi\"; \"hi\"]\n * [\"hI\"; \"hi\"; \"hi\"]\n * >>> total_match [\"4\"] [\"1\"; \"2\"; \"3\"; \"4\"; \"5\"]\n * [\"4\"]\n*)\nlet total_match (lst1 : string list) (lst2 : string list) : string list =\n  let rec helper lst1 lst2 acc =\n    match lst1, lst2 with\n    | [], _ -> acc\n    | _, [] -> acc\n    | h1::t1, h2::t2 ->\n      if h1 = h2 then helper t1 t2 (h1::acc)\n      else if h1 < h2 then helper t1 (h2::lst2) acc\n      else helper (h1::lst1) t2 acc\n  in\n  helper lst1 lst2 []"], ["(**Write a function that returns true if the given number is the multiplication of 3 prime numbers\n * and false otherwise.\n * Knowing that (a) is less then 100. \n * Example:\n * >>> is_multiply_prime 30\n * true\n * 30 = 2 * 3 * 5\n*)\nlet is_multiply_prime (a : int) : bool =\n  let rec is_prime_rec n =\n    if n <= 1 then false\n    else if n = 2 || n = 3 then true\n    else if n mod 2 = 0 then is_prime_rec (n / 2)\n    else is_prime_rec (n - 1)\n  in\n  is_prime_rec a"], ["(**Your task is to write a function that returns true if a number x is a simple\n * power of n and false in other cases.\n * x is a simple power of n if n**int=x\n * For example:\n * >>> is_simple_power 1 4\n * true\n * >>> is_simple_power 2 2\n * true\n * >>> is_simple_power 8 2\n * true\n * >>> is_simple_power 3 2\n * false\n * >>> is_simple_power 3 1\n * false\n * >>> is_simple_power 5 3\n * false\n*)\nlet is_simple_power (x : int) (n : int) : bool =\n  let rec simple_power n x =\n    match n with\n    | 0 -> false\n    | _ ->\n        if x = n then true\n        else simple_power (n - 1) x\n  in\n  simple_power n x"], ["(**Write a function that takes an integer a and returns true \n * if this ingeger is a cube of some integer number.\n * Note: you may assume the input is always valid.\n * Examples:\n * >>> iscube 1\n * true\n * >>> iscube 2\n * false\n * >>> iscube (~1)\n * true\n * >>> iscube 64\n * true\n * >>> iscube 0\n * true\n * >>> iscube 180\n * false\n*)\nlet iscube (a : int) : bool =\n  match a with\n  | 0 -> false\n  | _ -> (a * a * a) = a"], ["(**You have been tasked to write a function that receives \n * a hexadecimal number as a string and counts the number of hexadecimal \n * digits that are primes (prime number, or a prime, is a natural number \n * greater than 1 that is not a product of two smaller natural numbers).\n * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n * So you have to determine a number of the following digits: 2, 3, 5, 7, \n * B (=decimal 11), D (=decimal 13).\n * Note: you may assume the input is always correct or empty string, \n * and symbols A,B,C,D,E,F are always uppercase.\n * Examples:\n * >>> hex_key \"AB\"\n * 1\n * >>> hex_key \"1077E\"\n * 2\n * >>> hex_key \"ABED1A33\"\n * 4\n * >>> hex_key \"123456789ABCDEF0\"\n * 6\n * >>> hex_key \"2020\"\n * 2\n*)\nlet hex_key (num : string) : int =\n  let rec count_digits (num : string) : int =\n    match num with\n    | \"0\" -> 0\n    | \"1\" -> 1\n    | \"2\" -> 2\n    | \"3\" -> 3\n    | \"4\" -> 4\n    | \"5\" -> 5\n    | \"6\" -> 6\n    | \"7\" -> 7\n    | \"8\" -> 8\n    | \"9\" -> 9\n    | \"A\" -> 10\n    | \"B\" -> 11\n    | \"C\" -> 12\n    | \"D\" -> 13\n    | \"E\" -> 14\n    | \"F\" -> "], ["(**You will be given a number in decimal form and your task is to convert it to\n * binary format. The function should return a string, with each character representing a binary\n * number. Each character in the string will be '0' or '1'.\n * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n * The extra characters are there to help with the format.\n * Examples:\n * >>> decimal_to_binary 15\n * \"db1111db\"\n * >>> decimal_to_binary 32\n * \"db100000db\"\n*)\nlet decimal_to_binary (decimal : int) : string =\n  let rec binary_to_decimal (binary : string) : int =\n    match binary with\n    | \"0\" -> 0\n    | \"1\" -> 1\n    | \"00\" -> decimal * 2\n    | \"01\" -> decimal * 3\n    | \"10\" -> decimal * 4\n    | \"11\" -> decimal * 5\n    | \"100\" -> decimal * 6\n    | \"101\" -> decimal * 7\n    | \"110\" -> decimal * 8\n    | \"111\" -> decimal * 9\n    | _ -> invalid_arg \"Invalid binary number\"\n  in\n  let rec binary_to_decimal_helper (binary : string) : int =\n    match binary with\n    | \"0\" -> 0\n    | \"1\" -> 1\n    | \"00\" -> decimal_to_binary (binary_to_decimal (binary_to_decimal_helper (binary_to_decimal binary)))\n    | \"01\" -> decimal_to_binary (binary_to_decimal (binary_to_decimal_helper (binary_to_decimal binary)))\n    | \"10\" -> decimal_to_binary (binary_to_decimal (binary_to_decimal_helper (binary_to_decimal binary)))\n    | \"11\" -> decimal_to_binary (binary_to_decimal (binary_to_decimal_helper (binary_to_decimal binary)))\n"], ["(**You are given a string s.\n * Your task is to check if the string is hapml or not.\n * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct\n * For example:\n * >>> is_happy \"a\"\n * false\n * >>> is_happy \"aa\"\n * false\n * >>> is_happy \"abcd\"\n * true\n * >>> is_happy \"aabb\"\n * false\n * >>> is_happy \"adb\"\n * true\n * >>> is_happy \"xyy\"\n * false\n*)\nlet is_happy (s : string) : bool =\n  let rec is_happy_rec (s : string) : bool =\n    match s with\n    | \"\" -> true\n    | _ when s.Length = 0 -> true\n    | _ when s.Length = 1 -> true\n    | _ when s.Length = 2 -> false\n    | _ when s.Length = 3 -> is_happy_rec (s.Substring(1, 2)) || is_happy_rec (s.Substring(2, 2))\n    | _ -> false\n  in\n  is_happy_rec s"], ["(**It is the last week of the semester and the teacher has to give the grades\n * to students. The teacher has been making her own algorithm for grading.\n * The only problem is, she has lost the code she used for grading.\n * She has given you a list of GPAs for some students and you have to write \n * a function that can output a list of letter grades using the following table:\n * GPA       |    Letter grade\n * 4.0                A+\n * > 3.7                A \n * > 3.3                A- \n * > 3.0                B+\n * > 2.7                B \n * > 2.3                B-\n * > 2.0                C+\n * > 1.7                C\n * > 1.3                C-\n * > 1.0                D+ \n * > 0.7                D \n * > 0.0                D-\n * 0.0                E\n * Example:\n * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]\n * [\"A+\"; \"B\"; \"C-\"; \"C\"; \"A-\"]\n*)\nlet numerical_letter_grade (grades : float list) : string list =\n  let rec numerical_grade_list (grades : float list) : string list =\n    match grades with\n    | [] -> []\n    | [x] -> [string_of_float x]\n    | _ ->\n        let (min_grade, max_grade) =\n          List.fold_left (fun (min_grade, max_grade) x ->\n            if x < min_grade then (min_grade, x) else (x, max_grade))\n          (0.0, 10.0) grades\n        in\n        List.map (fun x -> string_of_float x) (List.filter (fun x -> x >= min_grade && x <= max_grade) grades)\n  in\n  numerical_grade_list grades"], ["(**Write a function that takes a string and returns true if the string\n * length is a prime number or false otherwise\n * Examples\n * >>> prime_length \"Hello\"\n * true\n * >>> prime_length \"abcdcba\"\n * true\n * >>> prime_length \"kittens\"\n * true\n * >>> prime_length \"orange\"\n * false\n*)\nlet prime_length (string : string) : bool =\n  let rec is_prime n =\n    if n <= 1 then false\n    else if n = 2 then true\n    else if n mod 2 = 0 then false\n    else n > 1 && is_prime (n - 1)\n  in\n  String.length string > 0 && is_prime String.length string"], ["(**Given a positive integer n, return the count of the numbers of n-digit\n * positive integers that start or end with 1.\n*)\nlet starts_one_ends (n : int) : int =\n  let rec count_ones_ends (n : int) : int =\n    match n with\n    | 0 -> 0\n    | _ -> 1 + count_ones_ends (n / 10) * 10\n  in\n  count_ones_ends n"], ["(**Given a positive integer N, return the total sum of its digits in binary.\n * Example\n * >>> solve 1000\n * \"1\"\n * >>> solve 150\n * \"110\"\n * >>> solve 147\n * \"1100\"\n * Variables:\n * @N integer\n * Constraints: 0 \u2264 N \u2264 10000.\n * Output:\n * a string of binary number\n*)\nlet solve (N : int) : string =\n  let rec sum_digits n =\n    match n with\n    | 0 -> \"0\"\n    | _ ->\n        let digits = n.ToString()\n            |> String.split_on_char '0'\n            |> List.map int_of_string\n            |> List.rev\n            |> List.filter (fun x -> x <> 0)\n            |> List.map int_of_string\n            |> List.rev\n            |> List.fold (fun acc x -> acc + x) 0\n        in\n        String.concat \"\" digits\n  in\n  sum_digits N"], ["(**Given a non-empty list of integers lst. add the even elements that are at odd indices..\n * Examples:\n * >>> add [4; 2; 6; 7]\n * 2\n*)\nlet add (lst : int list) : int =\n  let rec add_even lst =\n    match lst with\n    | [] -> 0\n    | hd :: tl ->\n        if hd % 2 = 0 then hd + add_even tl else hd + 1\n  in\n  add_even lst"], ["(**Write a function that takes a string and returns an ordered version of it.\n * Ordered version of string, is a string where all words (separated by space)\n * are replaced by a new word where all the characters arranged in\n * ascending order based on ascii value.\n * Note: You should keep the order of words and blank spaces in the sentence.\n * For example:\n * >>> anti_shuffle \"Hi\"\n * \"Hi\"\n * >>> anti_shuffle \"hello\"\n * \"ehllo\"\n * >>> anti_shuffle \"Hello World!!!\"\n * \"Hello !!!Wdlor\"\n*)\nlet anti_shuffle (s : string) : string =\n  let rec anti_shuffle_aux (s : string) : string =\n    match s with\n    | \"\" -> \"\"\n    | \" \"::ss -> anti_shuffle_aux ss\n    | (a::as) ->\n        let (b, c) = String.split_on_char ' ' a in\n        let (d, e) = String.split_on_char ' ' b in\n        let (f, g) = String.split_on_char ' ' c in\n        let (h, i) = String.split_on_char ' ' d in\n        let (j, k) = String.split_on_char ' ' e in\n        let (l, m) = String.split_on_char ' ' f in\n        let (n, o) = String.split_on_char ' ' g in\n        let (p, q) = String.split_on_char ' ' h in\n        let (r, s) = String.split_on_char ' ' i in\n        let (t, u) = String.split_on_char ' ' j in\n        let (v, w) = String.split_on_char ' ' k in\n        let (x, y) = String.split_on_char ' ' l in\n        let (z, _) = String.split_on_char ' ' m in\n        let (aa, bb) = String.split_on_char ' ' n in\n        let (cc, dd) = String.split_on_char ' ' o in\n        let ("], ["(**You are given a 2 dimensional data, as a nested lists,\n * which is similar to matrix, however, unlike matrices,\n * each row may contain a different number of columns.\n * Given lst, and integer x, find integers x in the list,\n * and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n * each tuple is a coordinate - (row, columns), starting with 0.\n * Sort coordinates initially by rows in ascending order.\n * Also, sort coordinates of the row by columns in descending order.\n * Examples:\n * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1\n * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]\n * >>> get_row [] 1\n * []\n * >>> get_row [[]; [1]; [1; 2; 3]] 3\n * [(2, 2)]\n*)\nlet get_row (lst : int list list) (x : int) :  int * int list =\n  let rec get_row_helper lst x =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let (row, col) = hd in\n        if row = x then\n          let (row', col') = get_row_helper tl x in\n          (row', col') :: (get_row_helper tl col)\n        else\n          let (row', col') = get_row_helper tl col in\n          (row', col') :: (get_row_helper tl row)\n    | _ ->\n        let (row, col) = lst |> List.nth 0 in\n        let (row', col') = get_row_helper lst col in\n        (row, col') :: (get_row_helper lst row)\n  in\n  get_row_helper lst x"], ["(**Given a list of non-negative integers, return a coml of the given list after sorting,\n * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n * Note:\n * * don't change the given list.\n * Examples:\n * >>> sort_array []\n * []\n * >>> sort_array [5]\n * [5]\n * >>> sort_array [2; 4; 3; 0; 1; 5]\n * [0; 1; 2; 3; 4; 5]\n * >>> sort_array [2; 4; 3; 0; 1; 5; 6]\n * [6; 5; 4; 3; 2; 1; 0]\n*)\nlet sort_array (array : int list) : int list =\n  let rec sort_helper (array : int list) (sum : int) : int list =\n    match array with\n    | [] -> []\n    | hd :: tl ->\n        if sum mod 2 = 1 then tl else hd :: sort_helper tl (sum + hd)\n  in\n  sort_helper array 0"], ["(**Create a function encrypt that takes a string as an argument and\n * returns a string encrypted with the alphabet being rotated. \n * The alphabet should be rotated in a manner such that the letters \n * shift down by two multiplied to two places.\n * For example:\n * >>> encrypt \"hi\"\n * \"lm\"\n * >>> encrypt \"asdfghjkl\"\n * \"ewhjklnop\"\n * >>> encrypt \"gf\"\n * \"kj\"\n * >>> encrypt \"et\"\n * \"ix\"\n*)\nlet encrypt (s : string) : string =\n  let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  let rotated_alphabet = alphabet |> List.map (fun c -> c + 2 * 2)\n  let rotated_alphabet_string = rotated_alphabet |> String.concat \"\"\n  let rotated_alphabet_string_length = rotated_alphabet_string.Length\n  let rotated_alphabet_string_index = rotated_alphabet_string |> String.index_of ' '\n  let rotated_alphabet_string_index_2 = rotated_alphabet_string_index + rotated_alphabet_string_length - 1\n  let rotated_alphabet_string_index_2 = rotated_alphabet_string_index_2 |> String.index_of ' '\n  let rotated_alphabet_string_index_3 = rotated_alphabet_string_index_2 + rotated_alphabet_string_length - 1\n  let rotated_alphabet_string_index_3 = rotated_alphabet_string_index_3 |> String.index_of ' '\n  let rotated_alphabet_string_index_4 = rotated_alphabet_string_index_3 + rotated_alphabet_string_length - 1\n  let rotated_alphabet_string_index_4 = rotated_alphabet_string_index_4 |> String.index_of ' '\n  let rotated_alphabet_string_index_5 = rotated_alphabet_string_index_4 + rotated_alphabet_string_length - 1\n"], ["(**You are given a list of integers.\n * Write a function next_smallest() that returns the 2nd smallest element of the list.\n * Return None if there is no such element.\n * >>> next_smallest [1; 2; 3; 4; 5]\n * Some(2)\n * >>> next_smallest [5; 1; 4; 3; 2]\n * Some(2)\n * >>> next_smallest []\n * Some(None)\n * >>> next_smallest [1; 1]\n * Some(None)\n*)\nlet next_smallest (lst : int list) : int option =\n  let rec aux lst =\n    match lst with\n    | [] -> None\n    | hd :: tl ->\n        if hd < aux tl then Some hd else aux tl\n  in\n  aux lst"], ["(**You'll be given a string of words, and your task is to count the number\n * of boredoms. A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n * For example:\n * >>> is_bored \"Hello world\"\n * 0\n * >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n * 1\n*)\nlet is_bored (S : string) : int =\n  let rec count_boredness (s : string) : int =\n    match s with\n    | \"\" -> 0\n    | \".\" -> 1\n    | \"?\" -> 2\n    | \"!\" -> 3\n    | \" \" -> 4\n    | _ -> 5\n  in\n  count_boredness S"], ["(**Create a function that takes 3 numbers.\n * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n * Returns false in any other cases.\n * Examples\n * >>> any_int 5 2 7\n * true\n * >>> any_int 3 2 2\n * false\n * >>> any_int 3 (~2) 1\n * true\n * >>> any_int 3.6 -2.2 2\n * false\n*)\nlet any_int (x : float) (y : float) (z : float) : bool =\n  let rec sum_of_squares (x : float) (y : float) (z : float) : float =\n    match (x, y, z) with\n    | (x, y, z) -> x + y + z\n  in\n  sum_of_squares x y z = sum_of_squares x y + sum_of_squares y z"], ["(**Write a function that takes a message, and encodes in such a \n * way that it swaps case of all letters, replaces all vowels in \n * the message with the letter that appears 2 places ahead of that \n * vowel in the english alphabet. \n * Assume only letters. \n * Examples:\n * >>> encode \"test\"\n * \"TGST\"\n * >>> encode \"This is a message\"\n * \"tHKS KS C MGSSCGG\"\n*)\nlet encode (message : string) : string =\n  let swapCase (c : char) : char =\n    match c with\n    | 'a' -> 'A'\n    | 'A' -> 'a'\n    | 'e' -> 'E'\n    | 'E' -> 'e'\n    | 'i' -> 'I'\n    | 'I' -> 'i'\n    | 'o' -> 'O'\n    | 'O' -> 'o'\n    | 'u' -> 'U'\n    | 'U' -> 'u'\n    | _ -> c\n  let swapVowels (c : char) : char =\n    match c with\n    | 'a' -> 'A'\n    | 'A' -> 'a'\n    | 'e' -> 'E'\n    | 'E' -> 'e'\n    | 'i' -> 'I'\n    | 'I' -> 'i'\n    | 'o' -> 'O'\n    | 'O' -> 'o'\n    | 'u' -> 'U'\n    | 'U' -> 'u'\n    | _ -> c\n  let swapEnglish (c : char) : char =\n    match c with\n    | 'a' -> 'A'\n    | 'A' -> 'a'\n    | 'e' -> 'E'\n    | 'E' -> 'e'\n    | 'i' -> 'I'\n    | 'I' -> 'i'\n    | 'o' -> 'O'\n    | 'O' -> 'o'\n    | 'u' -> 'U'\n    | 'U' -> 'u'\n    | _ -> c\n  let swapChar (c : char"], ["(**You are given a list of integers.\n * You need to find the largest prime value and return the sum of its digits.\n * Examples:\n * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]\n * 10\n * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]\n * 25\n * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]\n * 13\n * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]\n * 11\n * >>> skjkasdkd [0; 81; 12; 3; 1; 21]\n * 3\n * >>> skjkasdkd [0; 8; 1; 2; 1; 7]\n * 7\n*)\nlet skjkasdkd (lst : int list) : int =\n  let rec find_largest_prime lst =\n    match lst with\n    | [] -> 0\n    | hd :: tl ->\n        if hd mod 2 = 0 then\n          let largest_prime = find_largest_prime tl in\n          largest_prime + hd\n        else\n          find_largest_prime tl\n  in\n  find_largest_prime lst"], ["(**Given an association list, return true if all keys are strings in lower \n * case or all keys are strings in upper case, else return false.\n * The function should return false is the given association list is empty.\n * Examples:\n * >>> check_dict_case [(\"a\", \"apple\"); (\"b\", \"banana\")]\n * true\n * >>> check_dict_case [(\"a\", \"apple\"); (\"A\", \"banana\"); (\"B\", \"banana\")]\n * false\n * >>> check_dict_case [(\"a\", \"apple\"); (8, \"banana\"); (\"a\", \"apple\")]\n * false\n * >>> check_dict_case [(\"Name\", \"John\"); (\"Age\", \"36\"); (\"City\", \"Houston\")]\n * false\n * >>> check_dict_case [(\"STATE\", \"NC\"); (\"ZIP\", \"12345\")]\n * true\n*)\nlet check_dict_case (dict : (string, string) list) : bool =\n  let rec check_case_string (key : string) (value : string) : bool =\n    match dict with\n    | [] -> true\n    | (key', value') :: rest ->\n        if key = key' && value = value'\n        then check_case_string key value rest\n        else false\n  in\n  check_case_string \"Name\" \"John\"\n  && check_case_string \"Age\" \"36\"\n  && check_case_string \"City\" \"Houston\"\n  && check_case_string \"STATE\" \"NC\"\n  && check_case_string \"ZIP\" \"12345\"\n;;"], ["(**Implement a function that takes an non-negative integer and returns a list of the first n\n * integers that are prime numbers and less than n.\n * for example:\n * >>> count_up_to 5\n * [2; 3]\n * >>> count_up_to 11\n * [2; 3; 5; 7]\n * >>> count_up_to 0\n * []\n * >>> count_up_to 20\n * [2; 3; 5; 7; 11; 13; 17; 19]\n * >>> count_up_to 1\n * []\n * >>> count_up_to 18\n * [2; 3; 5; 7; 11; 13; 17]\n*)\nlet count_up_to (n : int) : int list =\n  let rec aux n acc =\n    if n <= 0 then acc\n    else if n mod 2 = 0 then aux (n / 2) (n :: acc)\n    else aux (n - 1) (n :: acc)\n  in aux n []"], ["(**Complete the function that takes two integers and returns \n * the product of their unit digits.\n * Assume the input is always valid.\n * Examples:\n * >>> multiply 148 412\n * 16\n * >>> multiply 19 28\n * 72\n * >>> multiply 2020 1851\n * 0\n * >>> multiply 14 (~15)\n * 20\n*)\nlet multiply (a : int) (b : int) : int =\n  let rec loop (a : int) (b : int) : int =\n    match (a, b) with\n    | (0, _) -> 0\n    | (_, 0) -> 0\n    | (a, b) -> a * b\n  in\n  loop a b"], ["(**Given a string s, count the number of uppercase vowels in even indices.\n * For example:\n * >>> count_upper \"aBCdEf\"\n * 1\n * >>> count_upper \"abcdefg\"\n * 0\n * >>> count_upper \"dBBE\"\n * 0\n*)\nlet count_upper (s : string) : int =\n  let rec count_even_indices (i : int) : int =\n    match i with\n    | 0 -> 1\n    | n -> if s.[n] = 'A' then 1 + count_even_indices (n - 1) else 0\n  in\n  count_even_indices (String.length s - 1)"], ["(**Create a function that takes a value (string) representing a number\n * and returns the closest integer to it. If the number is equidistant\n * from two integers, round it away from zero.\n * Examples\n * >>> closest_integer \"10\"\n * 10\n * >>> closest_integer \"15.3\"\n * 15\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n*)\nlet closest_integer (value : string) : int =\n  let rec closest_integer_helper (value : string) (min_value : int) (max_value : int) : int =\n    match value with\n    | \"\" -> min_value\n    | \"0\" -> min_value\n    | \"1\" -> min_value\n    | \"2\" -> min_value\n    | \"3\" -> min_value\n    | \"4\" -> min_value\n    | \"5\" -> min_value\n    | \"6\" -> min_value\n    | \"7\" -> min_value\n    | \"8\" -> min_value\n    | \"9\" -> min_value\n    | \"10\" -> min_value\n    | \"11\" -> min_value\n    | \"12\" -> min_value\n    | \"13\" -> min_value\n    | \"14\" -> min_value\n    | \"15\" -> min_value\n    | \"16\" -> min_value\n    | \"17\" -> min_value\n    | \"18\" -> min_value\n    | \"19\" -> min_value\n    | \"20\" -> min_value\n    | \"21\" -> min_value\n    | \"22\" -> min_value\n    | \"23\" -> min_value\n    | \"24\" -> min_value\n    | \"25\" -> min_value\n    | \"26\" -> min_value\n    | \"2"], ["(**Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n * Examples:\n * >>> make_a_pile 3\n * [3; 5; 7]\n*)\nlet make_a_pile (n : int) : int list =\n  let rec make_level n =\n    if n = 1 then [n]\n    else if n mod 2 = 0 then [n; n + 1]\n    else [n; n + 1; n + 2]\n  in\n  List.map make_level [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]"], ["(**You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return a list of the words.\n * For example:\n * >>> words_string \"Hi, my name is John\"\n * [\"Hi\"; \"my\"; \"name\"; \"is\"; \"John\"]\n * >>> words_string \"One, two, three, four, five, six\"\n * [\"One\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"]\n*)\nlet words_string (s : string) : string list =\n  let rec split_words s =\n    match s with\n    | \"\" -> []\n    | c :: cs ->\n        if c = ',' || c = ' ' then\n          split_words cs\n        else\n          let (words, rest) = String.split_on_char c s in\n          words :: split_words rest\n  in\n  split_words s\n;;"], ["(**This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive. If \n * there's no such number, then the function should return -1.\n * For example:\n * >>> choose_num 12 15\n * 14\n * >>> choose_num 13 12\n * (~1)\n*)\nlet choose_num (x : int) (y : int) : int =\n  let rec choose_num_helper x y n =\n    if n = 0 then -1\n    else if n = 1 then x\n    else if x < y then choose_num_helper x y (n - 1)\n    else choose_num_helper y x (n - 1)\n  in choose_num_helper x y 1"], ["(**Given a list of positive integers x. return a sorted list of all \n * elements that hasn't any even digit.\n * Note: Returned list should be sorted in increasing order.\n * For example:\n * >>> unique_digits [15; 33; 1422; 1]\n * [1; 15; 33]\n * >>> unique_digits [152; 323; 1422; 10]\n * []\n*)\nlet unique_digits (x : int list) : int list =\n  let rec unique_digits_helper (x : int list) : int list =\n    match x with\n    | [] -> []\n    | hd :: tl ->\n        if hd mod 2 = 0 then hd :: unique_digits_helper tl else hd :: unique_digits_helper tl\n  in\n  unique_digits_helper x\n;;"], ["(**Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting list, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n * For example:\n * >>> by_length [2; 1; 1; 4; 5; 8; 2; 3]\n * [\"Eight\"; \"Five\"; \"Four\"; \"Three\"; \"Two\"; \"Two\"; \"One\"; \"One\"]\n * If the list is empty, return an empty list:\n * >>> by_length []\n * []\n * If the list has any strange number ignore it:\n * >>> by_length [1; (~1); 55]\n * [\"One\"]\n*)\nlet by_length (arr : int list) : string list =\n  let rec by_length_aux arr =\n    match arr with\n    | [] -> []\n    | hd :: tl ->\n        let len = Array.length tl in\n        let rec by_length_aux_helper tl =\n          match tl with\n          | [] -> []\n          | hd :: tl ->\n              let len = Array.length tl in\n              let rec by_length_aux_helper_helper tl =\n                match tl with\n                | [] -> []\n                | hd :: tl ->\n                    let len = Array.length tl in\n                    let rec by_length_aux_helper_helper_helper tl =\n                      match tl with\n                      | [] -> []\n                      | hd :: tl ->\n                          let len = Array.length tl in\n                          let rec by_length_aux_helper_helper_helper_helper tl =\n                            match tl with\n                            | [] -> []\n                            | hd :: tl ->\n                                let len = Array.length tl in\n                                let rec by_length_aux_helper_helper_helper_helper_helper tl =\n                                  match tl with\n                                  | [] -> []\n                                  | hd :: tl ->"], ["(**Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * >>> f 5\n * [1; 2; 6; 24; 15]\n*)\nlet f (n : int) : int list =\n  let rec aux n acc =\n    if n = 0 then acc\n    else if n mod 2 = 0 then aux (n / 2) (n :: acc)\n    else aux (n / 2 + 1) (n :: acc)\n  in aux n []"], ["(**Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n * Example 1:\n * >>> even_odd_palindrome 3\n * (1, 2)\n * Explanation:\n * Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n * Example 2:\n * >>> even_odd_palindrome 12\n * (4, 6)\n * Explanation:\n * Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n * Note:\n * 1. 1 <= n <= 10^3\n * 2. returned tuple has the number of even and odd integer palindromes respectively.\n*)\nlet even_odd_palindrome (n : int) :  int * int =\n  let rec even_odd_palindrome_helper (n : int) : int * int =\n    match n with\n    | 0 -> (0, 0)\n    | _ ->\n      let even_palindrome = n % 2 = 0 in\n      let odd_palindrome = n % 2 <> 0 in\n      let even_palindrome_count = if even_palindrome then 1 else 0 in\n      let odd_palindrome_count = if odd_palindrome then 1 else 0 in\n      let even_palindrome_sum = even_palindrome ?sum ?sum in\n      let odd_palindrome_sum = odd_palindrome ?sum ?sum in\n      (even_palindrome_count, even_palindrome_sum + odd_palindrome_sum)\n    |> fun (even_palindrome_count, even_palindrome_sum) ->\n    let odd_palindrome_count = n / 2 in\n    let odd_palindrome_sum = odd_palindrome_count * odd_palindrome_sum in\n   "], ["(**Write a function count_nums which takes a list of integers and returns\n * the number of elements which has a sum of digits > 0.\n * If a number is negative, then its first signed digit will be negative:\n * e.g. -123 has signed digits -1, 2, and 3.\n * >>> count_nums []\n * 0\n * >>> count_nums [(~1); 11; (~11)]\n * 1\n * >>> count_nums [1; 1; 2]\n * 3\n*)\nlet count_nums (arr : int list) : int =\n  let rec count_sum_digits (arr : int list) : int =\n    match arr with\n    | [] -> 0\n    | (x :: xs) ->\n        let sum_digits = sum_digits x in\n        if sum_digits > 0 then count_sum_digits xs else sum_digits\n  in\n  count_sum_digits arr"], ["(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n * numbers in the list will be randomly ordered. Your task is to determine if\n * it is possible to get a list sorted in non-decreasing order by performing \n * the following operation on the given list:\n * You are allowed to perform right shift operation any number of times.\n * One right shift operation means shifting all elements of the list by one\n * position in the right direction. The last element of the list will be moved to\n * the starting position in the list i.e. 0th index. \n * If it is possible to obtain the sorted list by performing the above operation\n * then return true else return false.\n * If the given list is empty then return true.\n * Note: The given list is guaranteed to have unique elements.\n * For Example:\n * >>> move_one_ball [3; 4; 5; 1; 2]\n * true\n * Explanation: By performin 2 right shift operations, non-decreasing order can\n * be achieved for the given list.\n * >>> move_one_ball [3; 5; 4; 1; 2]\n * false\n * Explanation:It is not possible to get non-decreasing order for the given\n * list by performing any number of right shift operations.\n*)\nlet move_one_ball (arr : int list) : bool =\n  let rec move_one_ball_helper (arr : int list) (n : int) : bool =\n    match arr with\n    | [] -> true\n    | _ :: rest ->\n        if n = 0 then true\n        else if n > 0 then move_one_ball_helper rest (n - 1)\n        else move_one_ball_helper rest (n - 1)\n  in\n  move_one_ball_helper arr 0"], ["(**In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]\n * \"YES\"\n * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]\n * \"NO\"\n * It is assumed that the input lists will be non-empty.\n*)\nlet exchange (lst1 : int list) (lst2 : int list) : string =\n  let rec exchange_helper lst1 lst2 =\n    match lst1, lst2 with\n    | [], [] -> \"YES\"\n    | [], _ -> \"NO\"\n    | _, [] -> \"YES\"\n    | (x :: xs1), (y :: ys2) ->\n      if x mod 2 = 0 && y mod 2 = 0 then\n        if x = y then\n          exchange_helper xs1 ys2\n        else\n          exchange_helper xs1 (y :: ys2)\n      else\n        exchange_helper xs1 (x :: xs2)\n    | _ -> \"NO\"\n  in\n  exchange_helper lst1 lst2"], ["(**Given a string representing a space separated lowercase letters, return an association list\n * of the letter with the most repetition and containing the corresponding count.\n * If several letters have the same occurrence, return all of them.\n * Example:\n * >>> histogram \"a b c\"\n * [(\"a\", 1); (\"b\", 1); (\"c\", 1)]\n * >>> histogram \"a b b a\"\n * [(\"a\", 2); (\"b\", 2)]\n * >>> histogram \"a b c a b\"\n * [(\"a\", 2); (\"b\", 2)]\n * >>> histogram \"b b b b a\"\n * [(\"b\", 4)]\n * >>> histogram \"\"\n * []\n*)\nlet histogram (test : string) : (string, int) list =\n  let rec loop (acc : string, count : int) (char : char) : (string, int) list =\n    match char with\n    | 'a' ->\n      if List.mem char acc then\n        let count' = count + 1 in\n        loop acc count' (char ^ count')\n      else\n        [(char, count)] :: acc\n    | 'b' ->\n      if List.mem char acc then\n        let count' = count + 1 in\n        loop acc count' (char ^ count')\n      else\n        [(char, count)] :: acc\n    | 'c' ->\n      if List.mem char acc then\n        let count' = count + 1 in\n        loop acc count' (char ^ count')\n      else\n        [(char, count)] :: acc\n    | _ ->\n      acc\n  in\n  loop [] 0"], ["(**Task\n * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n * then check if the result string is palindrome.\n * A string is called palindrome if it reads the same backward as forward.\n * You should return a tuple containing the result string and true/false for the check.\n * Example\n * >>> reverse_delete \"abcde\" \"ae\"\n * (\"bcd\", false)\n * >>> reverse_delete \"abcdef\" \"b\"\n * (\"acdef\", false)\n * >>> reverse_delete \"abcdedcba\" \"ab\"\n * (\"cdedc\", true)\n*)\nlet reverse_delete (s : string) (c : string) :  string * bool =\n  let rec delete_char (s : string) (c : string) : string * bool =\n    match s, c with\n    | \"\", _ -> (s, false)\n    | s, _ ->\n        let (s', c') = String.split_on_char c s in\n        if String.length c' = 1 then (s', true) else (s', false)\n  in\n  delete_char s c"], ["(**Given a list of strings, where each string consists of only digits, return a list.\n * Each element i of the output should be \"the number of odd elements in the\n * string i of the input.\" where all the i's should be replaced by the number\n * of odd digits in the i'th string of the input.\n * >>> odd_count [\"1234567\"]\n * [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n * >>> odd_count [\"3\"; \"11111111\"]\n * [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"; \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n*)\nlet odd_count (lst : string list) : string list =\n  let rec odd_count_helper lst =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let rec odd_count_helper_helper (lst : string list) =\n          match lst with\n          | [] -> []\n          | hd :: tl ->\n              let rec odd_count_helper_helper_helper (lst : string list) =\n                match lst with\n                | [] -> []\n                | hd :: tl ->\n                    let rec odd_count_helper_helper_helper_helper (lst : string list) =\n                      match lst with\n                      | [] -> []\n                      | hd :: tl ->\n                          let rec odd_count_helper_helper_helper_helper_helper (lst : string list) =\n                            match lst with\n                            | [] -> []\n                            | hd :: tl ->\n                                let rec odd_count_helper_helper_helper_helper_helper_helper (lst : string list) =\n                                  match lst with\n                                  | [] -> []\n                                  | hd :: tl ->\n                                      let rec odd_count_helper_helper_helper_helper_helper_helper_helper (lst : string list) =\n                                        match lst with\n                                        | [] -> []\n                                        | hd :: tl ->\n                "], ["(**Given a list of integers nums, find the minimum sum of any non-empty sub-list\n * of nums.\n * Example\n * >>> minSubArraySum [2; 3; 4; 1; 2; 4]\n * 1\n * >>> minSubArraySum [(~1); (~2); (~3)]\n * (~6)\n*)\nlet minSubArraySum (nums : int list) : int =\n  let rec minSubArraySumHelper (nums : int list) : int =\n    match nums with\n    | [] -> 0\n    | hd :: tl ->\n        let rec loop (acc, sum) (hd : int) (tl : int list) : int * int =\n          match tl with\n          | [] -> (acc, sum)\n          | hd' :: tl' ->\n              let sum' = sum + hd\n              let acc' = if hd = hd' then acc + hd' else acc\n              loop (acc', sum') hd' tl'\n        in\n        loop (0, 0) hd []\n    | _ ->\n        let acc, sum = minSubArraySumHelper tl\n        loop (acc, sum) hd tl\n  in\n  minSubArraySumHelper nums"], ["(**You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n * Example 1:\n * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1\n * 6\n * Example 2:\n * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2\n * 5\n * Example 3:\n * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5\n * 0\n * Constraints:\n * * all wells have the same length\n * * 1 <= grid.length <= 10^2\n * * 1 <= grid[:,1].length <= 10^2\n * * grid[i][j] -> 0 | 1\n * * 1 <= capacity <= 10\n*)\nlet max_fill (grid : int list list) (capacity : int) : int =\n  let rec fill_buckets (buckets : int list) (capacity : int) : int =\n    match buckets with\n    | [] -> 0\n    | bucket :: rest ->\n        let bucket_capacity = Array.length bucket in\n        let bucket_capacity_max = Array.max bucket in\n        let bucket_capacity_min = Array.min bucket in\n        let bucket_capacity_sum = bucket_capacity_max - bucket_capacity_min in\n        let bucket_capacity_sum_max = Array.max bucket_capacity_sum in\n        let bucket_capacity_sum_min = Array.min bucket_capacity_sum in\n        let bucket_cap"], ["(**In this Kata, you have to sort a list of non-negative integers according to\n * number of ones in their binary representation in ascending order.\n * For similar number of ones, sort based on decimal value.\n * It must be implemented like this:\n * >>> sort_array [1; 5; 2; 3; 4]\n * [1; 2; 3; 4; 5]\n * >>> sort_array [(~2); (~3); (~4); (~5); (~6)]\n * [(~6); (~5); (~4); (~3); (~2)]\n * >>> sort_array [1; 0; 2; 3; 4]\n * [0; 1; 2; 3; 4]\n*)\nlet sort_array (arr : int list) : int list =\n  let rec sort_list_helper (lst : int list) : int list =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let rec sort_helper (lst : int list) : int list =\n          match lst with\n          | [] -> []\n          | hd :: tl ->\n              if hd = 1 then tl else\n                let rec helper (lst : int list) : int list =\n                  match lst with\n                  | [] -> []\n                  | hd :: tl ->\n                      if hd = 1 then tl else\n                        let rec helper_helper (lst : int list) : int list =\n                          match lst with\n                          | [] -> []\n                          | hd :: tl ->\n                              if hd = 1 then tl else\n                                let rec helper_helper_helper (lst : int list) : int list =\n                                  match lst with\n                                  | [] -> []\n                                  | hd :: tl ->\n                                      if hd = 1 then tl else\n                                        let rec helper_helper_helper_helper (lst : int list) : int list =\n                                          match lst with\n                                          | [] -> []\n                                          | hd :: tl ->\n                                              if hd = 1 then t"], ["(**Given a string s and a natural number n, you have been tasked to implement \n * a function that returns a list of all words from string s that contain exactly \n * n consonants, in order these words appear in the string s.\n * If the string s is empty then the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n * Examples:\n * >>> select_words \"Mary had a little lamb\" 4\n * [\"little\"]\n * >>> select_words \"Mary had a little lamb\" 3\n * [\"Mary\"; \"lamb\"]\n * >>> select_words \"simple white space\" 2\n * []\n * >>> select_words \"Hello world\" 4\n * [\"world\"]\n * >>> select_words \"Uncle sam\" 3\n * [\"Uncle\"]\n*)\nlet select_words (s : string) (n : int) : string list =\n  let rec select_words_helper (s : string) (n : int) : string list =\n    match s with\n    | \"\" -> []\n    | _ ->\n        let words = s.Split(' ')\n        in\n        let rec select_words_helper_helper (words : string list) (n : int) : string list =\n          match words with\n          | [] -> []\n          | _ :: rest ->\n              let word = words.(0)\n              in\n              if n = 0 then\n                word :: select_words_helper_helper rest (n - 1)\n              else\n                let consonants = word.Split('')\n                in\n                let consonants = List.filter (fun c -> c <> ' ') consonants\n                in\n                let consonants = List.take n consonants\n                in\n                consonants @ select_words_helper_helper rest (n - 1)\n        in\n        select_words_helper_helper words n\n  in\n  select_words_helper s n"], ["(**You are given a word. Your task is to find the closest vowel that stands between \n * two consonants from the right side of the word (case sensitive).\n * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n * find any vowel met the above condition. \n * You may assume that the given string contains English letter only.\n * Example:\n * >>> get_closest_vowel \"yogurt\"\n * \"u\"\n * >>> get_closest_vowel \"FULL\"\n * \"U\"\n * >>> get_closest_vowel \"quick\"\n * \"\"\n * >>> get_closest_vowel \"ab\"\n * \"\"\n*)\nlet get_closest_vowel (word : string) : string =\n  let rec find_closest_vowel acc = function\n    | [] -> \"\"\n    | (c1, c2) :: rest ->\n      if c1 = c2 then acc\n      else if c1 = 'a' || c1 = 'e' || c1 = 'i' || c1 = 'o' || c1 = 'u' then acc\n      else find_closest_vowel (acc + c1) rest\n  in\n  find_closest_vowel \"\" word\n"], ["(**You are given a list of two strings, both strings consist of open\n * parentheses '(' or close parentheses ')' only.\n * Your job is to check if it is possible to concatenate the two strings in\n * some order, that the resulting string will be good.\n * A string S is considered to be good if and only if all parentheses in S\n * are balanced. For example: the string '(())()' is good, while the string\n * '())' is not.\n * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n * Examples:\n * >>> match_parens [\"()(\"; \")\"]\n * \"Yes\"\n * >>> match_parens [\")\"; \")\"]\n * \"No\"\n*)\nlet match_parens (lst : string list) : string =\n  let rec loop (lst : string list) (parens : string) : string option =\n    match lst with\n    | [] -> None\n    | hd :: tl ->\n        let rec check (parens : string) : bool =\n          match parens with\n          | \"(\" -> true\n          | \")\" -> true\n          | _ -> false\n        in\n        if check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens && check parens &&"], ["(**Given a list arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n * Example 1:\n * >>> maximum [(~3); (~4); 5] 3\n * [(~4); (~3); 5]\n * Example 2:\n * >>> maximum [4; (~4); 4] 2\n * [4; 4]\n * Example 3:\n * >>> maximum [(~3); 2; 1; 2; (~1); (~2); 1] 1\n * [2]\n * Note:\n * 1. The length of the list will be in the range of [1, 1000].\n * 2. The elements in the list will be in the range of [-1000, 1000].\n * 3. 0 <= k <= len(arr)\n*)\nlet maximum (arr : int list) (k : int) : int list =\n  let rec maximum_helper arr k acc =\n    match arr with\n    | [] -> acc\n    | hd :: tl ->\n        if k = 0 then hd :: acc\n        else if k > 0 then maximum_helper tl (k - 1) (hd :: acc)\n        else maximum_helper tl (k - 1) acc\n  in\n  maximum_helper arr k []"], ["(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n * Examples\n * >>> solution [5; 8; 7; 1]\n * 12\n * >>> solution [3; 3; 3; 3; 3]\n * 9\n * >>> solution [30; 13; 24; 321]\n * 0\n*)\nlet solution (lst : int list) : int =\n  let rec sum_of_odd_positions_in_even_positions lst =\n    match lst with\n    | [] -> 0\n    | hd :: tl ->\n        if hd mod 2 = 1 then sum_of_odd_positions_in_even_positions tl else hd + sum_of_odd_positions_in_even_positions tl\n  in\n  sum_of_odd_positions_in_even_positions lst"], ["(**Given a non-empty list of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n * Example:\n * >>> add_elements [111; 21; 3; 4000; 5; 6; 7; 8; 9] 4\n * 24\n * Constraints:\n * 1. 1 <= len(arr) <= 100\n * 2. 1 <= k <= len(arr)\n*)\nlet add_elements (arr : int list) (k : int) : int =\n  let rec sum_digits (arr : int list) (k : int) : int =\n    match arr with\n    | [] -> 0\n    | hd :: tl ->\n        let digits = Array.to_list hd in\n        let rec sum_digits_helper (digits : int list) (k : int) : int =\n          match digits with\n          | [] -> 0\n          | hd :: tl ->\n              let digit = hd in\n              if k <= 0 then digit\n              else if k mod 2 = 0 then digit + sum_digits_helper tl (k div 2)\n              else digit + sum_digits_helper tl (k div 2)\n        in\n        sum_digits_helper tl (k mod 2)\n  in\n  sum_digits arr k"], ["(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n * as follows: start with any positive integer n. Then each term is obtained from the \n * previous term as follows: if the previous term is even, the next term is one half of \n * the previous term. If the previous term is odd, the next term is 3 times the previous\n * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n * Note: \n * 1. Collatz(1) is [1].\n * 2. returned list sorted in increasing order.\n * For example:\n * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n * >>> get_odd_collatz 5\n * [1; 5]\n*)\nlet get_odd_collatz (n : int) : int list =\n  let rec collatz_helper n acc =\n    if n = 1 then [n]\n    else if n mod 2 = 0 then [n / 2]\n    else collatz_helper (n / 2) (n * 3 + 1 :: acc)\n  in collatz_helper n []"], ["(**You have to write a function which validates a given date string and\n * returns true if the date is valid otherwise false.\n * The date is valid if all of the following rules are satisfied:\n * 1. The date string is not empty.\n * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n * 3. The months should not be less than 1 or higher than 12.\n * 4. The date should be in the format: mm-dd-yyyy\n * >>> valid_date \"03-11-2000\"\n * true\n * >>> valid_date \"15-01-2012\"\n * false\n * >>> valid_date \"04-0-2040\"\n * false\n * >>> valid_date \"06-04-2020\"\n * true\n * >>> valid_date \"06/04/2020\"\n * false\n*)\nlet valid_date (date : string) : bool =\n  let rec check_month (month : int) (year : int) : bool =\n    match month with\n    | 1 | 3 | 5 | 7 | 8 | 10 | 12 -> true\n    | _ -> false\n  in\n  let rec check_day (day : int) (year : int) : bool =\n    match day with\n    | 1 | 2 | 4 | 6 | 9 | 11 -> true\n    | _ -> false\n  in\n  let rec check_year (year : int) : bool =\n    match year with\n    | 2000 | 2020 -> true\n    | _ -> false\n  in\n  let rec check_format (format : string) (year : int) (month : int) (day : int) : bool =\n    let rec check_day_of_month"], ["(**Given a list of numbers, return whether or not they are sorted\n * in ascending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n * >>> is_sorted [5]\n * true\n * >>> is_sorted [1; 2; 3; 4; 5]\n * true\n * >>> is_sorted [1; 3; 2; 4; 5]\n * false\n * >>> is_sorted [1; 2; 3; 4; 5; 6]\n * true\n * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]\n * true\n * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]\n * false\n * >>> is_sorted [1; 2; 2; 3; 3; 4]\n * true\n * >>> is_sorted [1; 2; 2; 2; 3; 4]\n * false\n*)\nlet is_sorted (lst : int list) : bool =\n  let rec is_sorted_aux lst =\n    match lst with\n    | [] -> true\n    | hd :: tl ->\n        if hd = lst.(0) then is_sorted_aux tl\n        else false\n  in\n  is_sorted_aux lst"], ["(**You are given two intervals,\n * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n * The given intervals are closed which means that the interval (start, end)\n * includes both start and end.\n * For each given interval, it is assumed that its start is less or equal its end.\n * Your task is to determine whether the length of intersection of these two \n * intervals is a prime number.\n * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n * which its length is 1, which not a prime number.\n * If the length of the intersection is a prime number, return \"YES\",\n * otherwise, return \"NO\".\n * If the two intervals don't intersect, return \"NO\".\n * [input/output] samples:\n * >>> intersection (1, 2) (2, 3)\n * \"NO\"\n * >>> intersection ((~1), 1) (0, 4)\n * \"NO\"\n * >>> intersection ((~3), (~1)) ((~5), 5)\n * \"YES\"\n*)\nlet intersection (interval1 :  int * int) (interval2 :  int * int) : string =\n  let rec intersection_helper (start1 : int) (end1 : int) (start2 : int) (end2 : int) : int * int option =\n    match (start1, start2, end1, end2) with\n    | (_, _, _, _) -> None\n    | (_, _, start2', end2') ->\n        if start1 <= start2' && end1 <= end2' then\n          Some (start1, end1')\n        else if start2 <= start1' && end2 <= end1' then\n          Some (start2, end2')\n        else\n          None\n    | (start1, _, _, _) ->\n        if start1 <= start2 then\n          Some (start1, start2)\n        else\n          None\n    | (_, start2, _, end2') ->\n        if start1 <= start2 && end1 <= end2' then\n          Some (start1, end1)\n        else if start2 <= start1"], ["(**You are given a list arr of integers and you need to return\n * sum of magnitudes of integers multiplied by product of all signs\n * of each number in the list, represented by 1, -1 or 0.\n * Note: return None for empty arr.\n * Example:\n * >>> prod_signs [1; 2; 2; (~4)]\n * Some(9)\n * >>> prod_signs [0; 1]\n * Some(0)\n * >>> prod_signs []\n * Some(None)\n*)\nlet prod_signs (arr : int list) : int option =\n  let rec prod_signs_helper (arr : int list) : int option =\n    match arr with\n    | [] -> None\n    | [x] -> Some (x * 1)\n    | (x :: xs) ->\n        let sign = if x < 0 then -1 else 1 in\n        let product = sign * prod_signs_helper xs in\n        Some (x * product)\n  in\n  prod_signs_helper arr"], ["(**Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n * You have to find the minimum path of length k in the grid. You can start\n * from any cell, and in each step you can move to any of the neighbor cells,\n * in other words, you can go to cells which share an edge with you current\n * cell.\n * Please note that a path of length k means visiting exactly k cells (not\n * necessarily distinct).\n * You CANNOT go off the grid.\n * A path A (of length k) is considered less than a path B (of length k) if\n * after making the ordered lists of the values on the cells that A and B go\n * through (let's call them lst_A and lst_B), lst_A is lexicographically less\n * than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n * lst_A[j] = lst_B[j].\n * It is guaranteed that the answer is unique.\n * Return an ordered list of the values on the cells that the minimum path go through.\n * Examples:    \n * >>> minPath [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 3\n * [1; 2; 1]\n * >>> minPath [[5; 9; 3]; [4; 1; 6]; [7; 8; 2]] 1\n * [1]\n*)\nlet minPath (grid : int list list) (k : int) : int list =\n  let rec helper (grid : int list list) (k : int) : int list =\n    match grid with\n    | [] -> []\n    | (x :: xs) :: rest ->\n      let rec helper_helper (grid : int list list) (k : int) : int list =\n        match grid with\n        | [] -> []"], ["(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n * the last couple centuries. However, what people don't know is Tribonacci sequence.\n * Tribonacci sequence is defined by the recurrence:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, if n is even.\n * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n * For example:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8 \n * You are given a non-negative integer number n, you have to a return a list of the \n * first n + 1 numbers of the Tribonacci sequence.\n * Examples:\n * >>> tri 3\n * [1; 3; 2; 8]\n*)\nlet tri (n : int) : int list =\n  if n < 1 then raise (Invalid_argument \"tri\")\n  else if n = 1 then [1]\n  else if n = 2 then [1; 1]\n  else if n mod 2 = 0 then tri (n - 1)\n  else tri (n - 1) + tri (n - 2) + tri (n + 1)"], ["(**Given a positive integer n, return the product of the odd digits.\n * Return 0 if all digits are even.\n * For example:\n * >>> digits 1\n * 1\n * >>> digits 4\n * 0\n * >>> digits 235\n * 15\n*)\nlet digits (n : int) : int =\n  let rec digits_helper n =\n    if n = 0 then 1\n    else if n mod 10 = 0 then n / 10 * digits_helper (n / 10)\n    else n * digits_helper (n / 10)\n  in digits_helper n"], ["(**Create a function that takes a string as input which contains only square brackets.\n * The function should return true if and only if there is a valid subsequence of brackets \n * where at least one bracket in the subsequence is nested.\n * >>> is_nested \"[[]]\"\n * true\n * >>> is_nested \"[]]]]]]][[[[[]\"\n * false\n * >>> is_nested \"[][]\"\n * false\n * >>> is_nested \"[]\"\n * false\n * >>> is_nested \"[[][]]\"\n * true\n * >>> is_nested \"[[]][[\"\n * true\n*)\nlet is_nested (string : string) : bool =\n  let rec loop (string : string) : bool =\n    match string with\n    | [] -> true\n    | _ :: rest ->\n        match rest with\n        | [] -> false\n        | _ :: rest ->\n            match string with\n            | [] -> false\n            | _ :: rest ->\n                match string with\n                | [] -> false\n                | _ :: rest ->\n                    match string with\n                    | [] -> false\n                    | _ :: rest ->\n                        match string with\n                        | [] -> false\n                        | _ :: rest ->\n                            loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                        loop rest\n                    | _ :: rest ->\n                "], ["(**You are given a list of numbers.\n * You need to return the sum of squared numbers in the given list,\n * round each element in the list to the upper int(Ceiling) first.\n * Examples:\n * >>> lst [1.0; 2.0; 3.0]\n * 14\n * >>> lst [1.0; 4.0; 9.0]\n * 98\n * >>> lst [1.0; 3.0; 5.0; 7.0]\n * 84\n * >>> lst [1.4; 4.2; 0.0]\n * 29\n * >>> lst [-2.4; 1.0; 1.0]\n * 6\n*)\nlet sum_squares (lst : float list) : int =\n  let rec sum_squares_rec lst acc =\n    match lst with\n    | [] -> acc\n    | hd :: tl ->\n        let sum = hd ^ 2.0 in\n        sum_squares_rec tl (sum +. acc)\n  in\n  sum_squares_rec lst 0.0"], ["(**Create a function that returns true if the last character\n * of a given string is an alphabetical character and is not\n * a part of a word, and false otherwise.\n * Note: \"word\" is a group of characters separated by space.\n * Examples:\n * >>> check_if_last_char_is_a_letter \"apple pie\"\n * false\n * >>> check_if_last_char_is_a_letter \"apple pi e\"\n * true\n * >>> check_if_last_char_is_a_letter \"apple pi e \"\n * false\n * >>> check_if_last_char_is_a_letter \"\"\n * false\n*)\nlet check_if_last_char_is_a_letter (txt : string) : bool =\n  let rec check_last_char_is_letter (c : char) : bool =\n    match c with\n    | 'a' .. 'z' -> true\n    | 'A' .. 'Z' -> true\n    | ' ' -> false\n    | _ -> false\n  in\n  let rec check_last_char_is_not_a_letter (c : char) : bool =\n    match c with\n    | 'a' .. 'z' -> true\n    | 'A' .. 'Z' -> true\n    | ' ' -> false\n    | _ -> false\n  in\n  let rec check_last_char_is_not_in_word (c : char) : bool =\n    match c with\n    | ' ' -> false\n    | _ -> true\n  in\n  let rec check_last_char_is_not_in_word_or_space (c : char) : bool =\n    match c with\n    | ' ' -> true\n    | _ -> false\n  in\n  let rec check_last_char_is_not_in_word_or_space_or_letter (c : char) : bool =\n    match c with\n    | ' ' -> true\n    | _ -> false\n  in\n  let rec check_last_char_is_not_in_word_or_space_or_letter_or_space (c : char) : bool =\n    match c with\n    | ' ' -> true\n   "], ["(**Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given list will not contain\n * duplicate values.\n * Examples:\n * >>> can_arrange [1; 2; 4; 3; 5]\n * 3\n * >>> can_arrange [1; 2; 3]\n * (~1)\n*)\nlet can_arrange (arr : int list) : int =\n  let rec find_largest_index (arr : int list) : int option =\n    match arr with\n    | [] -> None\n    | hd :: tl ->\n        let largest_index =\n          if hd > arr |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |> List.hd |"], ["(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n * Example\n * >>> is_equal_to_sum_even 4\n * false\n * >>> is_equal_to_sum_even 6\n * false\n * >>> is_equal_to_sum_even 8\n * true\n*)\nlet is_equal_to_sum_even (n : int) : bool =\n  let rec sum_even_rec n =\n    match n with\n    | 0 -> true\n    | _ -> n mod 2 = 0 && sum_even_rec (n / 2)\n  in\n  sum_even_rec n"], ["(**The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n * where n > 0\n * For example:\n * >>> special_factorial 4\n * 288\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n*)\nlet special_factorial (n : int) : int =\n  let rec helper n acc =\n    if n = 0 then acc\n    else helper (n - 1) (n * acc)\n  in\n  helper n 1"], ["(**Given a string text, replace all spaces in it with underscores, \n * and if a string has more than 2 consecutive spaces, \n * then replace all consecutive spaces with - \n * >>> fix_spaces \" Example\"\n * \"Example\"\n * >>> fix_spaces \" Example 1\"\n * \"Example_1\"\n * >>> fix_spaces \" Example 2\"\n * \"_Example_2\"\n * >>> fix_spaces \" Example 3\"\n * \"_Example-3\"\n*)\nlet fix_spaces (text : string) : string =\n  let rec fix_spaces_aux (text : string) : string =\n    match text with\n    | \"\" -> \"\"\n    | \" \" -> \"_\"\n    | \" \" * n -> \"_\" ^ (String.init n (fun _ -> \" \"))\n    | s -> s\n  in\n  fix_spaces_aux text\n;;"], ["(**Create a function which takes a string representing a file's name, and returns\n * 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n * A file's name is considered to be valid if and only if all the following conditions \n * are met:\n * - There should not be more than three digits ('0'-'9') in the file's name.\n * - The file's name contains exactly one dot '.'\n * - The substring before the dot should not be empty, and it starts with a letter from \n * the latin alphapet ('a'-'z' and 'A'-'Z').\n * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n * Examples:\n * >>> file_name_check \"example.txt\"\n * \"Yes\"\n * >>> file_name_check \"1example.dll\"\n * \"No\"\n*)\nlet file_name_check (file_name : string) : string =\n  let is_valid_name = function\n    | \"\" -> true\n    | _ ->\n        let is_valid_digit = function\n          | '0'..'9' -> true\n          | _ -> false\n        in\n        let is_valid_dot = function\n          | '.' -> true\n          | _ -> false\n        in\n        let is_valid_substring = function\n          | \"\" -> true\n          | _ ->\n              let is_valid_letter = function\n                | 'a'..'z' -> true\n                | 'A'..'Z' -> true\n                | _ -> false\n              in\n              let is_valid_digit = function\n                | '0'..'9' -> true\n                | _ -> false\n              in\n              let is_valid_substring = function\n                | \"\" -> true\n                | _ ->\n                    let is_valid_letter = function\n                      | 'a'..'z' -> true\n                      | 'A'..'Z' -> true\n                      | _ -> false\n                    in\n                    let is_valid_digit = function\n                      | '0'..'9' -> true\n                      | _ -> false\n                    in\n                    is_"], ["(**\"\n * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n * Examples:\n * >>> lst\n * [1; 2; 3]\n * >>> lst\n * []\n * >>> lst\n * [(~1); (~5); 2; (~1); (~5)]\n*)\nlet sum_squares (lst : int list) : int =\n  let rec square_index (lst : int list) : int list =\n    match lst with\n    | [] -> []\n    | hd :: tl -> if hd mod 3 = 0 && hd mod 4 <> 0 then [hd] else [hd; (~hd)] :: square_index tl\n  in\n  let rec cube_index (lst : int list) : int list =\n    match lst with\n    | [] -> []\n    | hd :: tl -> if hd mod 3 = 0 && hd mod 4 <> 0 then [hd] else [hd; (~hd)] :: cube_index tl\n  in\n  let rec sum_squares_rec (lst : int list) : int =\n    match lst with\n    | [] -> 0\n    | hd :: tl -> (hd * hd) + (sum_squares_rec tl)\n  in\n  sum_squares_rec lst"], ["(**You are given a string representing a sentence,\n * the sentence contains some words separated by a space,\n * and you have to return a string that contains the words from the original sentence,\n * whose lengths are prime numbers,\n * the order of the words in the new string should be the same as the original one.\n * Example 1:\n * >>> words_in_sentence \"This is a test\"\n * \"is\"\n * Example 2:\n * >>> words_in_sentence \"lets go for swimming\"\n * \"go for\"\n * Constraints:\n * * 1 <= len(sentence) <= 100\n * * sentence contains only letters\n*)\nlet words_in_sentence (sentence : string) : string =\n  let rec find_words (words : string list) (index : int) : string list =\n    match words with\n    | [] -> []\n    | word :: rest ->\n        if index >= sentence.Length then\n          rest\n        else if word.Length = index then\n          word :: find_words rest (index + 1)\n        else\n          word :: find_words rest (index + 1)\n  in\n  find_words [] 0"], ["(**Your task is to implement a function that will simplify the expression\n * x * n. The function returns true if x * n evaluates to a whole number and false\n * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n * >>> simplify \"1/5\" \"5/1\"\n * true\n * >>> simplify \"1/6\" \"2/1\"\n * false\n * >>> simplify \"7/10\" \"10/2\"\n * false\n*)\nlet simplify (x : string) (n : string) : bool =\n  let rec simplify_rec (x : string) (n : string) : bool =\n    match x, n with\n    | \"1\", \"1\" -> true\n    | \"0\", \"1\" -> true\n    | \"1\", \"0\" -> true\n    | \"0\", \"0\" -> true\n    | \"1/2\", \"1/2\" -> true\n    | \"1/3\", \"1/3\" -> true\n    | \"1/4\", \"1/4\" -> true\n    | \"1/5\", \"1/5\" -> true\n    | \"1/6\", \"1/6\" -> true\n    | \"1/7\", \"1/7\" -> true\n    | \"1/8\", \"1/8\" -> true\n    | \"1/9\", \"1/9\" -> true\n    | \"1/10\", \"1/10\" -> true\n    | \"1/11\", \"1/11\" -> true\n    | \"1/12\", \"1/12\" -> true\n    | \"1/13\", \"1/13\" -> true\n    | \"1/14\", \"1/14\" -> true\n    | \"1/15\", \"1/15\" -> true\n    | \"1/16\", \"1/16\" -> true\n    | \"1/17\", \"1/17\" -> true\n    | \"1/18\","], ["(**Write a function which sorts the given list of integers\n * in ascending order according to the sum of their digits.\n * Note: if there are several items with similar sum of their digits,\n * order them based on their index in original list.\n * For example:\n * >>> order_by_points [1; 11; (~1); (~11); (~12)]\n * [(~1); (~11); 1; (~12); 11]\n * >>> order_by_points []\n * []\n*)\nlet order_by_points (nums : int list) : int list =\n  let rec sort_by_sum (nums : int list) : int list =\n    match nums with\n    | [] -> []\n    | hd :: tl ->\n        let sum = List.fold_left (fun acc x -> acc + x) 0 hd in\n        if sum = List.fold_left (fun acc x -> acc + x) 0 tl\n        then hd :: sort_by_sum tl\n        else sort_by_sum tl\n  in\n  sort_by_sum nums\n;;"], ["(**Write a function that takes a list of numbers as input and returns \n * the number of elements in the list that are greater than 10 and both \n * first and last digits of a number are odd (1, 3, 5, 7, 9).\n * For example:\n * >>> specialFilter [15; (~73); 14; (~15)]\n * 1\n * >>> specialFilter [33; (~2); (~3); 45; 21; 109]\n * 2\n*)\nlet specialFilter (nums : int list) : int =\n  let rec aux n acc =\n    match n with\n    | [] -> acc\n    | hd :: tl ->\n        if hd > 10 && hd mod 2 = 1 && hd / 2 mod 2 = 1 then acc + 1\n        else aux tl (acc + 1)\n  in aux [] 0"], ["(**You are given a positive integer n. You have to create an integer list a of length n.\n * For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n * Example :\n * >>> get_max_triples 5\n * 1\n * Explanation: \n * a = [1, 3, 7, 13, 21]\n * The only valid triple is (1, 7, 13).\n*)\nlet get_max_triples (n : int) : int =\n  let rec get_max_triples_helper n acc =\n    if n = 0 then acc\n    else if n mod 3 = 0 then acc + n\n    else get_max_triples_helper (n - 1) (n * n)\n  in\n  get_max_triples_helper n 0"], ["(**Write a function that accepts a list of strings as a parameter,\n * deletes the strings that have odd lengths from it,\n * and returns the resulted list with a sorted order,\n * The list is always a list of strings and never a list of numbers,\n * and it may contain duplicates.\n * The order of the list should be ascending by length of each word, and you\n * should return the list sorted by that rule.\n * If two words have the same length, sort the list alphabetically.\n * The function should return a list of strings in sorted order.\n * You may assume that all words will have the same length.\n * For example:\n * >>> list_sort [\"aa\"; \"a\"; \"aaa\"]\n * [\"aa\"]\n * >>> list_sort [\"ab\"; \"a\"; \"aaa\"; \"cd\"]\n * [\"ab\"; \"cd\"]\n*)\nlet sorted_list_sum (lst : string list) : string list =\n  let rec sort_lst lst =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let len = String.length hd in\n        let sorted_lst = List.sort (fun x y -> String.length x - String.length y) tl in\n        sorted_lst @ [hd]\n  in\n  sort_lst lst"], ["(**A simple program which should return the value of x if n is \n * a prime number and should return the value of y otherwise.\n * Examples:\n * >>> x_or_y 7 34 12\n * 34\n * >>> x_or_y 15 8 5\n * 5\n*)\nlet x_or_y (n : int) (x : int) (y : int) : int =\n  if n = 2 then x\n  else if n mod 2 = 0 then y\n  else x"], ["(**Given a list of numbers, return the sum of squares of the numbers\n * in the list that are odd. Ignore numbers that are negative or not integers.\n * >>> double_the_difference [1; 3; 2; 0]\n * 10\n * >>> double_the_difference [(~1); (~2); 0]\n * 0\n * >>> double_the_difference [9; (~2)]\n * 81\n * >>> double_the_difference [0]\n * 0\n * If the input list is empty, return 0.\n*)\nlet double_the_difference (lst : float list) : int =\n  let rec double_sum lst =\n    match lst with\n    | [] -> 0\n    | hd :: tl -> hd + double_sum tl\n  in\n  double_sum lst"], ["(**I think we all remember that feeling when the result of some long-awaited\n * event is finally known. The feelings and thoughts you have at that moment are\n * definitely worth noting down and comparing.\n * Your task is to determine if a person correctly guessed the results of a number of matches.\n * You are given two lists of scores and guesses of equal length, where each index shows a match. \n * Return a list of the same length denoting how far off each guess was. If they have guessed correctly,\n * the value is 0, and if not, the value is the absolute difference between the guess and the score.\n * example:\n * >>> compare [1; 2; 3; 4; 5; 1] [1; 2; 3; 4; 2; (~2)]\n * [0; 0; 0; 0; 3; 3]\n * >>> compare [0; 5; 0; 0; 0; 4] [4; 1; 1; 0; 0; (~2)]\n * [4; 4; 1; 0; 0; 6]\n*)\nlet compare (game : int list) (guess : int list) : int list =\n  let rec compare_list (lst1 : int list) (lst2 : int list) : int list =\n    match lst1, lst2 with\n    | [], [] -> []\n    | [], _ -> [0]\n    | _, [] -> [0]\n    | (x1 :: xs1), (y1 :: ys1) ->\n      let x2 = if x1 = y1 then 0 else abs (x1 - y1) in\n      let y2 = if y1 = x1 then 0 else abs (y1 - x1) in\n      if x2 = y2 then x2 :: compare_list xs1 ys1\n      else if x2 > y2 then x2 :: compare_list xs1 ys1\n      else y2 :: compare_list xs1 ys1\n    | _ -> failwith \"Invalid input\"\n  in\n  compare_list game guess"], ["(**You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class. The\n * strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters \n * in the extension's name, the strength is given by the fraction CAP - SM. \n * You should find the strongest extension and return a string in this \n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n * (its strength is -1).\n * Example:\n * >>> Strongest_Extension \"my_class\" [\"AA\"; \"Be\"; \"CC\"]\n * \"my_class.AA\"\n*)\nlet Strongest_Extension (class_name : string) (extensions : string list) : string =\n  let rec find_strongest_extension (class_name : string) (extensions : string list) : string option =\n    match extensions with\n    | [] -> None\n    | _ ->\n        let extension_name = String.concat \".\" (List.map (fun extension -> String.sub extension 0 (String.length extension - 1)) extensions) in\n        let strength = String.length class_name - String.length extension_name in\n        if strength > 0 then Some (class_name ^ \".\" ^ extension_name)\n        else None\n  in\n  find_strongest_extension class_name extensions"], ["(**You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n * >>> cycpattern_check \"abcd\" \"abd\"\n * false\n * >>> cycpattern_check \"hello\" \"ell\"\n * true\n * >>> cycpattern_check \"whassup\" \"psus\"\n * false\n * >>> cycpattern_check \"abab\" \"baa\"\n * true\n * >>> cycpattern_check \"efef\" \"eeff\"\n * false\n * >>> cycpattern_check \"himenss\" \"simen\"\n * true\n*)\nlet cycpattern_check (a : string) (b : string) : bool =\n  let rec check_sub (a : string) (b : string) : bool =\n    match a, b with\n    | \"\", \"\" -> true\n    | a, \"\" -> false\n    | a, b -> a = b || check_sub a (b)\n  in\n  check_sub a b\n;;"], ["(**Given an integer. return a tuple that has the number of even and odd digits respectively.\n * Example:\n * >>> even_odd_count (~12)\n * (1, 1)\n * >>> even_odd_count 123\n * (1, 2)\n*)\nlet even_odd_count (num : int) :  int * int =\n  let rec even_odd_count_helper (num : int) : int * int =\n    match num with\n    | 0 -> (0, 0)\n    | _ ->\n      let even_digit = num mod 10 in\n      let odd_digit = num mod 10 in\n      let even_count = even_odd_count_helper even_digit in\n      let odd_count = even_odd_count_helper odd_digit in\n      even_count, odd_count\n  in\n  even_odd_count_helper num"], ["(**Given a positive integer, obtain its roman numeral equivalent as a string,\n * and return it in lowercase.\n * Restrictions: 1 <= num <= 1000\n * Examples:\n * >>> int_to_mini_roman 19\n * \"xix\"\n * >>> int_to_mini_roman 152\n * \"clii\"\n * >>> int_to_mini_roman 426\n * \"cdxxvi\"\n*)\nlet int_to_mini_roman (number : int) : string =\n  let rec loop (acc : string) (rem : int) : string =\n    match rem with\n    | 0 -> acc\n    | n ->\n        let digit = n / 10 in\n        let rem_digit = rem mod 10 in\n        let digit_str = match digit with\n          | 0 -> \"I\"\n          | 1 -> \"V\"\n          | 2 -> \"X\"\n          | 3 -> \"L\"\n          | 4 -> \"C\"\n          | 5 -> \"D\"\n          | 6 -> \"M\"\n          | _ -> \"M\"\n        in\n        loop (digit_str ^ acc) rem_digit\n  in\n  loop \"I\" number"], ["(**Given the lengths of the three sides of a triangle. Return true if the three\n * sides form a right-angled triangle, false otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or \n * 90 degree.\n * Example:\n * >>> right_angle_triangle 3 4 5\n * true\n * >>> right_angle_triangle 1 2 3\n * false\n*)\nlet right_angle_triangle (a : int) (b : int) (c : int) : bool =\n  let rec is_right_angle (a : int) (b : int) (c : int) : bool =\n    match (a, b, c) with\n    | (a, _, _) when a = b -> true\n    | (_, a, _) when a = c -> true\n    | (_, _, c) when c = b -> true\n    | _ -> false\n  in\n  is_right_angle a b c\n;;"], ["(**Write a function that accepts a list of strings.\n * The list contains different words. Return the word with maximum number\n * of unique characters. If multiple strings have maximum number of unique\n * characters, return the one which comes first in lexicographical order.\n * >>> find_max [\"name\"; \"of\"; \"string\"]\n * \"string\"\n * >>> find_max [\"name\"; \"enam\"; \"game\"]\n * \"enam\"\n * >>> find_max [\"aaaaaaa\"; \"bb\"; \"cc\"]\n * \"aaaaaaa\"\n*)\nlet find_max (words : string list) : string =\n  let rec find_max_aux (words : string list) : string option =\n    match words with\n    | [] -> None\n    | hd :: tl ->\n        let max_len = String.length hd in\n        let max_char = String.find_first_index (fun c -> Char.is_letter c) hd in\n        let max_char_len = max_len - max_char in\n        let max_char_count = String.count_by (fun c -> Char.is_letter c) hd in\n        let max_char_count_len = max_char_len - max_char_count in\n        if max_char_count_len > max_char_len then\n          Some (hd, max_char, max_char_count, max_char_count_len)\n        else\n          find_max_aux tl\n  in\n  find_max_aux words"], ["(**You're a hungry rabbit, and you already have eaten a certain number of carrots,\n * but now you need to eat more carrots to complete the day's meals.\n * you should return a list of [ total number of eaten carrots after your meals,\n * the number of carrots left after your meals ]\n * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n * Example:\n * >>> eat 5 6 10\n * [11; 4]\n * >>> eat 4 8 9\n * [12; 1]\n * >>> eat 1 10 10\n * [11; 0]\n * >>> eat 2 11 5\n * [7; 0]\n * Variables:\n * @number : integer\n * the number of carrots that you have eaten.\n * @need : integer\n * the number of carrots that you need to eat.\n * @remaining : integer\n * the number of remaining carrots thet exist in stock\n * Constrain:\n * * 0 <= number <= 1000\n * * 0 <= need <= 1000\n * * 0 <= remaining <= 1000\n * Have fun :)\n*)\nlet eat (number : int) (need : int) (remaining : int) : int list =\n  if need > remaining then\n    [ 0; 0 ]\n  else if need = remaining then\n    [ number; 0 ]\n  else\n    let total_needed = need - remaining\n    let total_left = remaining - total_needed\n    let eaten_carrots = total_needed + 1\n    let left_carrots = total_left - eaten_carrots\n    let remaining_carrots = remaining - left_carrots\n    let eaten_carrots_after_meals = eaten_carrots + remaining_carrots\n    let left_carrots_after_meals = left_carrots + remaining_carrots\n    let hungry = eaten_carrots_after_"], ["(**Given two lists operator, and operand. The first list has basic algebra operations, and \n * the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n * Example:\n * operator['+', '*', '-']\n * list = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n*)\nlet do_algebra (operator : string list) (operand : int list) : int =\n    let rec eval_op (op : string) (a : int) (b : int) : int =\n        match op with\n        | \"+\" -> a + b\n        | \"-\" -> a - b\n        | \"*\" -> a * b\n        | \"/\" -> if b = 0 then raise Not_found else a / b\n        | \"**\" -> if b = 0 then raise Not_found else a ** b\n        | _ -> raise Not_found\n    in\n    let rec eval_list (op : string) (a : int list) (b : int list) : int list =\n        match op with\n        | \"+\" -> a :: (eval_list op b (a @ []) : int list)\n        | \"-\" -> a :: (eval_list op (a @ []) b : int list)\n        | \"*\" -> a :: (eval_list op (a @ []) (eval_list op b [] : int list))\n        | \"/\" -> if a = 0 then raise Not_found else a :: (eval_list op (a @ []) [] : int list)\n        | \"**\" -> if a = 0 then raise Not_found"], ["(**You are given a string s.\n * if s[i] is a letter, reverse its case from lower to upper or vise versa, \n * otherwise keep it as it is.\n * If the string contains no letters, reverse the string.\n * The function should return the resulted string.\n * Examples\n * >>> solve \"1234\"\n * \"4321\"\n * >>> solve \"ab\"\n * \"AB\"\n * >>> solve \"#a@C\"\n * \"#A@c\"\n*)\nlet solve (s : string) : string =\n  let rec reverse_lower_upper s =\n    match s with\n    | [] -> \"\"\n    | h::t ->\n        let c = char_of_string h in\n        let c' = char_of_string t in\n        if c = c' then reverse_lower_upper t else if c < c' then reverse_lower_upper s else reverse_lower_upper t\n  in\n  reverse_lower_upper s"], ["(**Given a string 'text', return its md5 hash equivalent string.\n * If 'text' is an empty string, return None.\n * >>> string_to_md5 \"Hello world\"\n * Some(\"3e25960a79dbc69b674cd4ec67a72c62\")\n*)\nlet string_to_md5 (text : string) : string option =\n  let md5 = MD5.create () in\n  let hash = MD5.digest_string text in\n  let hex_digits = \"0123456789abcdef\" in\n  let hex_string = String.concat \"\" (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2) (List.map (fun x -> String.sub x 2 2) (List.map (fun x -> String.sub x 0 2"], ["(**Given two positive integers a and b, return the even digits between a\n * and b, in ascending order.\n * For example:\n * >>> generate_integers 2 8\n * [2; 4; 6; 8]\n * >>> generate_integers 8 2\n * [2; 4; 6; 8]\n * >>> generate_integers 10 14\n * []\n*)\nlet generate_integers (a : int) (b : int) : int list =\n  let rec generate_range a b =\n    match a, b with\n    | a, b when a > b -> []\n    | a, b -> a :: generate_range a (b - 1)\n  in\n  generate_range a b"]]