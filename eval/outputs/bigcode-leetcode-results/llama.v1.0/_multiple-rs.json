[["/// Check if in given vector of numbers, are any two numbers closer to each other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    numbers.iter().map(|num| num - threshold).all(|num| *num <= 0.0)"], ["/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut open_braces = 0;\n    let mut open_parens = 0;\n    let mut closed_braces = 0;\n    let mut closed_parens = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n            open_braces += 1;\n        } else if c == ')' {\n            open_braces -= 1;\n            if open_braces == 0 {\n                closed_parens += 1;\n            }\n        } else if c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n            open_parens -= 1;\n            if open_parens == 0 {\n                closed_braces += 1;\n            }\n        } else if c == ' ' {\n            // Ignore spaces\n        } else {\n            groups.push(String::from(paren_string.chars().nth(open_braces).unwrap().to_string()));\n            open_braces = 0;\n            open_parens = 0;\n            closed_braces = 0;\n            closed_parens = 0;\n        }\n    }\n    groups"], ["/// Given a positive floating point number, it can be decomposed into\n/// and integer part (largest integer smaller than given number) and decimals\n/// (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part = 0.0;\n    let mut leftover = 1.0;\n    while leftover > 0.0 {\n        let remainder = number.checked_sub(leftover).unwrap();\n        decimal_part += remainder;\n        leftover = remainder.rem_euclid(number);\n    }\n    decimal_part"], ["/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n        balance += op;\n    }\n    balance < 0"], ["/// For a given vector of input numbers, calculate Mean Absolute Deviation\n/// around the mean of this dataset.\n/// Mean Absolute Deviation is the average absolute difference between each\n/// element and a centerpoint (mean in this case):\n/// MAD = average | x - x_mean |\n/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n/// 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    numbers.iter().map(|x| x.abs()).sum::<f64>() / numbers.len() as f64"], ["/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// Vec::<isize>::new()\n/// >>> intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.iter().map(|x| *x).take(delimeter).chain(numbers.iter().skip(delimeter)).collect()"], ["/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    let mut parens = Vec::new();\n    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c {\n            '(' => depth += 1,\n            ')' => depth -= 1,\n            _ => {}\n        }\n        parens.push(depth);\n    }\n    parens"], ["/// Filter an input vector of strings only for ones that contain given substring\n/// >>> filter_by_substring(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.iter().filter(|s| s.contains(&substring)).collect()"], ["/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n/// Empty sum should be equal to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n/// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)"], ["/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut max_so_far = 0;\n    let mut max_so_far_index = 0;\n    for I in 0..numbers.len() {\n        let num = numbers[i];\n        if max_so_far < num {\n            max_so_far = num;\n            max_so_far_index = i;\n        }\n    }\n    let mut result = Vec::new();\n    result.push(max_so_far);\n    for I in 1..max_so_far_index {\n        let num = numbers[i];\n        if max_so_far < num {\n            max_so_far = num;\n            result.push(max_so_far);\n        }\n    }\n    result"], ["/// Find the shortest palindrome that begins with a supplied string.\n/// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that is a palindrome.\n/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n/// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n/// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n    let mut longest_prefix = String::from(\"\");\n    let mut longest_postfix = String::from(\"\");\n    let mut postfix_len = 0;\n    let mut prefix_len = 0;\n    for char in string.chars() {\n        if char.is_alphabetic() {\n            if char.is_ascii_uppercase() {\n                postfix_len += 1;\n            } else {\n                postfix_len += 2;\n            }\n        } else {\n            if char.is_ascii_lowercase() {\n                prefix_len += 1;\n            } else {\n                prefix_len += 2;\n            }\n        }\n    }\n    let mut postfix = String::from(\"\");\n    let mut prefix = String::from(\"\");\n    for I in 0..postfix_len {\n        postfix.push(string[i..i + 1].chars().next().unwrap().to_ascii_lowercase());\n    }\n    for I in 0..prefix_len {\n        prefix.push(string[i..i + 1].chars().next().unwrap().to_ascii_lowercase());\n    }\n    if postfix.len() > prefix.len() {\n        postfix = postfix[..postfix.len() - prefix.len()].to_string();\n    } else {\n        prefix = prefix[..prefix.len() - postfix.len()].to_string();\n    }\n    if postfix.len() > prefix"], ["/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n    let mut result = String::new();\n    for I in 0..a.len() {\n        for j in 0..b.len() {\n            if a[i] == b[j] {\n                result.push(b[j] ^ a[i]);\n            }\n        }\n    }\n    result"], ["/// Out of vector of strings, return the longest one. Return the first one in case of multiple\n/// strings of the same length. Return None in case the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n    let mut longest_length = 0;\n    let mut longest_string = String::new();\n    for string in strings {\n        if string.len() > longest_length {\n            longest_length = string.len();\n            longest_string = string;\n        }\n    }\n    Some(longest_string)"], ["/// Return a greatest common divisor of two integers a and b\n/// >>> greatest_common_divisor(3, 5)\n/// 1\n/// >>> greatest_common_divisor(25, 15)\n/// 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n    if a == 0 || b == 0 {\n        return 0;\n    }\n    let mut gcd = a;\n    let mut remainder = b;\n    while remainder != 0 {\n        gcd = gcd / b;\n        remainder = remainder % b;\n    }\n    gcd"], ["/// Return vector of all prefixes from shortest to longest of the input string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes = vec![];\n    let mut current_prefix = String::from(\"\");\n    for I in 0..string.len() {\n        let prefix = &string[i..];\n        if prefix.len() > current_prefix.len() {\n            current_prefix = prefix.to_string();\n        }\n        prefixes.push(current_prefix);\n    }\n    prefixes"], ["/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n/// >>> string_sequence(0)\n/// String::from(\"0\")\n/// >>> string_sequence(5)\n/// String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n    let mut sequence = String::new();\n    for I in 0..n {\n        sequence.push_str(&format!(\"{} \", i));\n    }\n    sequence"], ["/// Given a string, find out how many distinct characters (regardless of case) does it consist of\n/// >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n/// 3\n/// >>> count_distinct_characters(String::from(\"Jerry\"))\n/// 4\nfn count_distinct_characters(string: String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n        if c.to_ascii_lowercase() == c.to_ascii_uppercase() {\n            count += 1;\n        }\n    }\n    count"], ["/// Input to this function is a string representing musical notes in a special ASCII format.\n/// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n/// not last.\n/// Here is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note, lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    let mut current_note = String::new();\n    for c in music_string.chars() {\n        match c {\n            'o' => {\n                notes.push(1);\n                current_note.clear();\n            }\n            'o|' => {\n                notes.push(2);\n                current_note.clear();\n            }\n            '.' => {\n                if current_note.is_empty() {\n                    notes.push(4);\n                } else {\n                    notes.push(current_note.len() as isize);\n                }\n                current_note.clear();\n            }\n            '|' => {\n                notes.push(2);\n                current_note.clear();\n            }\n            _ => {\n                current_note.push(c as isize);\n            }\n        }\n    }\n    notes"], ["/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let mut count = 0;\n    for (i, c) in string.chars().enumerate() {\n        if substring.chars().nth(i).unwrap() == c {\n            count += 1;\n        }\n    }\n    count"], ["/// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n/// Return the string with numbers sorted from smallest to largest\n/// >>> sort_numbers(String::from(\"three one five\"))\n/// String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n    numbers.chars().map(|c| match c {\n        '0'..='9' => c as char,\n        _ => ' '\n    }).collect()"], ["/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut min_index = 0;\n    for (index, value) in numbers.iter().enumerate() {\n        let distance = value - min_distance;\n        if distance < min_distance {\n            min_distance = distance;\n            min_index = index;\n        }\n    }\n    (min_distance, min_index)"], ["/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let mut rescaled_numbers = numbers.clone();\n    let mut min_num = numbers[0];\n    let mut max_num = numbers[0];\n    for num in numbers {\n        if num < min_num {\n            min_num = num;\n        }\n        if num > max_num {\n            max_num = num;\n        }\n    }\n    rescaled_numbers.sort_by_key(|num| num);\n    rescaled_numbers.iter().map(|num| *num / (max_num - min_num)).collect()"], ["/// Return length of given string\n/// >>> strlen(String::from(\"\"))\n/// 0\n/// >>> strlen(String::from(\"abc\"))\n/// 3\nfn strlen(string: String) -> isize {\n    string.chars().count() as isize"], ["/// For a given number n, find the largest number that divides n evenly, smaller than n\n/// >>> largest_divisor(15)\n/// 5\nfn largest_divisor(n: isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut divisor = 1;\n    let mut remainder = n;\n    while remainder > 0 {\n        divisor *= 10;\n        remainder /= 10;\n    }\n    divisor"], ["/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![1; n as usize];\n    let mut count = 1;\n    while count * count <= n {\n        factors[count] = count;\n        count += 1;\n    }\n    factors"], ["/// From a vector of integers, remove all elements that occur more than once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n/// vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    numbers.into_iter().unique().collect()"], ["/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n/// >>> flip_case(String::from(\"Hello\"))\n/// String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n    let mut reversed_string = string.chars().rev().collect::<String>();\n    reversed_string.swap_reverse(0, reversed_string.len() - 1);\n    reversed_string"], ["/// Concatenate vector of strings into a single string\n/// >>> concatenate(vec![])\n/// String::from(\"\")\n/// >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n    strings.join(\" \")"], ["/// Filter an input vector of strings only for ones that start with a given prefix.\n/// >>> filter_by_prefix(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.iter().filter(|s| s.starts_with(prefix)).collect()"], ["/// Return only positive numbers in the vector.\n/// >>> get_positive(vec![-1, 2, -4, 5, 6])\n/// vec![2, 5, 6]\n/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.iter().filter(|&x| *x > 0).cloned().collect()"], ["/// Return true if a given number is prime, and false otherwise.\n/// >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n/// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n/// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    for I in 2..=n / 2 {\n        if n % I == 0 {\n            return false;\n        }\n    }\n    true"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n/// to the values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n/// vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n    let mut i = 0;\n    while I < l.len() && l[i] % 3 == 0 {\n        l.swap(i, i + 1);\n        i += 2;\n    }\n    l.sort_by(|a, b| a.cmp(b));\n    l"], ["/// Return sorted unique elements in a vector\n/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n    l.iter().cloned().collect()"], ["/// Return maximum element in the vector.\n/// >>> max_element(vec![1, 2, 3])\n/// 3\n/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// 123\nfn max_element(l: Vec<isize>) -> isize {\n    let mut max = l[0];\n    for I in 1..l.len() {\n        if l[i] > max {\n            max = l[i];\n        }\n    }\n    max"], ["/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n/// >>> fizz_buzz(50)\n/// 0\n/// >>> fizz_buzz(78)\n/// 2\n/// >>> fizz_buzz(79)\n/// 3\nfn fizz_buzz(n: isize) -> isize {\n    if n % 11 == 0 || n % 13 == 0 {\n        return 0;\n    }\n    if n % 3 == 0 {\n        return 1;\n    }\n    if n % 5 == 0 {\n        return 2;\n    }\n    return 3;"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>> sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3, 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_copy = l.clone();\n    l_copy.sort_by(|a, b| a.cmp(b));\n    l_copy"], ["/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n/// >>> prime_fib(1)\n/// 2\n/// >>> prime_fib(2)\n/// 3\n/// >>> prime_fib(3)\n/// 5\n/// >>> prime_fib(4)\n/// 13\n/// >>> prime_fib(5)\n/// 89\nfn prime_fib(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut fibonacci = 0;\n    let mut next_fibonacci = 1;\n    let mut is_prime = true;\n    for I in 2..n {\n        if fibonacci == 0 || fibonacci == 1 {\n            is_prime = false;\n            break;\n        }\n        fibonacci = next_fibonacci;\n        next_fibonacci = (next_fibonacci * i) % n;\n    }\n    if is_prime {\n        return fibonacci;\n    } else {\n        return next_fibonacci;\n    }"], ["/// triples_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are three distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n/// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let mut sum = 0;\n    for I in 0..l.len() {\n        sum += l[i];\n        if sum == 0 {\n            return true;\n        }\n    }\n    false"], ["/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n    let mut collisions = 0;\n    for I in 0..n {\n        for j in 0..n {\n            if I != j {\n                if cars_collide(i, j) {\n                    collisions += 1;\n                }\n            }\n        }\n    }\n    collisions"], ["/// Return vector with elements incremented by 1.\n/// >>> incr_list(vec![1, 2, 3])\n/// vec![2, 3, 4]\n/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = l.clone();\n    new_l.push(1);\n    new_l"], ["/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut pairs = Vec::new();\n    for num in l {\n        sum += num;\n        if sum == 0 {\n            pairs.push(num);\n        }\n    }\n    pairs.len() == 2 && pairs.iter().all(|&x| x == 0)"], ["/// Change numerical base of input number x to base.\n/// return string representation after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n/// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n    let mut num = x;\n    while num > 0 {\n        let mut remainder = num % base;\n        result.push_str(&format!(\"{:0>2}\", remainder).as_str());\n        num /= base;\n    }\n    result"], ["/// Given length of a side and high return area for a triangle.\n/// >>> triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n    let side = a as f64;\n    let h_over_2 = h / 2.0;\n    let area = side * h_over_2;\n    area"], ["/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fib4(0) -> 0\n/// fib4(1) -> 0\n/// fib4(2) -> 2\n/// fib4(3) -> 0\n/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n/// >>> fib4(5)\n/// 4\n/// >>> fib4(6)\n/// 8\n/// >>> fib4(7)\n/// 14\nfn fib4(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut fib = 0;\n    fib += fib4(n - 1);\n    fib += fib4(n - 2);\n    fib += fib4(n - 3);\n    fib += fib4(n - 4);\n    fib"], ["/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1, 2, 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l: Vec<isize>) -> f64 {\n    let len = l.len();\n    if len % 2 == 0 {\n        let mid = len / 2;\n        let left = l.get(0..mid).cloned().collect();\n        let right = l.get(mid..).cloned().collect();\n        (left + right) / 2.0\n    } else {\n        let left = l.get(0..len / 2).cloned().collect();\n        let right = l.get(len / 2..len).cloned().collect();\n        (left + right) / 2.0\n    }"], ["/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>> is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>() == text"], ["/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n    let mut result = 1;\n    let mut remainder = 0;\n    while n > 0 {\n        let quotient = n % p;\n        result *= p;\n        remainder = quotient;\n        n /= p;\n    }\n    remainder"], ["/// remove_vowels is a function that takes string and returns string without vowels.\n/// >>> remove_vowels(String::from(\"\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"abcdef\"))\n/// String::from(\"bcdf\")\n/// >>> remove_vowels(String::from(\"aaaaa\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"aaBAA\"))\n/// String::from(\"B\")\n/// >>> remove_vowels(String::from(\"zbcd\"))\n/// String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n    let mut vowels = String::new();\n    for c in text.chars() {\n        if c.is_ascii_uppercase() || c.is_ascii_lowercase() {\n            vowels.push(c);\n        }\n    }\n    vowels.to_string()"], ["/// Return true if all numbers in the vector l are below threshold t.\n/// >>> below_threshold(vec![1, 2, 4, 10], 100)\n/// true\n/// >>> below_threshold(vec![1, 20, 4, 10], 5)\n/// false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)"], ["/// Add two numbers x and y\n/// >>> add(2, 3)\n/// 5\n/// >>> add(5, 7)\n/// 12\nfn add(x: isize, y: isize) -> isize {\n    x + y"], ["/// Check if two words have the same characters.\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n/// true\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n/// true\n/// >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n/// true\n/// >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n/// false\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n/// false\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n/// false\nfn same_chars(s0: String, s1: String) -> bool {\n    s0.chars().all(|c| s1.chars().any(|c2| c == c2))"], ["/// Return n-th Fibonacci number.\n/// >>> fib(10)\n/// 55\n/// >>> fib(1)\n/// 1\n/// >>> fib(8)\n/// 21\nfn fib(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut prev = 0;\n    let mut curr = 1;\n    for I in 2..=n {\n        let mid = (prev + curr) % 2;\n        prev = curr;\n        curr = mid;\n    }\n    curr"], ["/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"<\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut brackets = brackets.trim().split(' ').collect::<Vec<&str>>();\n    let mut open_brackets = 0;\n    let mut close_brackets = 0;\n    for bracket in brackets {\n        if bracket.is_empty() {\n            continue;\n        }\n        if bracket == \">\" {\n            close_brackets += 1;\n        } else if bracket == \"<\" {\n            open_brackets += 1;\n        } else {\n            return false;\n        }\n    }\n    if open_brackets == close_brackets {\n        return true;\n    } else {\n        return false;\n    }"], ["/// Return true is vector elements are monotonically increasing or decreasing.\n/// >>> monotonic(vec![1, 2, 4, 20])\n/// true\n/// >>> monotonic(vec![1, 20, 4, 10])\n/// false\n/// >>> monotonic(vec![4, 1, 0, -10])\n/// true\nfn monotonic(l: Vec<isize>) -> bool {\n    l.iter().cloned().all(|&x| x <= l.iter().cloned().max().unwrap_or(l.iter().cloned().max().unwrap()))"], ["/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut common = Vec::new();\n    for (i, v1) in l1.iter().enumerate() {\n        for (j, v2) in l2.iter().enumerate() {\n            if *v1 == *v2 {\n                common.push(*i);\n            }\n        }\n    }\n    common"], ["/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n/// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n/// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut factors = vec![];\n    let mut current_factor = 1;\n    for I in 2..=n {\n        if n % I == 0 {\n            current_factor = i;\n            break;\n        }\n    }\n    factors.push(current_factor);\n    for I in 2..=n / current_factor {\n        if n % I == 0 {\n            factors.push(i);\n        }\n    }\n    factors.sort_by(|a, b| a.cmp(b));\n    factors[0]"], ["/// sum_to_n is a function that sums numbers from 1 to n.\n/// >>> sum_to_n(30)\n/// 465\n/// >>> sum_to_n(100)\n/// 5050\n/// >>> sum_to_n(5)\n/// 15\n/// >>> sum_to_n(10)\n/// 55\n/// >>> sum_to_n(1)\n/// 1\nfn sum_to_n(n: isize) -> isize {\n    let mut sum = 0;\n    for I in 1..=n {\n        sum += I;\n    }\n    sum"], ["/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"(\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n/// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\")(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut brackets = brackets.split(\"(\").collect::<Vec<&str>>();\n    let mut open_brackets = 0;\n    let mut close_brackets = 0;\n    for bracket in brackets {\n        if bracket.is_empty() {\n            continue;\n        }\n        if bracket.chars().nth(0).unwrap() != '(' {\n            return false;\n        }\n        if bracket.chars().nth(bracket.len() - 1).unwrap() != ') {\n            return false;\n        }\n        open_brackets += 1;\n        close_brackets += 1;\n    }\n    open_brackets == close_brackets"], ["/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n/// >>> derivative(vec![3, 1, 2, 4, 5])\n/// vec![1, 4, 12, 20]\n/// >>> derivative(vec![1, 2, 3])\n/// vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![0; xs.len()];\n    for I in 0..xs.len() {\n        result[i] = xs[i] / (xs[i] + 1);\n    }\n    result"], ["/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fibfib(0) == 0\n/// fibfib(1) == 0\n/// fibfib(2) == 1\n/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n/// >>> fibfib(1)\n/// 0\n/// >>> fibfib(5)\n/// 4\n/// >>> fibfib(8)\n/// 24\nfn fibfib(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut fib = 0;\n    let mut prev = 0;\n    for I in 1..=n {\n        fib = prev + fib;\n        prev = fib - prev;\n    }\n    fib"], ["/// Write a function vowels_count which takes a string representing\n/// a word as input and returns the number of vowels in the string.\n/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s: String) -> isize {\n    let mut count = 0;\n    for c in s.chars() {\n        if c.is_ascii_vowel() {\n            count += 1;\n        }\n    }\n    count"], ["/// Circular shift the digits of the integer x, shift the digits right by shift\n/// and return the result as a string.\n/// If shift > number of digits, return digits reversed.\n/// >>> circular_shift(12, 1)\n/// String::from(\"21\")\n/// >>> circular_shift(12, 2)\n/// String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits = x.to_string();\n    let mut shifted_digits = String::new();\n    let mut shift = 0;\n    while digits.len() > shift {\n        shifted_digits.push(digits.remove(shift).to_string());\n        shift += 1;\n    }\n    shifted_digits.push(digits.remove(shift).to_string());\n    if shift > digits.len() {\n        shifted_digits.reverse();\n    }\n    shifted_digits"], ["/// Task\n/// Write a function that takes a string as input and returns the sum of the upper characters only'\n/// ASCII codes.\n/// Examples:\n/// >>> digitSum(String::from(\"\"))\n/// 0\n/// >>> digitSum(String::from(\"abAB\"))\n/// 131\n/// >>> digitSum(String::from(\"abcCd\"))\n/// 67\n/// >>> digitSum(String::from(\"helloE\"))\n/// 69\n/// >>> digitSum(String::from(\"woArBld\"))\n/// 131\n/// >>> digitSum(String::from(\"aAaaaXa\"))\n/// 153\nfn digitSum(s: String) -> isize {\n    let mut sum = 0;\n    for c in s.chars() {\n        if c.is_ascii_uppercase() {\n            sum += c.to_ascii_uppercase() as isize;\n        }\n    }\n    sum"], ["/// In this task, you will be given a string that represents a number of apples and oranges \n/// that are distributed in a basket of fruit this basket contains \n/// apples, oranges, and mango fruits. Given the string that represents the total number of \n/// the oranges and apples and an integer that represent the total number of the fruits \n/// in the basket return the number of the mango fruits in the basket.\n/// for examble:\n/// >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n/// 8\n/// >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n/// 2\n/// >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n/// 95\n/// >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n/// 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n    let mut count = 0;\n    for c in s.chars() {\n        match c {\n            'a' => count += 1,\n            'o' => count += 1,\n            'm' => count += 1,\n            _ => {}\n        }\n    }\n    if n == 0 {\n        return count;\n    }\n    if n == 1 {\n        return count;\n    }\n    let mut total = 0;\n    for c in s.chars() {\n        match c {\n            'a' => total += 1,\n            'o' => total += 1,\n            'm' => total += 1,\n            _ => {}\n        }\n    }\n    total * n"], ["/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.into_iter().collect::<Vec<_>>();\n    let mut min_index = arr.len() - 1;\n    let mut min_value = arr[min_index];\n    for I in 0..arr.len() {\n        if arr[i] < min_value {\n            min_index = i;\n            min_value = arr[i];\n        }\n    }\n    let mut result = vec![min_value, min_index];\n    if arr.len() > 1 {\n        result.push(arr[min_index]);\n"], ["/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n/// zero, and has a frequency greater than or equal to the value of the integer itself. \n/// The frequency of an integer is the number of times it appears in the vector.\n/// If no such a value exist, return -1.\n/// Examples:\n/// >>> search(vec![4, 1, 2, 2, 3, 1])\n/// 2\n/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n/// 3\n/// >>> search(vec![5, 5, 4, 4, 4])\n/// -1\nfn search(lst: Vec<isize>) -> isize {\n    let mut freq = HashMap::new();\n    for num in lst {\n        freq.insert(num, freq.get(&num).unwrap_or(&0).wrapping_add(1));\n    }\n    let max_freq = freq.iter().max_by_key(|&(f, _)| f).unwrap_or(&(0, 0));\n    let max_freq_num = max_freq.0;\n    let max_freq_count = max_freq.1;\n    if max_freq_count == 0 {\n        return -1;\n    }\n    max_freq_num / max_freq_count"], ["/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = lst.clone();\n    let mut min_idx = 0;\n    let mut max_idx = 0;\n    for I in 1..lst.len() {\n        if lst[i] < lst[min_idx] {\n            min_idx = i;\n        }\n        if lst[i] > lst[max_idx] {\n            max_idx = i;\n        }\n    }\n    sorted_lst.swap(min_idx, max_idx);\n    sorted_lst"], ["/// Given the lengths of the three sides of a triangle. Return the area of\n/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum of any two sides is greater \n/// than the third side.\n/// Example:\n/// >>> triangle_area(3, 4, 5)\n/// 6.0\n/// >>> triangle_area(1, 2, 10)\n/// -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    let sum = a + b + c;\n    let half_sum = (a + b) / 2.0;\n    let half_half_sum = (a + b) / 2.0;\n    let half_sum_c = (a + c) / 2.0;\n    let half_half_sum_c = (a + c) / 2.0;\n    let half_sum_half_sum = (a + b) / 2.0;\n    let half_half_sum_half_sum = (a + b) / 2.0;\n    let half_sum_half_half_sum = (a + b) / 2.0;\n    let half_half_half_sum_half_sum = (a + b) / 2.0;\n    let half_sum_half_half_half_sum = (a + b) / 2.0;\n    let half_half_half_half_sum_half_sum = (a + b) / 2.0;\n    let half_sum_half_half_half_half_sum = (a + b) / 2.0;\n    let half_half_half_half_half_sum_half_sum = (a + b) / 2.0;\n    let half_half_half_half_half_half_sum = (a + b) / 2.0;\n    let half_sum_half_half_half_half_half_sum = (a + b) / 2.0;\n    let half_half_half_half_half_half"], ["/// Write a function that returns true if the object q will fly, and false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n/// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>> will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n/// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for I in 0..q.len() {\n        sum += q[i];\n        if sum > w {\n            return false;\n        }\n    }\n    sum <= w"], ["/// Given a vector arr of integers, find the minimum number of elements that\n/// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n/// is read the same backwards and forwards. In one change, you can change one element to any other element.\n/// For example:\n/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n/// 4\n/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n/// 1\n/// >>> smallest_change(vec![1, 2, 3, 2, 1])\n/// 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut min_change = 0;\n    for I in 0..arr.len() {\n        let mut change = 1;\n        for j in I..arr.len() {\n            if arr[j] != arr[i] {\n                change *= 2;\n            }\n        }\n        if change < min_change {\n            min_change = change;\n            count = 0;\n        }\n        count += 1;\n    }\n    min_change"], ["/// Write a function that accepts two vectors of strings and returns the vector that has \n/// total number of chars in the all strings of the vector less than the other vector.\n/// if the two vectors have the same number of chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n/// Vec::<String>::new()\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n/// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n/// >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let mut count = 0;\n    for s in lst1 {\n        if lst2.iter().any(|x| x.chars().nth(0).unwrap() == s.chars().nth(0).unwrap()) {\n            count += 1;\n        }\n    }\n    lst1.iter().filter(|x| x.chars().nth(0).unwrap() == String::from(\"h\")).collect()"], ["/// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n/// and false otherwise.\n/// Knowing that (a) is less then 100. \n/// Example:\n/// >>> is_multiply_prime(30)\n/// true\n/// 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n    let mut count = 0;\n    let mut sum = 0;\n    let mut num = a;\n    while num > 1 {\n        if num % 2 == 0 || num % 3 == 0 {\n            count += 1;\n        }\n        sum += num;\n        num /= 2;\n    }\n    if count == 0 {\n        return true;\n    } else if count == 1 {\n        return sum % 3 == 0;\n    } else {\n        return sum % 3 == 0 && sum % 5 == 0;\n    }"], ["/// Your task is to write a function that returns true if a number x is a simple\n/// power of n and false in other cases.\n/// x is a simple power of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n/// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n/// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n/// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 1 {\n        return true;\n    }\n    if x == 1 {\n        return false;\n    }\n    let mut result = x;\n    while result * n > x {\n        result *= n;\n        n *= 2;\n    }\n    result *= n;\n    result == x"], ["/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    a.powi(3) == a"], ["/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let mut count = 0;\n    for I in 0..num.len() {\n        let digit = num[i];\n        if digit.is_digit(10) {\n            count += digit as isize;\n        }\n    }\n    count"], ["/// You will be given a number in decimal form and your task is to convert it to\n/// binary format. The function should return a string, with each character representing a binary\n/// number. Each character in the string will be '0' or '1'.\n/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n/// The extra characters are there to help with the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n    let mut decimal_str = String::from(format!(\"{:02}\", decimal));\n    let mut binary_str = String::new();\n    let mut i = 0;\n    while decimal_str.len() > 0 {\n        let digit = decimal_str.chars().nth(i).unwrap();\n        let binary_digit = digit.to_digit(2).unwrap();\n        binary_str.push(binary_digit);\n        decimal_str.pop();\n        i += 1;\n    }\n    binary.push_str(&binary_str);\n    binary"], ["/// You are given a string s.\n/// Your task is to check if the string is haprs or not.\n/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(String::from(\"a\"))\n/// false\n/// >>> is_happy(String::from(\"aa\"))\n/// false\n/// >>> is_happy(String::from(\"abcd\"))\n/// true\n/// >>> is_happy(String::from(\"aabb\"))\n/// false\n/// >>> is_happy(String::from(\"adb\"))\n/// true\n/// >>> is_happy(String::from(\"xyy\"))\n/// false\nfn is_happy(s: String) -> bool {\n    let mut stack = Vec::new();\n    let mut visited = Vec::new();\n    for c in s.chars() {\n        if visited.contains(&c) {\n            continue;\n        }\n        visited.push(c);\n        if stack.len() == 0 {\n            stack.push(c);\n        } else if stack.last().unwrap() != &c {\n            stack.pop();\n        }\n    }\n    visited.iter().all(|&c| stack.pop().unwrap() == c)"], ["/// It is the last week of the semester and the teacher has to give the grades\n/// to students. The teacher has been making her own algorithm for grading.\n/// The only problem is, she has lost the code she used for grading.\n/// She has given you a vector of GPAs for some students and you have to write \n/// a function that can output a vector of letter grades using the following table:\n/// GPA       |    Letter grade\n/// 4.0                A+\n/// > 3.7                A \n/// > 3.3                A- \n/// > 3.0                B+\n/// > 2.7                B \n/// > 2.3                B-\n/// > 2.0                C+\n/// > 1.7                C\n/// > 1.3                C-\n/// > 1.0                D+ \n/// > 0.7                D \n/// > 0.0                D-\n/// 0.0                E\n/// Example:\n/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n/// vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    let mut letter_grades: Vec<String> = vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\n    for grade in grades {\n        if grade >= 3.7 {\n            letter_grades.push(String::from(\"A+\"))\n        } else if grade >= 3.3 && grade < 3.7 {\n            letter_grades.push(String::from(\"A\"))\n        } else if grade >= 3.0 && grade < 3.3 {\n            letter_grades.push(String::from(\"B+\"))\n        } else if grade >= 2.7 && grade < 3.0 {\n            letter_grades.push(String::from(\"B\"))\n       "], ["/// Write a function that takes a string and returns true if the string\n/// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n/// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut count = 0;\n    for char in string.chars() {\n        if char.is_digit(10) {\n            count += 1;\n        }\n    }\n    count == string.len()"], ["/// Given a positive integer n, return the count of the numbers of n-digit\n/// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) -> isize {\n    let mut count = 0;\n    for I in 1..=n {\n        if I % 1 == 0 {\n            count += 1;\n        } else {\n            break;\n        }\n    }\n    count"], ["/// Given a positive integer N, return the total sum of its digits in binary.\n/// Example\n/// >>> solve(1000)\n/// String::from(\"1\")\n/// >>> solve(150)\n/// String::from(\"110\")\n/// >>> solve(147)\n/// String::from(\"1100\")\n/// Variables:\n/// @N integer\n/// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary number\nfn solve(N: isize) -> String {\n    let mut sum = 0;\n    let mut digits = vec![0; 10];\n    let mut count = 0;\n    let mut i = 0;\n    while N > 0 {\n        let digit = N % 10;\n        sum += digit;\n        count += 1;\n        N /= 10;\n        i += 1;\n    }\n    let mut result = String::new();\n    for I in 0..count {\n        result.push(digits[i]);\n    }\n    result.push_str(&format!(\"{:02}\", sum));\n    result"], ["/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n/// Examples:\n/// >>> add(vec![4, 2, 6, 7])\n/// 2\nfn add(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for I in 0..lst.len() {\n        if I % 2 == 1 {\n            sum += lst[i];\n        }\n    }\n    sum"], ["/// Write a function that takes a string and returns an ordered version of it.\n/// Ordered version of string, is a string where all words (separated by space)\n/// are replaced by a new word where all the characters arranged in\n/// ascending order based on ascii value.\n/// Note: You should keep the order of words and blank spaces in the sentence.\n/// For example:\n/// >>> anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n    let mut words = s.split_whitespace().map(|w| w.to_lowercase());\n    let mut words = words.collect::<Vec<_>>();\n    words.sort_unstable();\n    words.join(\" \")"], ["/// You are given a 2 dimensional data, as a nested vectors,\n/// which is similar to matrix, however, unlike matrices,\n/// each row may contain a different number of columns.\n/// Given lst, and integer x, find integers x in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize, isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut sorted_lst = lst.iter().cloned().collect::<Vec<_>>();\n    sorted_lst.sort_by_key(|row| row.iter().map(|&x| x).collect::<Vec<_>>().iter().map(|&y| y).collect::<Vec<_>>().iter().map(|&x| x).collect::<Vec<_>>().iter().collect::<Vec<_>>().iter().map(|&y| y).collect::<Vec<_>>().iter().collect::<Vec<_>>().iter().collect::<Vec<_>>().iter().collect::<Vec<_>>().iter().collect::<Vec<_>>().iter().collect::<Vec<_>>().iter().collect::<Vec<_"], ["/// Given a vector of non-negative integers, return a cors of the given vector after sorting,\n/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n/// or sort it in descending order if the sum( first index value, last index value) is even.\n/// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n/// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n    if sorted_array.len() % 2 == 1 {\n        sorted_array.sort_by(|a, b| a.cmp(b));\n    } else {\n        sorted_array.sort_by(|a, b| b.cmp(a));\n    }\n    sorted_array"], ["/// Create a function encrypt that takes a string as an argument and\n/// returns a string encrypted with the alphabet being rotated. \n/// The alphabet should be rotated in a manner such that the letters \n/// shift down by two multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n/// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s: String) -> String {\n    let mut encrypted = String::new();\n    let mut alphabet = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n    let mut shift = 2;\n    for I in 0..s.len() {\n        let mut j = (i + shift) % alphabet.len();\n        let mut c = alphabet[i];\n        while j < alphabet.len() {\n            c = alphabet[j];\n            alphabet.swap(j, j + shift);\n            j += shift;\n        }\n        encrypted.push(c);\n    }\n    encrypted"], ["/// You are given a vector of integers.\n/// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n/// Return None if there is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n/// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n/// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    let mut min_idx = 0;\n    let mut min_val = lst[0];\n    for I in 1..lst.len() {\n        if lst[i] < min_val {\n            min_idx = i;\n            min_val = lst[i];\n        }\n    }\n    Some(min_val)"], ["/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut count = 0;\n    for I in S.chars() {\n        if I == '!' || I == '?' || I == '!' || I == '?' {\n            count += 1;\n        }\n    }\n    count"], ["/// Create a function that takes 3 numbers.\n/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n/// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n/// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n/// true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    x + y + z == f64::try_from(x + y + z).unwrap()"], ["/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n    let mut result = message;\n    for (i, c) in message.chars().enumerate() {\n        if c == 'a' && i == 0 {\n            result.insert(i, 'e');\n        } else if c == 'e' && i == 1 {\n            result.insert(i, 'a');\n        } else if c == 'i' && i == 1 {\n            result.insert(i, 'i');\n        } else if c == 'o' && i == 1 {\n            result.insert(i, 'o');\n        } else if c == 'u' && i == 1 {\n            result.insert(i, 'u');\n        } else if c == 'A' && i == 0 {\n            result.insert(i, 'E');\n        } else if c == 'E' && i == 1 {\n            result.insert(i, 'A');\n        } else if c == 'I' && i == 1 {\n            result.insert(i, 'I');\n        } else if c == 'O' && i == 1 {\n            result.insert(i, 'O');\n        } else if c == 'U' && i == 1 {\n            result.insert(i, 'U');\n        } else {\n            result.insert(i, c);\n        }\n    }\n    result"], ["/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for num in lst {\n        let mut sum_digits = 0;\n        for digit in num.iter().rev() {\n            sum_digits += digit.to_string().chars().filter(|c| c.is_digit(10)).count();\n        }\n        sum += sum_digits;\n   "], ["use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys = dict.keys().cloned().collect::<Vec<String>>();\n    keys.sort_by_key(|k| k.to_lowercase().as_str());\n    keys.len() == dict.values().cloned().collect::<Vec<String>>().len()"], ["/// Implement a function that takes an non-negative integer and returns a vector of the first n\n/// integers that are prime numbers and less than n.\n/// for example:\n/// >>> count_up_to(5)\n/// vec![2, 3]\n/// >>> count_up_to(11)\n/// vec![2, 3, 5, 7]\n/// >>> count_up_to(0)\n/// Vec::<isize>::new()\n/// >>> count_up_to(20)\n/// vec![2, 3, 5, 7, 11, 13, 17, 19]\n/// >>> count_up_to(1)\n/// Vec::<isize>::new()\n/// >>> count_up_to(18)\n/// vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n    let mut count = Vec::new();\n    for I in 2..=n {\n        if is_prime(i) {\n            count.push(i);\n        }\n    }\n    count"], ["/// Complete the function that takes two integers and returns \n/// the product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n/// >>> multiply(148, 412)\n/// 16\n/// >>> multiply(19, 28)\n/// 72\n/// >>> multiply(2020, 1851)\n/// 0\n/// >>> multiply(14, -15)\n/// 20\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 1;\n    while a > 0 && b > 0 {\n        let remainder = a % b;\n        product *= b;\n        a /= b;\n        b -= remainder;\n    }\n    product * b"], ["/// Given a string s, count the number of uppercase vowels in even indices.\n/// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>> count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n    for I in 0..s.len() {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            count += 1;\n        }\n    }\n    count"], ["/// Create a function that takes a value (string) representing a number\n/// and returns the closest integer to it. If the number is equidistant\n/// from two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n/// Rounding away from zero means that if the given number is equidistant\n/// from two integers, the one you should return is the one that is the\n/// farthest from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n    let mut min_value = value.chars().min().unwrap();\n    let mut max_value = value.chars().max().unwrap();\n    let mut closest_value = min_value;\n\n    for I in 1..=value.len() {\n        let current_value = value[i];\n        let current_min_value = min_value;\n        let current_max_value = max_value;\n\n        if current_value < current_min_value {\n            current_min_value = current_value;\n        }\n        if current_value > current_max_value {\n            current_max_value = current_value;\n        }\n\n        if current_value == closest_value {\n            continue;\n        }\n\n        if current_value < closest_value {\n            closest_value = current_value;\n        }\n    }\n\n    closest_value"], ["/// Given a positive integer n, you have to make a pile of n levels of stones.\n/// The first level has n stones.\n/// The number of stones in the next level is:\n/// - the next odd number if n is odd.\n/// - the next even number if n is even.\n/// Return the number of stones in each level in a vector, where element at index\n/// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>> make_a_pile(3)\n/// vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![];\n    let mut count = 0;\n    while n > 1 {\n        if n % 2 == 0 {\n            count += 1;\n        } else {\n            count += 3;\n        }\n        n /= 2;\n    }\n    pile.push(count);\n    pile"], ["/// You will be given a string of words separated by commas or spaces. Your task is\n/// to split the string into words and return a vector of the words.\n/// For example:\n/// >>> words_string(String::from(\"Hi, my name is John\"))\n/// vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n/// >>> words_string(String::from(\"One, two, three, four, five, six\"))\n/// vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n    s.split(\", \").map(|s| s.trim().to_string()).collect()"], ["/// This function takes two positive numbers x and y and returns the\n/// biggest even integer number that is in the range [x, y] inclusive. If \n/// there's no such number, then the function should return -1.\n/// For example:\n/// >>> choose_num(12, 15)\n/// 14\n/// >>> choose_num(13, 12)\n/// -1\nfn choose_num(x: isize, y: isize) -> isize {\n    let mut max_num = x;\n    let mut max_num_index = 0;\n    for I in 1..=y {\n        if max_num < i {\n            max_num = i;\n            max_num_index = I;\n        }\n    }\n    max_num_index"], ["/// Given a vector of positive integers x. return a sorted vector of all \n/// elements that hasn't any even digit.\n/// Note: Returned vector should be sorted in increasing order.\n/// For example:\n/// >>> unique_digits(vec![15, 33, 1422, 1])\n/// vec![1, 15, 33]\n/// >>> unique_digits(vec![152, 323, 1422, 10])\n/// Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    x.iter().filter(|&x| x % 2 == 0).cloned().collect()"], ["/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n/// reverse the resulting vector, and then replace each digit by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty, return an empty vector:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n/// If the vector has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result = Vec::new();\n    for num in arr {\n        if num > 9 {\n            result.push(String::from(num.to_string()));\n        } else {\n            result.push(String::from(num.to_string()));\n        }\n    }\n    result.sort_by(|a, b| a.cmp(b));\n    result.reverse();\n    result"], ["/// Implement the function f that takes n as a parameter,\n/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n/// or the sum of numbers from 1 to i otherwise.\n/// i starts from 1.\n/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n/// Example:\n/// >>> f(5)\n/// vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n    let mut result = vec![1];\n    for I in 1..=n {\n        result.push(i.pow(i % 2));\n    }\n    result"], ["/// Given a positive integer n, return a tuple that has the number of even and odd\n/// integer palindromes that fall within the range(1, n), inclusive.\n/// Example 1:\n/// >>> even_odd_palindrome(3)\n/// (1, 2)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n/// Example 2:\n/// >>> even_odd_palindrome(12)\n/// (4, 6)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n/// Note:\n/// 1. 1 <= n <= 10^3\n/// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_palindromes = 0;\n    let mut odd_palindromes = 0;\n    for I in 1..=n {\n        if i % 2 == 0 {\n            even_palindromes += 1;\n        } else {\n            odd_palindromes += 1;\n        }\n    }\n    (even_palindromes, odd_palindromes)"], ["/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in arr {\n        if num > 0 && num.abs() % 10 == 0 {\n            count += 1;\n        }\n    }\n    count"], ["/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n/// numbers in the vector will be randomly ordered. Your task is to determine if\n/// it is possible to get a vector sorted in non-decreasing order by performing \n/// the following operation on the given vector:\n/// You are allowed to perform right shift operation any number of times.\n/// One right shift operation means shifting all elements of the vector by one\n/// position in the right direction. The last element of the vector will be moved to\n/// the starting position in the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector by performing the above operation\n/// then return true else return false.\n/// If the given vector is empty then return true.\n/// Note: The given vector is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3, 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations, non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3, 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing order for the given\n/// vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut n = arr.len();\n    let mut shift = 1;\n    while n > 1 {\n        n -= 1;\n        arr.rotate_left(shift);\n        shift += 1;\n    }\n    arr.rotate_left(shift);\n    arr.sort();\n    arr.is_sorted()"], ["/// In this problem, you will implement a function that takes two vectors of numbers,\n/// and determines whether it is possible to perform an exchange of elements\n/// between them to make lst1 a vector of only even numbers.\n/// There is no limit on the number of exchanged elements between lst1 and lst2.\n/// If it is possible to exchange elements between the lst1 and lst2 to make\n/// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return \"NO\".\n/// For example:\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n/// String::from(\"YES\")\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n/// String::from(\"NO\")\n/// It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut lst1_copy = lst1.clone();\n    let mut lst2_copy = lst2.clone();\n\n    // Copy lst1 and lst2 to make them equal\n    for I in 0..lst1.len() {\n        lst1_copy[i] = lst1[i];\n        lst2_copy[i] = lst2[i];\n    }\n\n    // Find the number of even elements in lst1\n    let mut even_count = 0;\n    for I in 0..lst1.len() {\n        if lst1[i] % 2 == 0 {\n            even_count += 1;\n        }\n    }\n\n    // If there are no even elements in lst1, return \"NO\"\n    if even_count == 0 {\n        return String::from(\"NO\");\n    }\n\n    // Find the number of even elements in lst2\n    let mut even_count2 = 0;\n    for I in 0..lst2.len() {\n        if lst2[i] % 2 == 0 {\n            even_count2 += 1;\n        }\n    }\n\n    // If there are no even elements in lst2,"], ["use std::collections::HashMap;\n\n/// Given a string representing a space separated lowercase letters, return a HashMap\n/// of the letter with the most repetition and containing the corresponding count.\n/// If several letters have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut hm = HashMap::new();\n    for c in test.chars() {\n        if let Some(count) = hm.entry(c.to_string()) {\n            *count += 1;\n        } else {\n            hm.insert(c.to_string(), 1);\n        }\n    }\n    hm"], ["/// Task\n/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n/// then check if the result string is palindrome.\n/// A string is called palindrome if it reads the same backward as forward.\n/// You should return a tuple containing the result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n    let mut s_copy = s.clone();\n    let mut c_copy = c.clone();\n    let mut result = String::new();\n    let mut is_palindrome = true;\n\n    for I in 0..s_copy.len() {\n        for j in 0..c_copy.len() {\n            if s_copy[i] == c_copy[j] {\n                result.push(s_copy[i]);\n                c_copy.remove(j);\n                j -= 1;\n            }\n        }\n        if c_copy.is_empty() {\n            break;\n        }\n    }\n\n    if result.is_empty() {\n        is_palindrome = false;\n    }\n\n    (result, is_palindrome)"], ["/// Given a vector of strings, where each string consists of only digits, return a vector.\n/// Each element i of the output should be \"the number of odd elements in the\n/// string i of the input.\" where all the i's should be replaced by the number\n/// of odd digits in the i'th string of the input.\n/// >>> odd_count(vec![String::from(\"1234567\")])\n/// vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n/// >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n/// vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n    let mut count = vec![0; lst.len()];\n    for s in lst {\n        let mut count_i = 0;\n        for c in s.chars() {\n            if c.is_digit(10) {\n                count_i += 1;\n            }\n        }\n        count[s.len() - count_i - 1] += 1;\n    }\n    count.iter().map(|&x| String::from(&x)).collect()"], ["/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n/// of nums.\n/// Example\n/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n/// 1\n/// >>> minSubArraySum(vec![-1, -2, -3])\n/// -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut sum = 0;\n    let mut min_sum = isize::MAX;\n    for num in nums {\n        sum += num;\n        if sum < min_sum {\n            min_sum = sum;\n        }\n    }\n    min_sum"], ["/// You are given a rectangular grid of wells. Each row represents a single well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well has a corresponding bucket that can be used to extract water from it, \n/// and all buckets have the same capacity.\n/// Your task is to use the buckets to empty the wells.\n/// Output the number of times you need to lower the buckets.\n/// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n    for I in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            let mut bucket = 0;\n            for I2 in 0..grid[i].len() {\n                if grid[i][j] == 1 {\n                    bucket += 1;\n                }\n            }\n            if bucket > capacity {\n                max_fill += 1;\n            }\n        }\n    }\n    max_fill"], ["/// In this Kata, you have to sort a vector of non-negative integers according to\n/// number of ones in their binary representation in ascending order.\n/// For similar number of ones, sort based on decimal value.\n/// It must be implemented like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n/// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n/// >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr"], ["/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut current_word = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic() {\n            current_word.push(c);\n        } else if current_word.len() == n {\n            words.push(current_word.to_string());\n            current_word = String::new();\n        }\n    }\n    if current_word.len() > 0 {\n        words.push(current_word.to_string());\n    }\n    words"], ["/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let mut vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_index = 0;\n    let mut closest_vowel = String::from(\"\");\n    for I in 0..word.len() {\n        let vowel = word[i];\n        if vowels.contains(&vowel) {\n            vowel_index = i;\n            break;\n        }\n    }\n    if vowel_index == 0 {\n        return closest_vowel;\n    }\n    let mut closest_distance = String::from(\"\");\n    for I in 0..word.len() {\n        let vowel = word[i];\n        if vowels[vowel_index] == vowel {\n            closest_distance = word[i..i+1].to_string();\n            break;\n        }\n    }\n    closest_distance"], ["/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n    let mut stack = Vec::new();\n    let mut result = String::new();\n    for s in lst {\n        if s.is_empty() {\n            continue;\n        }\n        if s.chars().nth(0).unwrap() == '(' {\n            stack.push(s);\n        } else if s.chars().nth(0).unwrap() == ') {\n            if let Some(s) = stack.pop() {\n                result.push_str(&s);\n            } else {\n                result.push_str(\"()\");\n            }\n        } else {\n            result.push_str(&s);\n        }\n    }\n    if stack.is_empty() {\n        result.push_str(\"()\");\n    }\n    result"], ["/// Given a vector arr of integers and a positive integer k, return a sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector will be in the range of [1, 1000].\n/// 2. The elements in the vector will be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut max_idx = 0;\n    let mut max_val = arr[0];\n    for I in 1..arr.len() {\n        if arr[i] > max_val {\n            max_idx = i;\n            max_val = arr[i];\n        }\n    }\n    let mut res = vec![];\n    for I in 0..k {\n        res.push(arr[max_idx + I]);\n    }\n    res"], ["/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n/// Examples\n/// >>> solution(vec![5, 8, 7, 1])\n/// 12\n/// >>> solution(vec![3, 3, 3, 3, 3])\n/// 9\n/// >>> solution(vec![30, 13, 24, 321])\n/// 0\nfn solution(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for I in 0..lst.len() {\n        if lst[i] % 2 == 1 {\n            sum += lst[i];\n        }\n    }\n    sum"], ["/// Given a non-empty vector of integers arr and an integer k, return\n/// the sum of the elements with at most two digits from the first k elements of arr.\n/// Example:\n/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n/// 24\n/// Constraints:\n/// 1. 1 <= len(arr) <= 100\n/// 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    let mut sum = 0;\n    for I in 0..k {\n        let mut sum_of_digits = 0;\n        for j in 0..arr.len() {\n            if arr[j] <= 9 {\n                sum_of_digits += arr[j];\n            } else {\n                sum_of_digits += (arr[j] - 10) as isize;\n            }\n        }\n        sum += sum_of_digits;\n    }\n    sum"], ["/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n/// as follows: start with any positive integer n. Then each term is obtained from the \n/// previous term as follows: if the previous term is even, the next term is one half of \n/// the previous term. If the previous term is odd, the next term is 3 times the previous\n/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n/// 2. returned vector sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n/// >>> get_odd_collatz(5)\n/// vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut collatz = vec![n];\n    for I in 1..=n {\n        if i % 2 == 0 {\n            collatz.push(i / 2);\n        } else {\n            collatz.push(3 * i + 1);\n        }\n    }\n    collatz.sort();\n    collatz"], ["/// You have to write a function which validates a given date string and\n/// returns true if the date is valid otherwise false.\n/// The date is valid if all of the following rules are satisfied:\n/// 1. The date string is not empty.\n/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n/// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut date_parts = date.split('-').collect::<Vec<&str>>();\n    let mut month = date_parts[0].parse::<u8>().unwrap();\n    let mut day = date_parts[1].parse::<u8>().unwrap();\n    let mut year = date_parts[2].parse::<u16>().unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    if day < 1 || day > 31 {\n        return false;\n    }\n\n    if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false;\n        }\n    }\n\n   "], ["/// Given a vector of numbers, return whether or not they are sorted\n/// in ascending order. If vector has more than 1 duplicate of the same\n/// number, return false. Assume no negative numbers and only integers.\n/// Examples\n/// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\nfn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    let mut i = 0;\n    let mut j = 1;\n    while i < lst.len() - 1 {\n        if lst[i] > lst[j] {\n            return false;\n        }\n        if lst[i] == lst[j] {\n            i += 1;\n            j += 1;\n        } else {\n            i += 1;\n        }\n    }\n    true"], ["/// You are given two intervals,\n/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed which means that the interval (start, end)\n/// includes both start and end.\n/// For each given interval, it is assumed that its start is less or equal its end.\n/// Your task is to determine whether the length of intersection of these two \n/// intervals is a prime number.\n/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n/// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let mut result = String::new();\n    let mut start = interval1.0;\n    let mut end = interval1.1;\n    while start <= end {\n        if interval2.0 <= start && interval2.1 >= end {\n            result.push(start);\n            start = interval2.1;\n        } else if interval2.0 <= end && interval2.1 <= start {\n            result.push(end);\n            end = interval2.0;\n        } else if interval2.0 <= start && interval2.1 <= end {\n            result.push(start);\n            start = interval2.1;\n        } else if interval2.0 <= end && interval2.1 <= start {\n            result.push(end);\n            end = interval2.0;\n        }\n    }\n    if result.is_empty() {\n        result.push('0');\n    }\n    result"], ["/// You are given a vector arr of integers and you need to return\n/// sum of magnitudes of integers multiplied by product of all signs\n/// of each number in the vector, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n/// >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut sum = 0;\n    let mut prod = 1;\n    for num in arr {\n        sum += num * prod;\n        prod *= -1;\n    }\n    Some(sum)"], ["/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n/// each cell of the grid contains a value. Every integer in the range [1, N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You have to find the minimum path of length k in the grid. You can start\n/// from any cell, and in each step you can move to any of the neighbor cells,\n/// in other words, you can go to cells which share an edge with you current\n/// cell.\n/// Please note that a path of length k means visiting exactly k cells (not\n/// necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length k) is considered less than a path B (of length k) if\n/// after making the ordered vectors of the values on the cells that A and B go\n/// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed that the answer is unique.\n/// Return an ordered vector of the values on the cells that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let m = grid[0].len();\n    let mut path = vec![0; k + 1];\n    path[0] = 1;\n    for I in 1..k {\n       "], ["/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return a vector of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(3)\n/// vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n    let mut result = vec![1];\n    let mut n_div_2 = n / 2;\n    let mut n_div_4 = n / 4;\n    let mut sum = 1;\n    while n_div_2 > 0 {\n        sum += result[n_div_4];\n        n_div_4 -= 1;\n        n_div_2 -= 1;\n    }\n    result.push(sum);\n    result"], ["/// Given a positive integer n, return the product of the odd digits.\n/// Return 0 if all digits are even.\n/// For example:\n/// >>> digits(1)\n/// 1\n/// >>> digits(4)\n/// 0\n/// >>> digits(235)\n/// 15\nfn digits(n: isize) -> isize {\n    let mut sum = 0;\n    for I in 1..=n {\n        let digit = i.to_string().chars().next().unwrap();\n        let digit_sum = digit.chars().filter(|c| c.is_digit(10)).fold(0, |acc, c| acc * 10 + c.to_digit(10).unwrap());\n        sum += digit_sum;\n    }\n    sum"], ["/// Create a function that takes a string as input which contains only square brackets.\n/// The function should return true if and only if there is a valid subsequence of brackets \n/// where at least one bracket in the subsequence is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n/// false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"[[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\nfn is_nested(string: String) -> bool {\n    let mut brackets = String::new();\n    for c in string.chars() {\n        match c {\n            '[' => brackets.push('['),\n            ']' => brackets.push(']'),\n            '{' => brackets.push('{'),\n            '}' => brackets.push('}'),\n            _ => brackets.push(c),\n        }\n    }\n    brackets.trim().is_empty()"], ["/// You are given a vector of numbers.\n/// You need to return the sum of squared numbers in the given vector,\n/// round each element in the vector to the upper int(Ceiling) first.\n/// Examples:\n/// >>> lst(vec![1.0, 2.0, 3.0])\n/// 14\n/// >>> lst(vec![1.0, 4.0, 9.0])\n/// 98\n/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n/// 84\n/// >>> lst(vec![1.4, 4.2, 0.0])\n/// 29\n/// >>> lst(vec![-2.4, 1.0, 1.0])\n/// 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter().map(|x| x.powi(2)).sum::<isize>()"], ["/// Create a function that returns true if the last character\n/// of a given string is an alphabetical character and is not\n/// a part of a word, and false otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n    let mut last_char = txt.chars().last().unwrap();\n    let mut is_letter = false;\n    let mut is_word = false;\n    for c in txt.chars() {\n        if c == last_char {\n            is_letter = true;\n        } else if c.is_alphabetic() {\n            is_letter = true;\n            is_word = true;\n        } else {\n            is_letter = false;\n            is_word = false;\n        }\n        last_char = c;\n    }\n    is_letter && is_word"], ["/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let mut prev = arr.pop().unwrap();\n    let mut max_idx = 0;\n    for I in 1..arr.len() {\n        if arr[i] > prev {\n            prev = arr[i];\n            max_idx = i;\n        }\n    }\n    max_idx"], ["/// Create a function that returns a tuple (a, b), where 'a' is\n/// the largest of negative integers, and 'b' is the smallest\n/// of positive integers in a vector.\n/// If there is no negative or positive integers, return them as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_val = 0;\n    let mut min_val = 0;\n    for num in lst {\n        if num < 0 {\n            max_val = max(max_val, num);\n        } else {\n            min_val = min(min_val, num);\n        }\n    }\n    if max_val == 0 {\n        (None, None)\n    } else {\n        (Some(max_val), Some(min_val))\n    }"], ["/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n/// Example\n/// >>> is_equal_to_sum_even(4)\n/// false\n/// >>> is_equal_to_sum_even(6)\n/// false\n/// >>> is_equal_to_sum_even(8)\n/// true\nfn is_equal_to_sum_even(n: isize) -> bool {\n    let mut sum = 0;\n    for I in 1..=n {\n        if I % 2 == 0 {\n            sum += i;\n        }\n    }\n    sum % 2 == 0"], ["/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>> special_factorial(4)\n/// 288\n/// The function will receive an integer as input and should return the special\n/// factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n    if n < 0 {\n        panic!(\"Input must be a positive integer\");\n    }\n    let mut result = 1;\n    for I in 1..=n {\n        result *= i;\n    }\n    result"], ["/// Given a string text, replace all spaces in it with underscores, \n/// and if a string has more than 2 consecutive spaces, \n/// then replace all consecutive spaces with - \n/// >>> fix_spaces(String::from(\" Example\"))\n/// String::from(\"Example\")\n/// >>> fix_spaces(String::from(\" Example 1\"))\n/// String::from(\"Example_1\")\n/// >>> fix_spaces(String::from(\" Example 2\"))\n/// String::from(\"_Example_2\")\n/// >>> fix_spaces(String::from(\" Example 3\"))\n/// String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n    let mut text = text.trim();\n    let mut spaces = text.chars().filter(|c| c.is_whitespace()).collect::<Vec<char>>();\n    let mut spaces_count = 0;\n    for c in spaces {\n        if spaces.len() > 2 {\n            spaces.pop();\n            spaces_count += 1;\n        }\n        spaces.push(c);\n    }\n    let mut result = String::new();\n    for c in spaces {\n        result.push(c);\n    }\n    result.push_str(&text[spaces_count..]);\n    result"], ["/// Create a function which takes a string representing a file's name, and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n/// A file's name is considered to be valid if and only if all the following conditions \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The substring before the dot should not be empty, and it starts with a letter from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n/// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n    let mut file_name_parts = file_name.split('.').collect::<Vec<&str>>();\n    let first_letter = file_name_parts[0].chars().next().unwrap();\n    let last_letter = file_name_parts[1].chars().next().unwrap();\n    let file_name_parts_str = String::from(file_name_parts.join(\"\"));\n    let file_name_parts_str_len = file_name_parts_str.len();\n    let file_name_parts_str_len_minus_1 = file_name_parts_str_len - 1;\n    let file_name_parts_str_minus_1 = file_name_parts_str.chars().nth(file_name_parts_str_len_minus_1).unwrap();\n    let file_name_parts_str_minus_1_lower = file_name_parts_str_minus_1.to_lowercase();\n    let file_name_parts_str_minus_1_upper = file_name_parts_str_minus_1.to_uppercase();\n    if file_name_parts_str_"], ["/// \"\n/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n/// Examples:\n/// >>> lst\n/// vec![1, 2, 3]\n/// >>> lst\n/// vec![]\n/// >>> lst\n/// vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for I in 0..lst.len() {\n        if I % 3 == 0 && I % 4 != 0 {\n            sum += lst[i] * lst[i];\n        } else if I % 3 != 0 && I % 4 == 0 {\n            sum += lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    sum"], ["/// You are given a string representing a sentence,\n/// the sentence contains some words separated by a space,\n/// and you have to return a string that contains the words from the original sentence,\n/// whose lengths are prime numbers,\n/// the order of the words in the new string should be the same as the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n    let mut words = Vec::new();\n    for word in sentence.chars() {\n        if word.is_alphabetic() {\n            let len = word.len();\n            if len % 2 == 0 {\n                words.push(word.to_string());\n            }\n        }\n    }\n    words.sort_by_key(|word| word.len());\n    words.join(\" \")"], ["/// Your task is to implement a function that will simplify the expression\n/// x * n. The function returns true if x * n evaluates to a whole number and false\n/// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n/// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n/// >>> simplify(String::from(\"1/5\"), String::from(\"5/1\"))\n/// true\n/// >>> simplify(String::from(\"1/6\"), String::from(\"2/1\"))\n/// false\n/// >>> simplify(String::from(\"7/10\"), String::from(\"10/2\"))\n/// false\nfn simplify(x: String, n: String) -> bool {\n    let mut x_num = x.parse::<i64>().unwrap();\n    let mut n_num = n.parse::<i64>().unwrap();\n    let mut result = false;\n    while x_num / n_num > 0 {\n        x_num -= n_num;\n        n_num = n_num / 2;\n        result = true;\n    }\n    result"], ["/// Write a function which sorts the given vector of integers\n/// in ascending order according to the sum of their digits.\n/// Note: if there are several items with similar sum of their digits,\n/// order them based on their index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    let mut sum = 0;\n    for num in nums {\n        sum += num;\n    }\n    sorted_nums.sort_by(|a, b| a.checked_add(sum).unwrap_or(b).cmp(&b.checked_add(sum).unwrap_or(a)));\n    sorted_nums"], ["/// Write a function that takes a vector of numbers as input and returns \n/// the number of elements in the vector that are greater than 10 and both \n/// first and last digits of a number are odd (1, 3, 5, 7, 9).\n/// For example:\n/// >>> specialFilter(vec![15, -73, 14, -15])\n/// 1\n/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n/// 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in nums {\n        if num > 10 && num % 2 == 1 && num.to_string()[0..2].chars().next().unwrap() % 2 == 1 {\n            count += 1;\n        }\n    }\n    count"], ["/// You are given a positive integer n. You have to create an integer vector a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// >>> get_max_triples(5)\n/// 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n    let mut a: Vec<isize> = vec![1; n];\n    a[1] = 3 * a[1] - a[1] + 1;\n    for I in 2..n {\n        a[i] = a[i - 1] + a[i - 2] + a[i - 3];\n    }\n    a.iter().filter(|&x| x % 3 == 0).count()"], ["/// Write a function that accepts a vector of strings as a parameter,\n/// deletes the strings that have odd lengths from it,\n/// and returns the resulted vector with a sorted order,\n/// The vector is always a vector of strings and never a vector of numbers,\n/// and it may contain duplicates.\n/// The order of the vector should be ascending by length of each word, and you\n/// should return the vector sorted by that rule.\n/// If two words have the same length, sort the vector alphabetically.\n/// The function should return a vector of strings in sorted order.\n/// You may assume that all words will have the same length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n/// vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    sorted_lst"], ["/// A simple program which should return the value of x if n is \n/// a prime number and should return the value of y otherwise.\n/// Examples:\n/// >>> x_or_y(7, 34, 12)\n/// 34\n/// >>> x_or_y(15, 8, 5)\n/// 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    if n == 1 {\n        return 0;\n    }\n    if n % 2 == 0 {\n        return x;\n    }\n    if n % 3 == 0 {\n        return y;\n    }\n    x_or_y(n / 2, x, y)"], ["/// Given a vector of numbers, return the sum of squares of the numbers\n/// in the vector that are odd. Ignore numbers that are negative or not integers.\n/// >>> double_the_difference(vec![1, 3, 2, 0])\n/// 10\n/// >>> double_the_difference(vec![-1, -2, 0])\n/// 0\n/// >>> double_the_difference(vec![9, -2])\n/// 81\n/// >>> double_the_difference(vec![0])\n/// 0\n/// If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n    let mut sum = 0;\n    for num in lst {\n        if num % 2 == 1 {\n            sum += num * num;\n        }\n    }\n    sum"], ["/// I think we all remember that feeling when the result of some long-awaited\n/// event is finally known. The feelings and thoughts you have at that moment are\n/// definitely worth noting down and comparing.\n/// Your task is to determine if a person correctly guessed the results of a number of matches.\n/// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n/// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n/// example:\n/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n/// vec![0, 0, 0, 0, 3, 3]\n/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n/// vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![0; game.len()];\n    for (i, score) in game.iter().enumerate() {\n        let guess_score = guess[i];\n        let diff = score - guess_score;\n        result[i] = diff.abs();\n    }\n    result"], ["/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut max_strength = 0;\n    let mut max_extension = String::new();\n    for extension in extensions {\n        let strength = extension.chars().filter(|c| c.is_uppercase()).count() as i32 - extension.chars().filter(|c| c.is_lowercase()).count() as i32;\n        if strength > max_strength {\n            max_strength = strength;\n            max_extension = extension;\n        }\n    }\n    max_extension"], ["/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n/// >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n/// false\n/// >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n/// true\n/// >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n/// false\n/// >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n/// true\n/// >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n/// false\n/// >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n/// true\nfn cycpattern_check(a: String, b: String) -> bool {\n    let mut a_copy = a.clone();\n    let mut b_copy = b.clone();\n    let mut result = true;\n\n    for I in 0..a_copy.len() {\n        for j in 0..b_copy.len() {\n            if a_copy[i] != b_copy[j] {\n                result = false;\n                break;\n            }\n        }\n    }\n\n    result"], ["/// Given an integer. return a tuple that has the number of even and odd digits respectively.\n/// Example:\n/// >>> even_odd_count(-12)\n/// (1, 1)\n/// >>> even_odd_count(123)\n/// (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n    let mut count = 0;\n    let mut sum = 0;\n    let mut digit = 0;\n    let mut remainder = num % 10;\n    while remainder != 0 {\n        digit += 1;\n        remainder /= 10;\n        count += 1;\n    }\n    let mut even_count = count;\n    let mut odd_count = count;\n    while digit != 0 {\n        if digit % 2 == 1 {\n            even_count += 1;\n        }\n        digit /= 10;\n    }\n    (even_count, odd_count)"], ["/// Given a positive integer, obtain its roman numeral equivalent as a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n/// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>> int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n/// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n    while num > 0 {\n        let remainder = num % 10;\n        let roman_numeral = match remainder {\n            0 => \"I\",\n            1 => \"V\",\n            2 => \"X\",\n            3 => \"L\",\n            4 => \"C\",\n            5 => \"D\",\n            _ => panic!(\"Invalid remainder\"),\n        };\n        result.push(roman_numeral.to_lowercase());\n        num /= 10;\n    }\n    result"], ["/// Given the lengths of the three sides of a triangle. Return true if the three\n/// sides form a right-angled triangle, false otherwise.\n/// A right-angled triangle is a triangle in which one angle is right angle or \n/// 90 degree.\n/// Example:\n/// >>> right_angle_triangle(3, 4, 5)\n/// true\n/// >>> right_angle_triangle(1, 2, 3)\n/// false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let a_squared = a * a;\n    let b_squared = b * b;\n    let c_squared = c * c;\n    let a_b_c = a * b * c;\n    let a_c_b = a * c * b;\n    let b_c_a = b * c * a;\n    let c_a_b = c * a * b;\n\n    let a_b_c_squared = a_b_c * a_b_c;\n    let a_c_b_squared = a_c_b * a_c_b;\n    let b_c_a_squared = b_c_a * b_c_a;\n    let c_a_b_squared = c_a_b * c_a_b;\n\n    let a_b_c_squared_over_a_squared = a_b_c_squared / a_squared;\n    let a_c_b_squared_over_a_squared = a_c_b_squared / a_squared;\n    let b_c_a_squared_over_b_squared = b_c_a_squared / b_squared;\n    let c_a_b_squared_over_c_squared = c_a_b_squared / c_squared;\n\n    let a_b_c_squared_over_a_squared_over_a_squared = a_b_c_squared_over_a_squared / a_squared_over_a_squared;\n   "], ["/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count = 0;\n    let mut max_word = String::new();\n    for word in words {\n        let count = word.chars().filter(|c| !c.is_whitespace()).count();\n        if count > max_count {\n            max_count = count;\n            max_word = word;\n        }\n    }\n    max_word"], ["/// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n/// you should return a vector of [ total number of eaten carrots after your meals,\n/// the number of carrots left after your meals ]\n/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n/// >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n/// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n/// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let mut total_eaten = 0;\n    let mut remaining_carrots = 0;\n    while total_eaten < need {\n        remaining_carrots = remaining - total_eaten;\n        if remaining_carrots > 0 {\n            total_eaten += remaining_carrots;\n        } else {\n            break;\n        }\n    }\n    let mut eaten_carrots = total_eaten;\n    let mut remaining_carrots = remaining;\n    while eaten_carrots < remaining_carrots {\n        remaining_carrots -= 1;\n        eaten_carrots += 1;\n    }\n"], ["/// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n/// the second vector is a vector of integers. Use the two given vectors to build the algebric \n/// expression and return the evaluation of this expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// vector = [2, 3, 4, 5]\n/// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator vector is equal to the length of operand vector minus one.\n/// Operand is a vector of of non-negative integers.\n/// Operator vector has at least one operator, and operand vector has at least two operands.\nfn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = 0;\n    for I in 0..(operator.len() - 1) {\n        let op = operator[i];\n        let operand_i = operand[i];\n        match op {\n            \"+\" => result += operand_i,\n            \"-\" => result -= operand_i,\n            \"*\" => result *= operand_i,\n            \"/\" => result /= operand_i,\n            \"**\" => result *= operand_i,\n            _ => panic!(\"Invalid operator: {}\", op),\n        }\n    }\n    result"], ["/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n    let mut reversed = String::new();\n    for c in s.chars() {\n        match c {\n            'a' => reversed.push('A'),\n            'A' => reversed.push('a'),\n            _ => reversed.push(c),\n        }\n    }\n    reversed"], ["/// Given a string 'text', return its md5 hash equivalent string.\n/// If 'text' is an empty string, return None.\n/// >>> string_to_md5(String::from(\"Hello world\"))\n/// Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n    let mut hash = [0u8; 32];\n    let mut iter = text.chars();\n    let mut count = 0;\n    while let Some(c) = iter.next() {\n        hash[count] = c as u8;\n        count += 1;\n    }\n    let mut hash_str = String::from_utf8_lossy(&hash);\n    let mut hash_str_hash = String::from_utf8_lossy(&hash);\n    hash_str_hash.push_str(\":\");\n    hash_str_hash.push_str(&hash_str);\n    Some(hash_str_hash)"], ["/// Given two positive integers a and b, return the even digits between a\n/// and b, in ascending order.\n/// For example:\n/// >>> generate_integers(2, 8)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(8, 2)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(10, 14)\n/// Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current = a;\n    while current <= b {\n        result.push(current);\n        current += 1;\n    }\n    result"]]