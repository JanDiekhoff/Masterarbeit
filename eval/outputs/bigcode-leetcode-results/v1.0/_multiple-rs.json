[["/// Check if in given vector of numbers, are any two numbers closer to each other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    numbers.iter().any(|&x| x - threshold < x)"], ["/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut parens = Vec::new();\n    let mut open_braces = Vec::new();\n    let mut open_parens = Vec::new();\n    let mut close_braces = Vec::new();\n    let mut close_parens = Vec::new();\n\n    for (i, &c) in paren_string.chars().enumerate() {\n        if c == '(' {\n            open_braces.push(i);\n        } else if c == ')' {\n            if open_braces.len() == 0 {\n                open_parens.push(i);\n            } else {\n                close_parens.push(i);\n            }\n        } else if c == '{' {\n            if open_braces.len() == 0 {\n                open_parens.push(i);\n            } else {\n                close_braces.push(i);\n            }\n        } else if c == '}' {\n            if open_parens.len() == 0 {\n                open_braces.push(i);\n            } else {\n                close_parens.push(i);\n            }\n        } else if c == '(' {\n            if open_braces.len() == 0 {\n                open_parens.push(i);\n            } else {\n                close_parens.push(i);\n            }\n        } else if c == ')' {\n            if open_parens.len() == 0 {\n                open_braces.push(i);\n            } else {\n                close_parens.push(i);"], ["/// Given a positive floating point number, it can be decomposed into\n/// and integer part (largest integer smaller than given number) and decimals\n/// (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\n    if number < 0.0 {\n        number = -number;\n    }\n\n    if number < 1.0 {\n        let remainder = number.rem_euclid(1.0);\n        integer_part = remainder.0;\n        decimal_part = remainder.1 / 10.0;\n    } else {\n        let remainder = number.rem_euclid(1.0);\n        integer_part = remainder.0;\n        decimal_part = remainder.1;\n    }\n\n    decimal_part"], ["/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n        balance += op;\n    }\n    balance < 0"], ["/// For a given vector of input numbers, calculate Mean Absolute Deviation\n/// around the mean of this dataset.\n/// Mean Absolute Deviation is the average absolute difference between each\n/// element and a centerpoint (mean in this case):\n/// MAD = average | x - x_mean |\n/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n/// 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    numbers.iter().map(|&x| x - numbers.mean()).sum::<f64>() / numbers.len()"], ["/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// Vec::<isize>::new()\n/// >>> intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for num in numbers {\n        result.push(num);\n    }\n    result.push(delimeter);\n    result"], ["/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    let mut parens = Vec::new();\n    let mut depth = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c == '(' {\n            depth += 1;\n            parens.push(depth);\n        } else if c == ')' {\n            depth -= 1;\n            if depth == 0 {\n                parens.push(depth);\n            }\n        } else {\n            parens.push(depth);\n        }\n    }\n    parens"], ["/// Filter an input vector of strings only for ones that contain given substring\n/// >>> filter_by_substring(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.iter().filter(|s| s.contains(substring)).collect()"], ["/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n/// Empty sum should be equal to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n/// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)"], ["/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut max = 0;\n    let mut max_index = 0;\n    for num in numbers.iter().rev() {\n        if *num > max {\n            max = *num;\n            max_index = max_index.wrapping_add(1);\n        }\n    }\n    let mut result = Vec::new();\n    for _ in 0..max_index {\n        result.push(max);\n    }\n    result"], ["/// Find the shortest palindrome that begins with a supplied string.\n/// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that is a palindrome.\n/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n/// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n/// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n    let mut longest_prefix = String::new();\n    let mut longest_postfix = String::new();\n    let mut prefix = String::new();\n    let mut postfix = String::new();\n    let mut prefix_length = 0;\n    let mut postfix_length = 0;\n    let mut palindrome = String::new();\n\n    for c in string.chars() {\n        if c.is_alphabetic() {\n            if c.to_ascii_lowercase() == prefix.to_ascii_lowercase() {\n                prefix_length += 1;\n            } else {\n                prefix.push(c);\n                prefix_length = 1;\n            }\n        } else {\n            if c.to_ascii_lowercase() == postfix.to_ascii_lowercase() {\n                postfix_length += 1;\n            } else {\n                postfix.push(c);\n                postfix_length = 1;\n            }\n        }\n    }\n\n    let mut longest_prefix_length = 0;\n    let mut longest_postfix_length = 0;\n    let mut longest_palindrome_length = 0;\n\n    for c in prefix.chars() {\n        if c.is_alphabetic() {\n            if c.to_ascii_lowercase() == longest_prefix.to_ascii_lowercase() {\n                longest_prefix_length += 1;\n            } else {\n                longest_prefix.push(c);\n"], ["/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n    let mut result = String::new();\n    for (i, &c) in a.chars().enumerate() {\n        if c == b[i] {\n            result.push(c);\n        } else {\n            result.push('0');\n        }\n    }\n    result"], ["/// Out of vector of strings, return the longest one. Return the first one in case of multiple\n/// strings of the same length. Return None in case the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n    strings.sort_by(|a, b| a.len().cmp(&b.len()))\n        .last()\n        .map(|s| s.to_string())"], ["/// Return a greatest common divisor of two integers a and b\n/// >>> greatest_common_divisor(3, 5)\n/// 1\n/// >>> greatest_common_divisor(25, 15)\n/// 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n    if a == 0 {\n        return b;\n    }\n    let mut gcd = a;\n    for _ in 0..b {\n        gcd = gcd.div(b);\n    }\n    gcd"], ["/// Return vector of all prefixes from shortest to longest of the input string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n    string.split_whitespace().filter(|s| !s.is_empty()).collect()"], ["/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n/// >>> string_sequence(0)\n/// String::from(\"0\")\n/// >>> string_sequence(5)\n/// String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n    let mut s = String::new();\n    for _ in 0..n {\n        s.push(format!(\"{}\", rand::random::<u32>() % 10));\n    }\n    s"], ["/// Given a string, find out how many distinct characters (regardless of case) does it consist of\n/// >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n/// 3\n/// >>> count_distinct_characters(String::from(\"Jerry\"))\n/// 4\nfn count_distinct_characters(string: String) -> isize {\n    string.chars().filter(|c| !c.is_ascii_alphabetic()).count()"], ["/// Input to this function is a string representing musical notes in a special ASCII format.\n/// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n/// not last.\n/// Here is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note, lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n    let mut notes = Vec::new();\n    for note in music_string.chars() {\n        match note {\n            'o' => notes.push(1),\n            'o|' => notes.push(2),\n            '.' => notes.push(1),\n            '.' | 'o' => notes.push(2),\n            _ => panic!(\"Invalid note\"),\n        }\n    }\n    notes"], ["/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let mut current_index = 0;\n    for (i, c) in string.chars().enumerate() {\n        if c == substring[index] {\n            count += 1;\n            index += 1;\n            current_index = i;\n        } else {\n            current_index = 0;\n        }\n        if current_index == substring.len() {\n            break;\n        }\n    }\n    count"], ["/// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n/// Return the string with numbers sorted from smallest to largest\n/// >>> sort_numbers(String::from(\"three one five\"))\n/// String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n    numbers.chars().map(|c| c.to_digit().unwrap()).collect()"], ["/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut min_index = 0;\n    for (i, n) in numbers.iter().enumerate() {\n        let distance = n - &numbers[i];\n        if distance < min_distance {\n            min_distance = distance;\n            min_index = i;\n        }\n    }\n    (numbers[min_index], numbers[min_index + 1])"], ["/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let mut rescaled = Vec::new();\n    for num in numbers {\n        let scale = 1.0 / num;\n        rescaled.push(scale);\n    }\n    rescaled"], ["/// Return length of given string\n/// >>> strlen(String::from(\"\"))\n/// 0\n/// >>> strlen(String::from(\"abc\"))\n/// 3\nfn strlen(string: String) -> isize {\n    string.len()"], ["/// For a given number n, find the largest number that divides n evenly, smaller than n\n/// >>> largest_divisor(15)\n/// 5\nfn largest_divisor(n: isize) -> isize {\n    if n < 0 {\n        panic!(\"Negative number is not allowed\");\n    }\n    let mut count = 0;\n    for i in 1..=n {\n        if n % i == 0 {\n            count += 1;\n        }\n    }\n    count"], ["/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let mut i = 1;\n    while n > 1 {\n        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n        }\n        i += 2;\n    }\n    factors"], ["/// From a vector of integers, remove all elements that occur more than once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n/// vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    numbers.into_iter().filter(|x| *x != 1).collect()"], ["/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n/// >>> flip_case(String::from(\"Hello\"))\n/// String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n    string.chars().map(|c| c.to_ascii_uppercase()).collect()"], ["/// Concatenate vector of strings into a single string\n/// >>> concatenate(vec![])\n/// String::from(\"\")\n/// >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n    strings.join(\"\")"], ["/// Filter an input vector of strings only for ones that start with a given prefix.\n/// >>> filter_by_prefix(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.iter().filter(|s| s.starts_with(prefix)).collect()"], ["/// Return only positive numbers in the vector.\n/// >>> get_positive(vec![-1, 2, -4, 5, 6])\n/// vec![2, 5, 6]\n/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.iter().filter(|&x| x > 0).cloned().collect()"], ["/// Return true if a given number is prime, and false otherwise.\n/// >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n/// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n/// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n: isize) -> bool {\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        i += 1;\n    }\n    return true;"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n/// to the values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n/// vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l.clone();\n    l.sort_by(|a, b| a.cmp(b));\n    l"], ["/// Return sorted unique elements in a vector\n/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().unique().collect()"], ["/// Return maximum element in the vector.\n/// >>> max_element(vec![1, 2, 3])\n/// 3\n/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// 123\nfn max_element(l: Vec<isize>) -> isize {\n    let mut max = l[0];\n    for i in 1..l.len() {\n        if l[i] > max {\n            max = l[i];\n        }\n    }\n    max"], ["/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n/// >>> fizz_buzz(50)\n/// 0\n/// >>> fizz_buzz(78)\n/// 2\n/// >>> fizz_buzz(79)\n/// 3\nfn fizz_buzz(n: isize) -> isize {\n    if n % 11 == 7 || n % 13 == 7 {\n        return 3;\n    }\n    return 2;"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>> sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3, 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted = Vec::new();\n    for i in 0..l.len() {\n        if l[i] % 2 == 0 {\n            sorted.push(l[i]);\n        }\n    }\n    sorted"], ["/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n/// >>> prime_fib(1)\n/// 2\n/// >>> prime_fib(2)\n/// 3\n/// >>> prime_fib(3)\n/// 5\n/// >>> prime_fib(4)\n/// 13\n/// >>> prime_fib(5)\n/// 89\nfn prime_fib(n: isize) -> isize {\n    let mut fib = 0;\n    let mut i = 1;\n    while i <= n {\n        fib = fib + i;\n        i += 1;\n    }\n    fib"], ["/// triples_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are three distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n/// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let mut sum = 0;\n    for num in l {\n        sum += num;\n    }\n    sum == 0"], ["/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n    let mut collisions = 0;\n    for I in 0..n {\n        for j in 0..n {\n            if i != j {\n                if cars_collide(i, j) {\n                    collisions += 1;\n                }\n            }\n        }\n    }\n    collisions"], ["/// Return vector with elements incremented by 1.\n/// >>> incr_list(vec![1, 2, 3])\n/// vec![2, 3, 4]\n/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|&x| x + 1).collect()"], ["/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    let mut sum = 0;\n    for num in l {\n        sum += num;\n    }\n    sum == 0"], ["/// Change numerical base of input number x to base.\n/// return string representation after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n/// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n    let mut num = x;\n    let mut base_num = base;\n\n    while num > 0 {\n        let remainder = num % base_num;\n        result.push_str(&format!(\"{:0*2}{}\", remainder, base_num));\n        num /= base_num;\n    }\n\n    result"], ["/// Given length of a side and high return area for a triangle.\n/// >>> triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n    let mut area = 0.0;\n    area += (a * h) / 2.0;\n    area += (h * h) / 2.0;\n    area"], ["/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fib4(0) -> 0\n/// fib4(1) -> 0\n/// fib4(2) -> 2\n/// fib4(3) -> 0\n/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n/// >>> fib4(5)\n/// 4\n/// >>> fib4(6)\n/// 8\n/// >>> fib4(7)\n/// 14\nfn fib4(n: isize) -> isize {\n    if n < 0 {\n        panic!(\"Invalid input: n must be a positive integer\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 0;\n    }\n    let mut fib = 0;\n    fib += fib4(n - 1);\n    fib += fib4(n - 2);\n    fib += fib4(n - 3);\n    fib += fib4(n - 4);\n    fib"], ["/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1, 2, 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l: Vec<isize>) -> f64 {\n    l.iter().fold(0.0, |acc, &x| acc + x) / l.len()"], ["/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>> is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().eq(text.chars())"], ["/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n    let mut r = 1;\n    let mut i = 0;\n    while i < n {\n        r = r * p % p;\n        i += 1;\n    }\n    r"], ["/// remove_vowels is a function that takes string and returns string without vowels.\n/// >>> remove_vowels(String::from(\"\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"abcdef\"))\n/// String::from(\"bcdf\")\n/// >>> remove_vowels(String::from(\"aaaaa\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"aaBAA\"))\n/// String::from(\"B\")\n/// >>> remove_vowels(String::from(\"zbcd\"))\n/// String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n    text.chars().filter(|c| !c.is_ascii_alphabetic()).collect()"], ["/// Return true if all numbers in the vector l are below threshold t.\n/// >>> below_threshold(vec![1, 2, 4, 10], 100)\n/// true\n/// >>> below_threshold(vec![1, 20, 4, 10], 5)\n/// false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)"], ["/// Add two numbers x and y\n/// >>> add(2, 3)\n/// 5\n/// >>> add(5, 7)\n/// 12\nfn add(x: isize, y: isize) -> isize {\n    x + y"], ["/// Check if two words have the same characters.\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n/// true\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n/// true\n/// >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n/// true\n/// >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n/// false\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n/// false\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n/// false\nfn same_chars(s0: String, s1: String) -> bool {\n    s0.chars().all(|c| s1.chars().any(|c2| c == c2))"], ["/// Return n-th Fibonacci number.\n/// >>> fib(10)\n/// 55\n/// >>> fib(1)\n/// 1\n/// >>> fib(8)\n/// 21\nfn fib(n: isize) -> isize {\n    if n < 0 {\n        panic!(\"Fibonacci number must be positive\");\n    }\n    fib(n - 1) + fib(n - 2)"], ["/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"<\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut bracket_count = 0;\n    let mut bracket_stack = vec![];\n    for c in brackets.chars() {\n        match c {\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '>' => bracket_stack.push(bracket_stack.len() - 1),\n            '<' => bracket_stack.pop(),\n            '"], ["/// Return true is vector elements are monotonically increasing or decreasing.\n/// >>> monotonic(vec![1, 2, 4, 20])\n/// true\n/// >>> monotonic(vec![1, 20, 4, 10])\n/// false\n/// >>> monotonic(vec![4, 1, 0, -10])\n/// true\nfn monotonic(l: Vec<isize>) -> bool {\n    l.iter().cloned().all(|x| x > 0)"], ["/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut common = Vec::new();\n    let mut i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            common.push(l1[i]);\n            i += 1;\n        } else {\n            break;\n        }\n    }\n    common"], ["/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n/// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n/// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut largest = n;\n    for I in 2..=n / 2 {\n        if n % I == 0 {\n            largest = i;\n        }\n    }\n    largest"], ["/// sum_to_n is a function that sums numbers from 1 to n.\n/// >>> sum_to_n(30)\n/// 465\n/// >>> sum_to_n(100)\n/// 5050\n/// >>> sum_to_n(5)\n/// 15\n/// >>> sum_to_n(10)\n/// 55\n/// >>> sum_to_n(1)\n/// 1\nfn sum_to_n(n: isize) -> isize {\n    let mut sum = 0;\n    for I in 1..=n {\n        sum += I;\n    }\n    sum"], ["/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"(\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n/// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\")(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut brackets = brackets.split(\",\").collect::<Vec<&str>>();\n    let mut brackets_stack = Vec::new();\n    let mut bracket_stack = Vec::new();\n    let mut bracket_count = 0;\n\n    for bracket in brackets {\n        if bracket.is_empty() {\n            bracket_stack.push(bracket_count);\n            bracket_count += 1;\n        } else {\n            let bracket_stack_top = bracket_stack.pop().unwrap();\n            let bracket_stack_bottom = bracket_stack.pop().unwrap();\n            if bracket_stack_top == bracket_stack_bottom {\n                bracket_stack.push(bracket_count);\n                bracket_count += 1;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    brackets_stack.pop();\n    bracket_stack.pop();\n\n    brackets_stack.is_empty() && bracket_stack.is_empty()"], ["/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n/// >>> derivative(vec![3, 1, 2, 4, 5])\n/// vec![1, 4, 12, 20]\n/// >>> derivative(vec![1, 2, 3])\n/// vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    xs.iter().map(|&x| x.pow(xs.len() - 1)).collect()"], ["/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fibfib(0) == 0\n/// fibfib(1) == 0\n/// fibfib(2) == 1\n/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n/// >>> fibfib(1)\n/// 0\n/// >>> fibfib(5)\n/// 4\n/// >>> fibfib(8)\n/// 24\nfn fibfib(n: isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)"], ["/// Write a function vowels_count which takes a string representing\n/// a word as input and returns the number of vowels in the string.\n/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s: String) -> isize {\n    s.chars().filter(|c| c.is_ascii_alphabetic()).count()"], ["/// Circular shift the digits of the integer x, shift the digits right by shift\n/// and return the result as a string.\n/// If shift > number of digits, return digits reversed.\n/// >>> circular_shift(12, 1)\n/// String::from(\"21\")\n/// >>> circular_shift(12, 2)\n/// String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits = x.to_string();\n    let mut shifted_digits = String::new();\n    let mut shift = 0;\n    while shift < shift + 1 {\n        shifted_digits.push(digits.chars().nth(shift).unwrap());\n        shift += 1;\n    }\n    shifted_digits"], ["/// Task\n/// Write a function that takes a string as input and returns the sum of the upper characters only'\n/// ASCII codes.\n/// Examples:\n/// >>> digitSum(String::from(\"\"))\n/// 0\n/// >>> digitSum(String::from(\"abAB\"))\n/// 131\n/// >>> digitSum(String::from(\"abcCd\"))\n/// 67\n/// >>> digitSum(String::from(\"helloE\"))\n/// 69\n/// >>> digitSum(String::from(\"woArBld\"))\n/// 131\n/// >>> digitSum(String::from(\"aAaaaXa\"))\n/// 153\nfn digitSum(s: String) -> isize {\n    s.chars().filter(|c| c.is_ascii_digit()).fold(0, |acc, c| acc + c.to_digit(10).unwrap())"], ["/// In this task, you will be given a string that represents a number of apples and oranges \n/// that are distributed in a basket of fruit this basket contains \n/// apples, oranges, and mango fruits. Given the string that represents the total number of \n/// the oranges and apples and an integer that represent the total number of the fruits \n/// in the basket return the number of the mango fruits in the basket.\n/// for examble:\n/// >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n/// 8\n/// >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n/// 2\n/// >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n/// 95\n/// >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n/// 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n    let mut fruit_count = 0;\n    let mut fruit_total = 0;\n    for c in s.chars() {\n        if c == 'a' || c == 'o' || c == 'm' {\n            fruit_total += n;\n        } else {\n            fruit_count += 1;\n        }\n    }\n    fruit_total - fruit_count"], ["/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr.clone();\n    let mut min_index = arr.len();\n    let mut min_value = arr[0];\n    for i in 1..arr.len() {\n        if arr[i] < min_value {\n            min_index = i;\n            min_value = arr[i];\n        }\n    }\n    let mut result = vec![];\n    for i in 0..min_index {\n        result.push(arr[i]);\n    }\n    result"], ["/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n/// zero, and has a frequency greater than or equal to the value of the integer itself. \n/// The frequency of an integer is the number of times it appears in the vector.\n/// If no such a value exist, return -1.\n/// Examples:\n/// >>> search(vec![4, 1, 2, 2, 3, 1])\n/// 2\n/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n/// 3\n/// >>> search(vec![5, 5, 4, 4, 4])\n/// -1\nfn search(lst: Vec<isize>) -> isize {\n    let mut freq = 0;\n    let mut max = 0;\n    for num in lst {\n        if num > 0 && freq < num {\n            freq = num;\n            max = num;\n        }\n    }\n    if freq > 0 {\n        max\n    } else {\n        -1\n    }"], ["/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort_unstable();\n    sorted_lst"], ["/// Given the lengths of the three sides of a triangle. Return the area of\n/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum of any two sides is greater \n/// than the third side.\n/// Example:\n/// >>> triangle_area(3, 4, 5)\n/// 6.0\n/// >>> triangle_area(1, 2, 10)\n/// -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    let sum = a + b + c;\n    let half_sum = sum / 2.0;\n    let sqrt_half_sum = sqrt(half_sum);\n    let area = (sqrt_half_sum * sqrt_half_sum) / 3.0;\n    area"], ["/// Write a function that returns true if the object q will fly, and false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n/// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>> will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n/// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for i in 0..q.len() {\n        sum += q[i];\n        if sum > w {\n            return false;\n        }\n    }\n    true"], ["/// Given a vector arr of integers, find the minimum number of elements that\n/// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n/// is read the same backwards and forwards. In one change, you can change one element to any other element.\n/// For example:\n/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n/// 4\n/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n/// 1\n/// >>> smallest_change(vec![1, 2, 3, 2, 1])\n/// 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n    let mut min_change = 0;\n    let mut min_index = 0;\n    for i in 0..arr.len() {\n        if arr[i] != arr[arr.len() - i - 1] {\n            min_change += 1;\n            min_index = i;\n        }\n    }\n    min_change"], ["/// Write a function that accepts two vectors of strings and returns the vector that has \n/// total number of chars in the all strings of the vector less than the other vector.\n/// if the two vectors have the same number of chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n/// Vec::<String>::new()\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n/// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n/// >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let mut lst = lst1.clone();\n    let mut lst2 = lst2.clone();\n    let mut total = 0;\n    while lst.len() > lst2.len() {\n        total += lst.len();\n        lst.pop();\n        lst2.pop();\n    }\n    lst.iter().zip(&lst2).map(|(a, b)| a.to_string() + b.to_string()).collect()"], ["/// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n/// and false otherwise.\n/// Knowing that (a) is less then 100. \n/// Example:\n/// >>> is_multiply_prime(30)\n/// true\n/// 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n    let mut num = a;\n    let mut is_prime = true;\n    let mut is_prime_2 = true;\n    let mut is_prime_3 = true;\n    let mut is_prime_4 = true;\n    let mut is_prime_5 = true;\n    let mut is_prime_6 = true;\n    let mut is_prime_7 = true;\n    let mut is_prime_8 = true;\n    let mut is_prime_9 = true;\n    let mut is_prime_10 = true;\n    let mut is_prime_11 = true;\n    let mut is_prime_12 = true;\n    let mut is_prime_13 = true;\n    let mut is_prime_14 = true;\n    let mut is_prime_15 = true;\n    let mut is_prime_16 = true;\n    let mut is_prime_17 = true;\n    let mut is_prime_18 = true;\n    let mut is_prime_19 = true;\n    let mut is_prime_20 = true;\n    let mut is_prime_21 = true;\n    let mut is_prime_22 = true;\n    let mut is_prime_23 = true;\n    let mut is_prime_24 = true;\n    let mut is_prime_25 = true;\n    let mut is_prime_26 = true;\n    let mut is_prime_27 = true;\n    let mut is_prime_28 = true;\n    let mut is_prime_29 = true;\n    let mut is_prime_30 = true;\n\n    while num > 1 {\n        if num % 2 == 0 {\n            is_prime_2 = false;\n"], ["/// Your task is to write a function that returns true if a number x is a simple\n/// power of n and false in other cases.\n/// x is a simple power of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n/// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n/// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n/// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return false;\n    }\n    if x == 0 {\n        return false;\n    }\n    if x % n == 0 {\n        return true;\n    }\n    is_simple_power(x / n, n)"], ["/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    a.powi(3) == a"], ["/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c.to_digit(10) == Some(2) {\n            count += 1;\n        }\n    }\n    count"], ["/// You will be given a number in decimal form and your task is to convert it to\n/// binary format. The function should return a string, with each character representing a binary\n/// number. Each character in the string will be '0' or '1'.\n/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n/// The extra characters are there to help with the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n    let mut binary = String::new();\n    let mut decimal_str = String::from(format!(\"{:06b}\", decimal));\n    let mut i = 0;\n    while i < decimal_str.len() {\n        binary.push(if decimal_str[i] == '1' { '1' } else { '0' });\n        i += 1;\n    }\n    binary"], ["/// You are given a string s.\n/// Your task is to check if the string is haprs or not.\n/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(String::from(\"a\"))\n/// false\n/// >>> is_happy(String::from(\"aa\"))\n/// false\n/// >>> is_happy(String::from(\"abcd\"))\n/// true\n/// >>> is_happy(String::from(\"aabb\"))\n/// false\n/// >>> is_happy(String::from(\"adb\"))\n/// true\n/// >>> is_happy(String::from(\"xyy\"))\n/// false\nfn is_happy(s: String) -> bool {\n    let mut stack = Vec::new();\n    let mut visited = Vec::new();\n    for c in s.chars() {\n        if visited.contains(&c) {\n            continue;\n        }\n        visited.push(c);\n        if stack.len() == 0 {\n            return false;\n        }\n        if stack.pop().unwrap() == c {\n            continue;\n        }\n        stack.push(c);\n    }\n    visited.pop();\n    visited.is_empty()"], ["/// It is the last week of the semester and the teacher has to give the grades\n/// to students. The teacher has been making her own algorithm for grading.\n/// The only problem is, she has lost the code she used for grading.\n/// She has given you a vector of GPAs for some students and you have to write \n/// a function that can output a vector of letter grades using the following table:\n/// GPA       |    Letter grade\n/// 4.0                A+\n/// > 3.7                A \n/// > 3.3                A- \n/// > 3.0                B+\n/// > 2.7                B \n/// > 2.3                B-\n/// > 2.0                C+\n/// > 1.7                C\n/// > 1.3                C-\n/// > 1.0                D+ \n/// > 0.7                D \n/// > 0.0                D-\n/// 0.0                E\n/// Example:\n/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n/// vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    let mut letter_grades = vec![];\n    for grade in grades {\n        if grade >= 3.7 {\n            letter_grades.push(String::from(\"A+\"));\n        } else if grade >= 3.3 {\n            letter_grades.push(String::from(\"A\"));\n        } else if grade >= 3.0 {\n            letter_grades.push(String::from(\"A-\"));\n        } else if grade >= 2.7 {\n            letter_grades.push(String::from(\"B+\"));\n        } else if grade >= 2.3 {\n            letter_grades.push(String::from(\"B\"));\n        } else if grade >= 2.0 {\n            letter_grades.push(String::from(\"B-\"));\n        } else"], ["/// Write a function that takes a string and returns true if the string\n/// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n/// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut count = 0;\n    for char in string.chars() {\n        if char.is_digit(10) {\n            count += 1;\n        }\n    }\n    count == 2"], ["/// Given a positive integer n, return the count of the numbers of n-digit\n/// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) -> isize {\n    let mut count = 0;\n    for I in 1..=n {\n        if i % 2 == 1 {\n            count += 1;\n        }\n    }\n    count"], ["/// Given a positive integer N, return the total sum of its digits in binary.\n/// Example\n/// >>> solve(1000)\n/// String::from(\"1\")\n/// >>> solve(150)\n/// String::from(\"110\")\n/// >>> solve(147)\n/// String::from(\"1100\")\n/// Variables:\n/// @N integer\n/// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary number\nfn solve(N: isize) -> String {\n    let mut sum = 0;\n    for I in 0..N {\n        let digit = (N - i) as u8;\n        sum += digit as u8;\n    }\n    String::from(sum.to_string())"], ["/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n/// Examples:\n/// >>> add(vec![4, 2, 6, 7])\n/// 2\nfn add(lst: Vec<isize>) -> isize {\n    lst.iter().filter(|&x| x % 2 == 1).sum()"], ["/// Write a function that takes a string and returns an ordered version of it.\n/// Ordered version of string, is a string where all words (separated by space)\n/// are replaced by a new word where all the characters arranged in\n/// ascending order based on ascii value.\n/// Note: You should keep the order of words and blank spaces in the sentence.\n/// For example:\n/// >>> anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n    s.chars().map(|c| c.to_ascii_lowercase().to_string()).collect()"], ["/// You are given a 2 dimensional data, as a nested vectors,\n/// which is similar to matrix, however, unlike matrices,\n/// each row may contain a different number of columns.\n/// Given lst, and integer x, find integers x in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize, isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut lst_vec = lst.clone();\n    let mut sorted_lst_vec = lst_vec.clone();\n    sorted_lst_vec.sort_by(|a, b| a.1.cmp(&b.1));\n    sorted_lst_vec.sort_by(|a, b| a.0.cmp(&b.0));\n    let mut sorted_lst_vec_vec = sorted_lst_vec.clone();\n    sorted_lst_vec_vec.sort_by(|a, b| a.0.cmp(&b.0));\n    let mut sorted_lst_vec_vec_vec = sorted_lst_vec_vec.clone();\n    sorted_lst_vec_vec_vec.sort_by(|a, b| a.1"], ["/// Given a vector of non-negative integers, return a cors of the given vector after sorting,\n/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n/// or sort it in descending order if the sum( first index value, last index value) is even.\n/// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n/// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n    sorted_array.sort_by(|a, b| a.cmp(b));\n    sorted_array"], ["/// Create a function encrypt that takes a string as an argument and\n/// returns a string encrypted with the alphabet being rotated. \n/// The alphabet should be rotated in a manner such that the letters \n/// shift down by two multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n/// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s: String) -> String {\n    let mut s = s.to_lowercase();\n    s.chars().rev().for_each(|c| {\n        let mut shift = 2;\n        if c.to_ascii_lowercase() == 'a' {\n            shift -= 2;\n        }\n        s.insert(c.to_ascii_lowercase() as usize - shift, ' ');\n    });\n    s"], ["/// You are given a vector of integers.\n/// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n/// Return None if there is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n/// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n/// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    lst.iter().find(|&x| x < lst.iter().next().unwrap())"], ["/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut count = 0;\n    for s in S.chars() {\n        if s == '.' || s == '?' || s == '!' {\n            count += 1;\n        }\n    }\n    count"], ["/// Create a function that takes 3 numbers.\n/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n/// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n/// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n/// true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    x + y + z == (x + y) + z"], ["/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n    let mut result = message.to_lowercase();\n    for (i, c) in message.chars().enumerate() {\n        if c.is_vowel() {\n            result.insert(i, c.to_lowercase());\n        } else {\n            result.insert(i, c.to_uppercase());\n        }\n    }\n    result"], ["/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for num in lst {\n        if num > 1 {\n            sum += num;\n        }\n    }\n    sum"], ["use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().all(|(key, value)| {\n        if key.to_lowercase() == value.to_lowercase() {\n            return true;\n        }\n        return false;\n    })"], ["/// Implement a function that takes an non-negative integer and returns a vector of the first n\n/// integers that are prime numbers and less than n.\n/// for example:\n/// >>> count_up_to(5)\n/// vec![2, 3]\n/// >>> count_up_to(11)\n/// vec![2, 3, 5, 7]\n/// >>> count_up_to(0)\n/// Vec::<isize>::new()\n/// >>> count_up_to(20)\n/// vec![2, 3, 5, 7, 11, 13, 17, 19]\n/// >>> count_up_to(1)\n/// Vec::<isize>::new()\n/// >>> count_up_to(18)\n/// vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n    let mut count = Vec::new();\n    let mut i = 2;\n    while i <= n {\n        if is_prime(i) {\n            count.push(i);\n        }\n        i += 2;\n    }\n    count"], ["/// Complete the function that takes two integers and returns \n/// the product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n/// >>> multiply(148, 412)\n/// 16\n/// >>> multiply(19, 28)\n/// 72\n/// >>> multiply(2020, 1851)\n/// 0\n/// >>> multiply(14, -15)\n/// 20\nfn multiply(a: isize, b: isize) -> isize {\n    let mut product = 1;\n    for I in 1..=b {\n        product *= a;\n        a *= 10;\n    }\n    product"], ["/// Given a string s, count the number of uppercase vowels in even indices.\n/// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>> count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n    for i in 0..s.len() {\n        if s[i] == 'A' || s[i] == 'a' {\n            count += 1;\n        }\n    }\n    count"], ["/// Create a function that takes a value (string) representing a number\n/// and returns the closest integer to it. If the number is equidistant\n/// from two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n/// Rounding away from zero means that if the given number is equidistant\n/// from two integers, the one you should return is the one that is the\n/// farthest from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n    let mut value = value.trim();\n    let mut value_int = value.parse::<isize>().unwrap();\n    let mut value_int_2 = value_int.clone();\n    let mut value_int_2_int = value_int_2.clone();\n    let mut value_int_2_int_2 = value_int_2_int.clone();\n    let mut value_int_2_int_2_int = value_int_2_int_2.clone();\n    let mut value_int_2_int_2_int_2 = value_int_2_int_2_int.clone();\n    let mut value_int_2_int_2_int_2_int = value_int_2_int_2_int_2.clone();\n    let mut value_int_2_int_2_int_2_int_2 = value_int_2_int_2_int_2.clone();\n    let mut value_int_2_int_2_int_2_int_2_int = value_int_2_int_2_int_2_int_2.clone();\n    let mut value_int_2_int_2_int_2_int_2_int_2_int = value_int_2_int_2_int_2_int_2_int.clone();\n    let mut value_int_2_int_"], ["/// Given a positive integer n, you have to make a pile of n levels of stones.\n/// The first level has n stones.\n/// The number of stones in the next level is:\n/// - the next odd number if n is odd.\n/// - the next even number if n is even.\n/// Return the number of stones in each level in a vector, where element at index\n/// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>> make_a_pile(3)\n/// vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut result = vec![0; n + 1];\n    result[0] = 1;\n    for i in 1..=n {\n        result[i] = result[i - 1] + 1;\n    }\n    result"], ["/// You will be given a string of words separated by commas or spaces. Your task is\n/// to split the string into words and return a vector of the words.\n/// For example:\n/// >>> words_string(String::from(\"Hi, my name is John\"))\n/// vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n/// >>> words_string(String::from(\"One, two, three, four, five, six\"))\n/// vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n    s.split(\",\").map(|s| s.trim()).collect()"], ["/// This function takes two positive numbers x and y and returns the\n/// biggest even integer number that is in the range [x, y] inclusive. If \n/// there's no such number, then the function should return -1.\n/// For example:\n/// >>> choose_num(12, 15)\n/// 14\n/// >>> choose_num(13, 12)\n/// -1\nfn choose_num(x: isize, y: isize) -> isize {\n    let mut x_min = x;\n    let mut y_min = y;\n    let mut x_max = x;\n    let mut y_max = y;\n\n    while x_min <= x_max && y_min <= y_max {\n        let mid = (x_min + x_max) / 2;\n        if mid >= y {\n            x_max = mid;\n        } else {\n            y_max = mid;\n        }\n    }\n\n    if x_min <= x_max && y_min <= y_max {\n        choose_num(x_min, y_min) + choose_num(x_min, y_max)\n    } else {\n        -1\n    }"], ["/// Given a vector of positive integers x. return a sorted vector of all \n/// elements that hasn't any even digit.\n/// Note: Returned vector should be sorted in increasing order.\n/// For example:\n/// >>> unique_digits(vec![15, 33, 1422, 1])\n/// vec![1, 15, 33]\n/// >>> unique_digits(vec![152, 323, 1422, 10])\n/// Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    x.iter().filter(|&x| !x.is_even()).cloned().collect()"], ["/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n/// reverse the resulting vector, and then replace each digit by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty, return an empty vector:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n/// If the vector has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = Vec::new();\n    for num in arr {\n        let mut name = String::from(format!(\"{}\", num));\n        if name.len() > 1 {\n            name.pop();\n        }\n        res.push(name);\n    }\n    res"], ["/// Implement the function f that takes n as a parameter,\n/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n/// or the sum of numbers from 1 to i otherwise.\n/// i starts from 1.\n/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n/// Example:\n/// >>> f(5)\n/// vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n    let mut result = vec![1];\n    for I in 1..=n {\n        result.push(i.powi(i - 1));\n    }\n    result"], ["/// Given a positive integer n, return a tuple that has the number of even and odd\n/// integer palindromes that fall within the range(1, n), inclusive.\n/// Example 1:\n/// >>> even_odd_palindrome(3)\n/// (1, 2)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n/// Example 2:\n/// >>> even_odd_palindrome(12)\n/// (4, 6)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n/// Note:\n/// 1. 1 <= n <= 10^3\n/// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_odd = vec![0; n];\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;\n    let mut odd_odd_sum = 0;\n    let mut even_odd_sum = 0;"], ["/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in arr {\n        if num > 0 && num.signum() > 0 {\n            count += 1;\n        }\n    }\n    count"], ["/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n/// numbers in the vector will be randomly ordered. Your task is to determine if\n/// it is possible to get a vector sorted in non-decreasing order by performing \n/// the following operation on the given vector:\n/// You are allowed to perform right shift operation any number of times.\n/// One right shift operation means shifting all elements of the vector by one\n/// position in the right direction. The last element of the vector will be moved to\n/// the starting position in the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector by performing the above operation\n/// then return true else return false.\n/// If the given vector is empty then return true.\n/// Note: The given vector is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3, 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations, non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3, 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing order for the given\n/// vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut arr = arr;\n    let mut arr_len = arr.len();\n    let mut arr_shift = 0;\n\n    while arr_shift < arr_len {\n        arr.swap(arr_shift, arr_shift + 1);\n        arr_shift += 1;\n    }\n\n    arr.sort();\n\n    arr.len() == arr.iter().cloned().collect::<Vec<isize>>().len()"], ["/// In this problem, you will implement a function that takes two vectors of numbers,\n/// and determines whether it is possible to perform an exchange of elements\n/// between them to make lst1 a vector of only even numbers.\n/// There is no limit on the number of exchanged elements between lst1 and lst2.\n/// If it is possible to exchange elements between the lst1 and lst2 to make\n/// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return \"NO\".\n/// For example:\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n/// String::from(\"YES\")\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n/// String::from(\"NO\")\n/// It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    if lst1.len() != lst2.len() {\n        return String::from(\"NO\");\n    }\n    let mut lst1_copy = lst1.clone();\n    let mut lst2_copy = lst2.clone();\n    for i in 0..lst1.len() {\n        for j in 0..lst2.len() {\n            if lst1_copy[i] == lst2_copy[j] {\n                lst1_copy[i] = lst1_copy[i] % 2;\n                lst2_copy[j] = lst2_copy[j] % 2;\n            }\n        }\n    }\n    if lst1_copy.len() == 0 {\n        return String::from(\"YES\");\n    } else {\n        return String::from(\"NO\");\n    }"], ["use std::collections::HashMap;\n\n/// Given a string representing a space separated lowercase letters, return a HashMap\n/// of the letter with the most repetition and containing the corresponding count.\n/// If several letters have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut h = HashMap::new();\n    for c in test.chars() {\n        let count = h.entry(c).or_insert(0);\n        *count += 1;\n    }\n    h"], ["/// Task\n/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n/// then check if the result string is palindrome.\n/// A string is called palindrome if it reads the same backward as forward.\n/// You should return a tuple containing the result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n    let mut s = s.to_string();\n    let mut c = c.to_string();\n    let mut result = String::new();\n    let mut is_palindrome = true;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len() && j < c.len() {\n        if s[i] == c[j] {\n            result.push(s[i]);\n            i += 1;\n            j += 1;\n        } else {\n            is_palindrome = false;\n            break;\n        }\n    }\n    (result, is_palindrome)"], ["/// Given a vector of strings, where each string consists of only digits, return a vector.\n/// Each element i of the output should be \"the number of odd elements in the\n/// string i of the input.\" where all the i's should be replaced by the number\n/// of odd digits in the i'th string of the input.\n/// >>> odd_count(vec![String::from(\"1234567\")])\n/// vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n/// >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n/// vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter().filter(|&x| x.len() % 2 == 1).map(|x| x.to_string()).collect()"], ["/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n/// of nums.\n/// Example\n/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n/// 1\n/// >>> minSubArraySum(vec![-1, -2, -3])\n/// -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut sum = 0;\n    let mut min_sum = 0;\n    for num in nums {\n        sum += num;\n        if sum < min_sum {\n            min_sum = sum;\n        }\n    }\n    min_sum"], ["/// You are given a rectangular grid of wells. Each row represents a single well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well has a corresponding bucket that can be used to extract water from it, \n/// and all buckets have the same capacity.\n/// Your task is to use the buckets to empty the wells.\n/// Output the number of times you need to lower the buckets.\n/// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n            let mut bucket = 0;\n            for unit in 0..capacity {\n                if grid[row][col] == unit {\n                    bucket += 1;\n                }\n            }\n            if bucket > max_fill {\n                max_fill = bucket;\n            }\n        }\n    }\n    max_fill"], ["/// In this Kata, you have to sort a vector of non-negative integers according to\n/// number of ones in their binary representation in ascending order.\n/// For similar number of ones, sort based on decimal value.\n/// It must be implemented like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n/// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n/// >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    arr.sort_by(|a, b| a.cmp(b))"], ["/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    for word in s.chars() {\n        if word.is_ascii_alphanumeric() {\n            let mut count = 0;\n            for c in word.chars() {\n                if c.is_ascii_alphanumeric() {\n                    count += 1;\n                }\n            }\n            if count == n {\n                words.push(word.to_string());\n            }\n        }\n    }\n    words"], ["/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let mut vowels = vec![];\n    let mut vowels_count = 0;\n    for c in word.chars() {\n        if c.is_ascii_lowercase() {\n            vowels.push(c);\n            vowels_count += 1;\n        }\n    }\n    if vowels_count == 1 {\n        return String::from(\"\");\n    }\n    let mut closest_vowel = String::from(\"\");\n    for i in 0..vowels.len() {\n        if vowels[i] == vowels[i + 1] {\n            closest_vowel = vowels[i];\n        }\n    }\n    return closest_vowel;"], ["/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n    let mut stack = vec![];\n    let mut result = String::new();\n    for s in lst {\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }\n        if s.is_empty() {\n            continue;\n        }"], ["/// Given a vector arr of integers and a positive integer k, return a sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector will be in the range of [1, 1000].\n/// 2. The elements in the vector will be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut max_arr = vec![0; k];\n    let mut max_idx = 0;\n    for i in 0..k {\n        if arr[i] > max_arr[i] {\n            max_arr[i] = arr[i];\n            max_idx = i;\n        }\n    }\n    max_arr.iter().rev().take(k).collect()"], ["/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n/// Examples\n/// >>> solution(vec![5, 8, 7, 1])\n/// 12\n/// >>> solution(vec![3, 3, 3, 3, 3])\n/// 9\n/// >>> solution(vec![30, 13, 24, 321])\n/// 0\nfn solution(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for &num in lst.iter() {\n        if num % 2 == 1 {\n            sum += num;\n        }\n    }\n    sum"], ["/// Given a non-empty vector of integers arr and an integer k, return\n/// the sum of the elements with at most two digits from the first k elements of arr.\n/// Example:\n/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n/// 24\n/// Constraints:\n/// 1. 1 <= len(arr) <= 100\n/// 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    let mut sum = 0;\n    for i in 0..k {\n        let mut sum_i = 0;\n        for j in 0..arr.len() {\n            if arr[j] <= arr[j + i] {\n                sum_i += arr[j] - arr[j + i];\n            }\n        }\n        sum += sum_i;\n    }\n    sum"], ["/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n/// as follows: start with any positive integer n. Then each term is obtained from the \n/// previous term as follows: if the previous term is even, the next term is one half of \n/// the previous term. If the previous term is odd, the next term is 3 times the previous\n/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n/// 2. returned vector sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n/// >>> get_odd_collatz(5)\n/// vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut odd = vec![];\n    let mut prev = 1;\n    for I in 1..=n {\n        if I % 2 == 1 {\n            odd.push(prev * 3 + 1);\n            prev = 3 * prev + 1;\n        } else {\n            odd.push(prev);\n            prev = prev * 2;\n        }\n    }\n    odd"], ["/// You have to write a function which validates a given date string and\n/// returns true if the date is valid otherwise false.\n/// The date is valid if all of the following rules are satisfied:\n/// 1. The date string is not empty.\n/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n/// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let mut date_parts = date.split('-');\n    let year = date_parts.next().unwrap().parse::<i32>().unwrap();\n    let month = date_parts.next().unwrap().parse::<i32>().unwrap();\n    let day = date_parts.next().unwrap().parse::<i32>().unwrap();\n    let date_str = format!(\"{}-{}-{}\", year, month, day);\n    let date_str_parts = date_str.split('/');\n    let day_of_month = date_str_parts.next().unwrap().parse::<i32>().unwrap();\n    let month_of_year = date_str_parts.next().unwrap().parse::<i32>().unwrap();\n    let year_of_year"], ["/// Given a vector of numbers, return whether or not they are sorted\n/// in ascending order. If vector has more than 1 duplicate of the same\n/// number, return false. Assume no negative numbers and only integers.\n/// Examples\n/// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\nfn is_sorted(lst: Vec<isize>) -> bool {\n    lst.iter().all(|&x| x > 0)"], ["/// You are given two intervals,\n/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed which means that the interval (start, end)\n/// includes both start and end.\n/// For each given interval, it is assumed that its start is less or equal its end.\n/// Your task is to determine whether the length of intersection of these two \n/// intervals is a prime number.\n/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n/// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let mut interval1 = interval1;\n    let mut interval2 = interval2;\n    let mut result = String::new();\n    while interval1.0 < interval2.0 {\n        if interval1.0 == interval2.0 {\n            result.push(interval1.0);\n            interval1.0 += 1;\n        } else {\n            result.push(interval1.0);\n            interval1.0 += 1;\n        }\n    }\n    result"], ["/// You are given a vector arr of integers and you need to return\n/// sum of magnitudes of integers multiplied by product of all signs\n/// of each number in the vector, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n/// >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut sum = 0;\n    for num in arr {\n        sum += num * (-1) * (1 + num);\n    }\n    Some(sum)"], ["/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n/// each cell of the grid contains a value. Every integer in the range [1, N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You have to find the minimum path of length k in the grid. You can start\n/// from any cell, and in each step you can move to any of the neighbor cells,\n/// in other words, you can go to cells which share an edge with you current\n/// cell.\n/// Please note that a path of length k means visiting exactly k cells (not\n/// necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length k) is considered less than a path B (of length k) if\n/// after making the ordered vectors of the values on the cells that A and B go\n/// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed that the answer is unique.\n/// Return an ordered vector of the values on the cells that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let mut grid = grid.clone();\n    let mut visited = vec![false; grid.len()];\n    let mut path = vec![0; grid.len()];\n    let mut min_path = vec![0; grid.len()];"], ["/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return a vector of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(3)\n/// vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n    let mut result = vec![1, 3, 2, 8];\n    for i in 1..=n {\n        result.push(tri(i) - tri(i - 1));\n    }\n    result"], ["/// Given a positive integer n, return the product of the odd digits.\n/// Return 0 if all digits are even.\n/// For example:\n/// >>> digits(1)\n/// 1\n/// >>> digits(4)\n/// 0\n/// >>> digits(235)\n/// 15\nfn digits(n: isize) -> isize {\n    let mut result = 1;\n    for digit in n.to_string().chars() {\n        result *= digit.to_digit(10).unwrap();\n    }\n    result"], ["/// Create a function that takes a string as input which contains only square brackets.\n/// The function should return true if and only if there is a valid subsequence of brackets \n/// where at least one bracket in the subsequence is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n/// false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"[[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\nfn is_nested(string: String) -> bool {\n    let mut brackets = String::new();\n    for c in string.chars() {\n        if c == '[' || c == ']' {\n            brackets.push(c);\n        }\n    }\n    brackets.trim().is_empty()"], ["/// You are given a vector of numbers.\n/// You need to return the sum of squared numbers in the given vector,\n/// round each element in the vector to the upper int(Ceiling) first.\n/// Examples:\n/// >>> lst(vec![1.0, 2.0, 3.0])\n/// 14\n/// >>> lst(vec![1.0, 4.0, 9.0])\n/// 98\n/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n/// 84\n/// >>> lst(vec![1.4, 4.2, 0.0])\n/// 29\n/// >>> lst(vec![-2.4, 1.0, 1.0])\n/// 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter().map(|x| x.powi(2)).sum()"], ["/// Create a function that returns true if the last character\n/// of a given string is an alphabetical character and is not\n/// a part of a word, and false otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n    let mut last_char = txt.chars().last().unwrap();\n    let mut last_char_is_letter = false;\n    for c in txt.chars() {\n        if c.to_ascii_lowercase() == last_char {\n            last_char_is_letter = true;\n        } else {\n            last_char_is_letter = false;\n        }\n    }\n    last_char_is_letter"], ["/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let mut arr_len = arr.len();\n    let mut max_idx = 0;\n    for i in 1..arr_len {\n        if arr[i] > arr[i - 1] {\n            max_idx = i;\n        }\n    }\n    max_idx"], ["/// Create a function that returns a tuple (a, b), where 'a' is\n/// the largest of negative integers, and 'b' is the smallest\n/// of positive integers in a vector.\n/// If there is no negative or positive integers, return them as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n    let mut min = None;\n    for num in lst {\n        if num < 0 {\n            max = Some(num);\n        } else if num > 0 {\n            min = Some(num);\n        }\n    }\n    (max, min)"], ["/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n/// Example\n/// >>> is_equal_to_sum_even(4)\n/// false\n/// >>> is_equal_to_sum_even(6)\n/// false\n/// >>> is_equal_to_sum_even(8)\n/// true\nfn is_equal_to_sum_even(n: isize) -> bool {\n    let mut sum = 0;\n    for I in 1..=4 {\n        if n % I == 0 {\n            sum += i;\n        }\n    }\n    sum == n"], ["/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>> special_factorial(4)\n/// 288\n/// The function will receive an integer as input and should return the special\n/// factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n    if n < 0 {\n        panic!(\"The special factorial function only accepts positive integers\");\n    }\n    if n == 0 {\n        return 1;\n    }\n    let mut result = 1;\n    for I in 1..=n {\n        result *= i;\n    }\n    result"], ["/// Given a string text, replace all spaces in it with underscores, \n/// and if a string has more than 2 consecutive spaces, \n/// then replace all consecutive spaces with - \n/// >>> fix_spaces(String::from(\" Example\"))\n/// String::from(\"Example\")\n/// >>> fix_spaces(String::from(\" Example 1\"))\n/// String::from(\"Example_1\")\n/// >>> fix_spaces(String::from(\" Example 2\"))\n/// String::from(\"_Example_2\")\n/// >>> fix_spaces(String::from(\" Example 3\"))\n/// String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n    text.replace(\" \", \"_\").replace(\" \", \"-\")"], ["/// Create a function which takes a string representing a file's name, and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n/// A file's name is considered to be valid if and only if all the following conditions \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The substring before the dot should not be empty, and it starts with a letter from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n/// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n    let mut file_name_parts = file_name.split('.');\n    let file_name_parts_len = file_name_parts.len();\n    let mut file_name_parts_str = String::new();\n    for I in 0..file_name_parts_len {\n        file_name_parts_str.push_str(&file_name_parts[i]);\n    }\n    if file_name_parts_str.len() == 3 {\n        if file_name_parts_str.starts_with(\"txt\") || file_name_parts_str.starts_with(\"exe\") || file_name_parts_str.starts_with(\"dll\") {\n            return String::from(\"Yes\");\n        }\n    }\n    String::from(\"No\")"], ["/// \"\n/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n/// Examples:\n/// >>> lst\n/// vec![1, 2, 3]\n/// >>> lst\n/// vec![]\n/// >>> lst\n/// vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for num in lst {\n        sum += num * num;\n    }\n    sum"], ["/// You are given a string representing a sentence,\n/// the sentence contains some words separated by a space,\n/// and you have to return a string that contains the words from the original sentence,\n/// whose lengths are prime numbers,\n/// the order of the words in the new string should be the same as the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n    let mut words = Vec::new();\n    let mut current_word = String::new();\n    for word in sentence.chars() {\n        if word.is_alphabetic() {\n            if current_word.is_empty() {\n                current_word.push(word);\n            } else {\n                if current_word.len() == 1 {\n                    words.push(current_word);\n                    current_word.clear();\n                } else {\n                    current_word.push(word);\n                }\n            }\n        }\n    }\n    if current_word.len() > 0 {\n        words.push(current_word);\n    }\n    words.join(\" \")"], ["/// Your task is to implement a function that will simplify the expression\n/// x * n. The function returns true if x * n evaluates to a whole number and false\n/// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n/// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n/// >>> simplify(String::from(\"1/5\"), String::from(\"5/1\"))\n/// true\n/// >>> simplify(String::from(\"1/6\"), String::from(\"2/1\"))\n/// false\n/// >>> simplify(String::from(\"7/10\"), String::from(\"10/2\"))\n/// false\nfn simplify(x: String, n: String) -> bool {\n    let mut x_str = x.clone();\n    let mut n_str = n.clone();\n    let mut result = false;\n\n    while x_str.len() > 0 && n_str.len() > 0 {\n        if x_str.len() == 1 && n_str.len() == 1 {\n            if x_str.chars().next().unwrap() == n_str.chars().next().unwrap() {\n                x_str.pop();\n                n_str.pop();\n                result = true;\n            } else {\n                x_str.pop();\n            }\n        } else if x_str.len() == 1 && n_str.len() == 2 {\n            if x_str.chars().next().unwrap() == n_str.chars().next().unwrap() {\n                x_str.pop();\n                n_str.pop();\n                result = true;\n            } else {\n                x_str.pop();\n            }\n        } else if x_str.len() == 2 && n_str.len() == 2 {\n            if x_str.chars().next().unwrap() == n_str.chars().next().unwrap() {\n                x_str.pop();\n                n_str.pop();\n                result = true;\n            } else {\n                x_str"], ["/// Write a function which sorts the given vector of integers\n/// in ascending order according to the sum of their digits.\n/// Note: if there are several items with similar sum of their digits,\n/// order them based on their index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut sorted_nums = nums.clone();\n    let mut sum = 0;\n    for num in &sorted_nums {\n        sum += *num;\n    }\n    sorted_nums.sort_by(|a, b| a.checked_add(sum).unwrap().cmp(&b.checked_add(sum).unwrap()));\n    sorted_nums"], ["/// Write a function that takes a vector of numbers as input and returns \n/// the number of elements in the vector that are greater than 10 and both \n/// first and last digits of a number are odd (1, 3, 5, 7, 9).\n/// For example:\n/// >>> specialFilter(vec![15, -73, 14, -15])\n/// 1\n/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n/// 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in nums {\n        if num > 10 && num % 2 == 1 && num.is_odd() {\n            count += 1;\n        }\n    }\n    count"], ["/// You are given a positive integer n. You have to create an integer vector a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// >>> get_max_triples(5)\n/// 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n    let mut a = vec![0; n];\n    a[0] = 1;\n    a[1] = 3;\n    a[2] = 7;\n    a[3] = 13;\n    a[4] = 21;\n    let mut max_triples = 0;\n    for i in 1..n {\n        for j in 1..i {\n            for k in 1..j {\n                if a[i] + a[j] + a[k] % 3 == 0 {\n                    max_triples += 1;\n                }\n            }\n        }\n    }\n    max_triples"], ["/// Write a function that accepts a vector of strings as a parameter,\n/// deletes the strings that have odd lengths from it,\n/// and returns the resulted vector with a sorted order,\n/// The vector is always a vector of strings and never a vector of numbers,\n/// and it may contain duplicates.\n/// The order of the vector should be ascending by length of each word, and you\n/// should return the vector sorted by that rule.\n/// If two words have the same length, sort the vector alphabetically.\n/// The function should return a vector of strings in sorted order.\n/// You may assume that all words will have the same length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n/// vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    lst"], ["/// A simple program which should return the value of x if n is \n/// a prime number and should return the value of y otherwise.\n/// Examples:\n/// >>> x_or_y(7, 34, 12)\n/// 34\n/// >>> x_or_y(15, 8, 5)\n/// 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    if n == 1 {\n        return y;\n    }\n    if n % 2 == 0 {\n        return x;\n    }\n    return x_or_y(n - 2, x, y);"], ["/// Given a vector of numbers, return the sum of squares of the numbers\n/// in the vector that are odd. Ignore numbers that are negative or not integers.\n/// >>> double_the_difference(vec![1, 3, 2, 0])\n/// 10\n/// >>> double_the_difference(vec![-1, -2, 0])\n/// 0\n/// >>> double_the_difference(vec![9, -2])\n/// 81\n/// >>> double_the_difference(vec![0])\n/// 0\n/// If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter().filter(|&x| x % 2 == 1).sum()"], ["/// I think we all remember that feeling when the result of some long-awaited\n/// event is finally known. The feelings and thoughts you have at that moment are\n/// definitely worth noting down and comparing.\n/// Your task is to determine if a person correctly guessed the results of a number of matches.\n/// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n/// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n/// example:\n/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n/// vec![0, 0, 0, 0, 3, 3]\n/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n/// vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![0; game.len()];\n    for (i, &g) in game.iter().enumerate() {\n        result[i] = g - guess[i];\n    }\n    result"], ["/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut best_extension = String::from(\"\");\n    let mut best_strength = 0;\n    for extension in extensions {\n        let strength = extension.chars().filter(|c| c.is_ascii_uppercase()).count();\n        if strength > best_strength {\n            best_strength = strength;\n            best_extension = extension;\n        }\n    }\n    best_extension"], ["/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n/// >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n/// false\n/// >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n/// true\n/// >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n/// false\n/// >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n/// true\n/// >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n/// false\n/// >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n/// true\nfn cycpattern_check(a: String, b: String) -> bool {\n    let mut a = a.chars().collect::<Vec<char>>();\n    let mut b = b.chars().collect::<Vec<char>>();\n    let mut c = a.clone();\n    let mut d = b.clone();\n    let mut result = true;\n    while result {\n        result = false;\n        for (i, &c) in c.iter().enumerate() {\n            if a[i] == b[i] {\n                d.push(c);\n                result = true;\n            } else {\n                d.pop();\n            }\n        }\n        for (i, &d) in d.iter().enumerate() {\n            if a[i] == d {\n                b.push(c);\n                result = true;\n            } else {\n                b.pop();\n            }\n        }\n        a.pop();\n        b.pop();\n    }\n    result"], ["/// Given an integer. return a tuple that has the number of even and odd digits respectively.\n/// Example:\n/// >>> even_odd_count(-12)\n/// (1, 1)\n/// >>> even_odd_count(123)\n/// (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n    let mut count = 0;\n    let mut odd = 0;\n    let mut even = 0;\n    for digit in num.iter() {\n        if digit % 2 == 0 {\n            even += 1;\n        } else {\n            odd += 1;\n        }\n    }\n    (even, odd)"], ["/// Given a positive integer, obtain its roman numeral equivalent as a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n/// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>> int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n/// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n    while num > 0 {\n        let digit = num % 10;\n        result.push(digit.to_string());\n        num /= 10;\n    }\n    result"], ["/// Given the lengths of the three sides of a triangle. Return true if the three\n/// sides form a right-angled triangle, false otherwise.\n/// A right-angled triangle is a triangle in which one angle is right angle or \n/// 90 degree.\n/// Example:\n/// >>> right_angle_triangle(3, 4, 5)\n/// true\n/// >>> right_angle_triangle(1, 2, 3)\n/// false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let a_b = a * b;\n    let a_c = a * c;\n    let b_c = b * c;\n    let a_b_c = a_b * b_c;\n    let a_c_b = a_c * b;\n    let b_a_c = b_c * a;\n    let c_a_b = c_a_b * a;\n    let a_c_b_a_b = a_c_b * a_c_b;\n    let a_c_b_a_c = a_c_b_a_b * a_c_b;\n    let a_c_b_a_c_a_b = a_c_b_a_c * a_c_b_a_c;\n    let a_c_b_a_c_a_b_a_b = a_c_b_a_c_a_b * a_c_b_a_c_a_b;\n    let a_c_b_a_c_a_b_a_b_a_b = a_c_b_a_c_a_b_a_b * a_c_b_a_c_a_b_a_b;\n    let a_c_b_a_c_a_b_a_b_a_b_a_b = a_c_b_a_c_a_b_a_b_a_b * a_c_b_a_c_a_b_a_b_a_b;\n    let a_c_b_a_c"], ["/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len = 0;\n    let mut max_word = String::new();\n    for word in words {\n        let len = word.chars().filter(|c| c.is_alphanumeric()).count();\n        if len > max_len {\n            max_len = len;\n            max_word = word.to_string();\n        }\n    }\n    max_word"], ["/// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n/// you should return a vector of [ total number of eaten carrots after your meals,\n/// the number of carrots left after your meals ]\n/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n/// >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n/// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n/// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut current_carrots = 0;\n    let mut remaining_carrots = 0;\n    while current_carrots < need {\n        remaining_carrots -= 1;\n        result.push(current_carrots);\n        current_carrots += 1;\n    }\n    if remaining_carrots > 0 {\n        result.push(remaining_carrots);\n    }\n    result"], ["/// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n/// the second vector is a vector of integers. Use the two given vectors to build the algebric \n/// expression and return the evaluation of this expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// vector = [2, 3, 4, 5]\n/// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator vector is equal to the length of operand vector minus one.\n/// Operand is a vector of of non-negative integers.\n/// Operator vector has at least one operator, and operand vector has at least two operands.\nfn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = 0;\n    for (i, operand_i) in operand.iter().enumerate() {\n        let operand_i_int = *operand_i as isize;\n        if i == 0 {\n            result += operand_i_int;\n        } else {\n            result += operator[i - 1] * operand_i_int;\n        }\n    }\n    result"], ["/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n        match c {\n            'A' => result.push('a'),\n            'a' => result.push('A'),\n            'B' => result.push('b'),\n            'b' => result.push('B'),\n            'C' => result.push('c'),\n            'c' => result.push('C'),\n            _ => result.push(c),\n        }\n    }\n    result"], ["/// Given a string 'text', return its md5 hash equivalent string.\n/// If 'text' is an empty string, return None.\n/// >>> string_to_md5(String::from(\"Hello world\"))\n/// Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n    let mut hash = [0u8; 32];\n    let mut iter = text.chars();\n    let mut i = 0;\n    while let Some(c) = iter.next() {\n        hash[i] = c as u8;\n        i += 1;\n    }\n    Some(String::from(hex::encode(&hash)))"], ["/// Given two positive integers a and b, return the even digits between a\n/// and b, in ascending order.\n/// For example:\n/// >>> generate_integers(2, 8)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(8, 2)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(10, 14)\n/// Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current = a;\n    while current <= b {\n        result.push(current);\n        current += 2;\n    }\n    result"]]