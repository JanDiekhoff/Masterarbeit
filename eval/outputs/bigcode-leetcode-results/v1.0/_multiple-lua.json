[["-- Check if in given table of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n-- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\nlocal function has_close_elements(numbers, threshold)\n  for _, num in ipairs(numbers) do\n    if num ~= nil and math.abs(num - threshold) < math.abs(num) then\n      return true\n    end\n  end\n  return false\nend\n```"], ["-- Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the table of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- {'()', '(())', '(()())'}\nlocal function separate_paren_groups(paren_string)\n  local result = {}\n  local current_group = {}\n  local current_open_brace = false\n  local current_close_brace = false\n  for i, char in ipairs(paren_string) do\n    if char == '(' then\n      current_open_brace = true\n    elseif char == ')' then\n      current_close_brace = true\n    elseif current_open_brace and current_close_brace then\n      table.insert(result, current_group)\n      current_group = {}\n      current_open_brace = false\n      current_close_brace = false\n    elseif current_open_brace then\n      current_group[#current_group + 1] = char\n    elseif current_close_brace then\n      current_group[#current_group + 1] = char\n    end\n  end\n  return result\nend\nreturn separate_paren_groups"], ["-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n  local integer, decimals = number:match('^%d+%.*%d+$')\n  return integer\nend -- function"], ["-- You're given a table of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return true. Otherwise it should return false.\n-- >>> below_zero({1, 2, 3})\n-- false\n-- >>> below_zero({1, 2, -4, 5})\n-- true\nlocal function below_zero(operations)\n  local balance = operations[1]\n  for i = 2, #operations do\n    if operations[i] < 0 then\n      return true\n    end\n    balance = balance - operations[i]\n  end\n  return balance < 0\nend \"\"\""], ["-- For a given table of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n-- 1.0\nlocal function mean_absolute_deviation(numbers)\n  local mean = numbers:mean()\n  local abs_diff = numbers:abs():map(function(x) return x - mean end)\n  return math.sqrt(table.sum(abs_diff) / numbers:size())\nend -- end of function mean_absolute_deviation"], ["-- Insert a number 'delimeter' between every two consecutive elements of input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1, 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n  return {unpack(unpack(numbers, 1, 2)) .. delimeter .. unpack(unpack(numbers, 3, 4))} end\nreturn intersperse } }"], ["-- Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n-- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n  local nesting = {}\n  local max_nesting = 0\n  for i, v in ipairs(paren_string:gmatch('(%s+)') or {}) do\n    local level = 0\n    if v:match('%(') then\n      level = level + 1\n    end\n    if v:match('%s)') then\n      level = level - 1\n    end\n    if level > max_nesting then\n      max_nesting = level\n    end\n    nesting[level] = nesting[level] or 0\n    nesting[level] = nesting[level] + 1\n  end\n  return nesting\nend\nreturn parse_nested_parens"], ["-- Filter an input table of strings only for ones that contain given substring\n-- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings, substring)\n  local filtered = {}\n  for k, v in ipairs(strings) do\n    if string.sub(v, 1, #substring) == substring then\n      table.insert(filtered, k)\n    end\n  end\n  return filtered\nend\n```"], ["-- For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product({})\n-- {0, 1}\n-- >>> sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n  local sum = 0\n  local product = 1\n  for I = 1, #numbers do\n    sum = sum + numbers[i]\n    product = product * numbers[i]\n  end\n  return {sum, product}\nend"], ["-- From a given table of integers, generate a table of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n  local max = numbers[1]\n  for I = 2, #numbers do\n    local current = numbers[i]\n    if current > max then\n      max = current\n    end\n  end\n  return max\nend -- end of function rolling_max"], ["-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string:reverse()\n  local prefix = string:reverse()\n  local palindrome = prefix .. postfix\n  return palindrome\nend"], ["-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010', '110')\n-- '100'\nlocal function string_xor(a, b)\n  return string.char(a) ^ string.char(b)\nend -- function string_xor"], ["-- Out of table of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return nil in case the input table is empty.\n-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n-- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n  if #strings == 0 then\n    return nil\n  end\n  local longest = nil\n  for _, str in ipairs(strings) do\n    if longest == nil or str:len() > longest:len() then\n      longest = str\n    end\n  end\n  return longest\nend\nreturn longest"], ["-- Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a, b)\n  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend\n```"], ["-- Return table of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes('abc')\n-- {'a', 'ab', 'abc'}\nlocal function all_prefixes(string)\n  local prefixes = {}\n  for i = 1, #string do\n    local prefix = string:sub(i, i)\n    if prefixes[prefix] == nil then\n      prefixes[prefix] = {}\n    end\n    prefixes[prefix][#prefixes[prefix] + 1] = string:sub(i, i)\n  end\n  return prefixes\nend -- function all_prefixes"], ["-- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence(0)\n-- '0'\n-- >>> string_sequence(5)\n-- '0 1 2 3 4 5'\nlocal function string_sequence(n)\n  local result = {}\n  for I = 0, n do\n    table.insert(result, string.format('%d', i))\n  end\n  return table.concat(result, ' ')\nend"], ["-- Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n-- 4\nlocal function count_distinct_characters(string)\n  local count = 0\n  for i = 1, #string do\n    local char = string:sub(i, i)\n    if char ~= char then\n      count = count + 1\n    end\n  end\n  return count\nend -- function count_distinct_characters\nreturn count_distinct_characters"], ["-- Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return table of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nlocal function parse_music(music_string)\n  local table = {}\n  for i = 1, #music_string do\n    local note = music_string:sub(i, i)\n    if note == 'o' then\n      table[#table + 1] = 4\n    elseif note == 'o|' then\n      table[#table + 1] = 2\n    elseif note == '.' then\n      table[#table + 1] = 1\n    elseif note == 'o|' then\n      table[#table + 1] = 2\n    elseif note == '.' then\n      table[#table + 1] = 1\n    else\n      table[#table + 1] = 1\n    end\n  end\n  return table\nend\n```"], ["-- Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa', 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string, substring)\n  local count = 0\n  for i = 1, #string do\n    if string:sub(i, i) == substring then\n      count = count + 1\n    end\n  end\n  return count\nend\n```"], ["-- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers('three one five')\n-- 'one three five'\nlocal function sort_numbers(numbers)\n  local sorted_numbers = {}\n  for I, number in ipairs(numbers) do\n    table.insert(sorted_numbers, number)\n  end\n  return table.concat(sorted_numbers, ' ')\nend\n```"], ["-- From a supplied table of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n-- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n-- {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n  local min_distance = numbers[1]\n  local min_index = 1\n  for I = 2, #numbers do\n    local distance = math.abs(numbers[i] - min_distance)\n    if distance < min_distance then\n      min_distance = distance\n      min_index = i\n    end\n  end\n  return {numbers[min_index], numbers[min_index]}\nend\nreturn find_closest_elements"], ["-- Given table of numbers (of at least two elements), apply a linear transform to that table,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25, 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n  local rescaled = {}\n  for i = 1, #numbers do\n    rescaled[i] = numbers[i] / numbers[#numbers]\n  end\n  return rescaled\nend\n```"], ["-- Filter given table of any luathon values only for integers\n-- >>> filter_integers({'a', 3.14, 5})\n-- {5}\n-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})\n-- {1, 2, 3}\nlocal function filter_integers(values)\n  return filter(function(value)\n    return type(value) == 'number' and value ~= 0\n  end, values)\nend\n```"], ["-- Return length of given string\n-- >>> strlen('')\n-- 0\n-- >>> strlen('abc')\n-- 3\nlocal function strlen(string)\n  return #string\nend -- function strlen"], ["-- For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor(15)\n-- 5\nlocal function largest_divisor(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n  else\n    return 2 * largest_divisor(n - 2)\n  end\nend\n```"], ["-- Return table of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be tableed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n-- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n  local factors = {}\n  local num = 1\n  while num <= n do\n    local factor = math.factorial(num)\n    table.insert(factors, factor)\n    num = num + 1\n  end\n  return factors\nend -- end of function factorize"], ["-- From a table of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates({1, 2, 3, 2, 4})\n-- {1, 3, 4}\nlocal function remove_duplicates(numbers)\n  local result = {}\n  for i = 1, #numbers do\n    if numbers[i] ~= numbers[i + 1] then\n      table.insert(result, numbers[i])\n    end\n  end\n  return result\nend\n```"], ["-- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case('Hello')\n-- 'hELLO'\nlocal function flip_case(string)\n  return string:gsub('[%a%s]', function(c) return string:sub(string.len(c) + 1, string.len(c)) end) end\nreturn flip_case"], ["-- Concatenate table of strings into a single string\n-- >>> concatenate({})\n-- ''\n-- >>> concatenate({'a', 'b', 'c'})\n-- 'abc'\nlocal function concatenate(strings)\n  return table.concat(strings, ' ')\nend"], ["-- Filter an input table of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc', 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings, prefix)\n  return filter(function(s)\n    return s:sub(1, #prefix) == prefix\n  end, strings)\nend -- function"], ["-- Return only positive numbers in the table.\n-- >>> get_positive({-1, 2, -4, 5, 6})\n-- {2, 5, 6}\n-- >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- {5, 3, 2, 3, 9, 123, 1}\nlocal function get_positive(l)\n  local ret = {}\n  for i, v in ipairs(l) do\n    if v > 0 then\n      ret[i] = v\n    end\n  end\n  return ret\nend"], ["-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime(6)\n-- false\n-- >>> is_prime(101)\n-- true\n-- >>> is_prime(11)\n-- true\n-- >>> is_prime(13441)\n-- true\n-- >>> is_prime(61)\n-- true\n-- >>> is_prime(4)\n-- false\n-- >>> is_prime(1)\n-- false\nlocal function is_prime(n)\n  if n <= 1 then\n    return false\n  end\n  if n % 2 == 0 then\n    return false\n  end\n  for I = 3, math.floor(math.sqrt(n)) do\n    if n % I == 0 then\n      return false\n    end\n  end\n  return true\nend\nreturn is_prime"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal function sort_third(l)\n  local l' = {}\n  for i = 1, #l do\n    local j = i + 1\n    while j <= #l do\n      if l[j] % 3 == 0 then\n        table.insert(l', l[j])\n        j = j + 1\n      else\n        table.insert(l', l[j])\n        j = j + 1\n      end\n    end\n    table.insert(l', l[i])\n  end\n  return l'\nend\n```"], ["-- Return sorted unique elements in a table\n-- >>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nlocal function unique(l)\n  local result = {}\n  for i, v in ipairs(l) do\n    if not result[v] then\n      result[v] = true\n    end\n  end\n  return result\nend\nreturn unique } }\n```"], ["-- Return maximum element in the table.\n-- >>> max_element({1, 2, 3})\n-- 3\n-- >>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- 123\nlocal function max_element(l)\n  local max = l[1]\n  for i = 2, #l do\n    if l[i] > max then\n      max = l[i]\n    end\n  end\n  return max\nend\n```"], ["-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n-- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n  local result = 0\n  for I = 1, n do\n    if (i % 11 == 7 or i % 13 == 7) then\n      result = result + 1\n    end\n  end\n  return result\nend\n```"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function sort_even(l)\n  local l' = {}\n  for i = 1, #l do\n    l'[i] = l[i]\n  end\n  return l'\nend\n```"], ["-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n-- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n  if n <= 1 then\n    return false\n  end\n  local fib = 0\n  local i = 1\n  while fib < n do\n    fib = fib + fib\n    i = i + 1\n  end\n  return true\nend\n```"], ["-- triples_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are three distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1, 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n-- false\nlocal function triples_sum_to_zero(l)\n  local sum = 0\n  for _, v in ipairs(l) do\n    sum = sum + v\n  end\n  return sum == 0\nend\n```"], ["-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\nlocal function car_race_collision(n)\n  local result = 0\n  for I = 1, n do\n    local car1 = get_car(i)\n    local car2 = get_car(i + 1)\n    if car1.speed > car2.speed then\n      car1.speed = car1.speed + 1\n      car2.speed = car2.speed - 1\n    else\n      car2.speed = car2.speed + 1\n      car1.speed = car1.speed - 1\n    end\n    if car1.speed == car2.speed then\n      result = result + 1\n    end\n  end\n  return result\nend"], ["-- Return table with elements incremented by 1.\n-- >>> incr_list({1, 2, 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4, 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n  return {\n    function(x)\n      return x + 1\n    end,\n    l\n  }\nend\n```"], ["-- pairs_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are two distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1, 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n-- false\nlocal function pairs_sum_to_zero(l)\n  local sum = 0\n  for i = 1, #l do\n    sum = sum + l[i]\n  end\n  return sum == 0\nend -- pairs_sum_to_zero\n```"], ["-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base(8, 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n-- '111'\nlocal function change_base(x, base)\n  if base == 1 then\n    return x\n  elseif base == 2 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 3 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 4 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 5 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 6 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 7 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 8 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 9 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 10 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 11 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 12 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 13 then\n    return string.format(\"%0\" .. (#x - 1) .. \"d\", x)\n  elseif base == 14 then\n   "], ["-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area(5, 3)\n-- 7.5\nlocal function triangle_area(a, h)\n  return a * h / 2\nend\n```"], ["-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4(5)\n-- 4\n-- >>> fib4(6)\n-- 8\n-- >>> fib4(7)\n-- 14\nlocal function fib4(n)\n  if n < 0 then\n    return 0\n  elseif n == 0 then\n    return 0\n  elseif n == 1 then\n    return 0\n  elseif n == 2 then\n    return 2\n  else\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend\nreturn fib4"], ["-- Return median of elements in the table l.\n-- >>> median({3, 1, 2, 4, 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n  if #l == 0 then\n    return nil\n  end\n  local n = #l\n  if n == 1 then\n    return l[1]\n  end\n  local median = l[1]\n  for i = 2, n do\n    median = math.min(median, l[i])\n  end\n  return median\nend\n```"], ["-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- true\n-- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n-- >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n  local n = #text\n  local i = 1\n  while i <= n do\n    local j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n    i = n + 1\n    j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n    i = n + 1\n    j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n    i = n + 1\n    j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n    i = n + 1\n    j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n    i = n + 1\n    j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n    i = n + 1\n    j = i + 1\n    while j <= n do\n      if text[i] ~= text[j] then\n        return false\n      else\n        i = j\n      end\n    end\n  end\n  return true\nend\n```"], ["-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n-- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n  else\n    return (n % p) + p\n  end\nend -- end modp"], ["-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels('')\n-- ''\n-- >>> remove_vowels('abcdef')\n-- 'bcdf'\n-- >>> remove_vowels('aaaaa')\n-- ''\n-- >>> remove_vowels('aaBAA')\n-- 'B'\n-- >>> remove_vowels('zbcd')\n-- 'zbcd'\nlocal function remove_vowels(text)\n  return string.gsub(text, '[%a%s]', '')\nend\nreturn remove_vowels"], ["-- Return true if all numbers in the table l are below threshold t.\n-- >>> below_threshold({1, 2, 4, 10}, 100)\n-- true\n-- >>> below_threshold({1, 20, 4, 10}, 5)\n-- false\nlocal function below_threshold(l, t)\n  for _, v in ipairs(l) do\n    if v < t then\n      return false\n    end\n  end\n  return true\nend\n```"], ["-- Add two numbers x and y\n-- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n  return x + y\nend\n```"], ["-- Check if two words have the same characters.\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n-- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n-- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n  if s0 == s1 then\n    return true\n  else\n    return false\n  end\nend\n```"], ["-- Return n-th Fibonacci number.\n-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n-- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n  if n < 2 then\n    return n\n  elseif n == 2 then\n    return 1\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend\nreturn fib )\n```"], ["-- brackets is a string of \"<\" and \">\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('<')\n-- false\n-- >>> correct_bracketing('<>')\n-- true\n-- >>> correct_bracketing('<<><>>')\n-- true\n-- >>> correct_bracketing('><<>')\n-- false\nlocal function correct_bracketing(brackets)\n  local brackets_count = 0\n  for i = 1, #brackets do\n    if brackets[i] == \"<\" then\n      brackets_count = brackets_count + 1\n    elseif brackets[i] == \">\" then\n      brackets_count = brackets_count - 1\n    end\n  end\n  return brackets_count == 0\nend -- correct_bracketing"], ["-- Return true is table elements are monotonically increasing or decreasing.\n-- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n-- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n  return function(i)\n    return l[i] > l[i + 1]\n  end\nend -- local"], ["-- Return sorted unique common elements for two tables.\n-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5, 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n  local result = {}\n  for k, v in ipairs(l1) do\n    if not table.contains(l2, v) then\n      result[#result + 1] = k\n    end\n  end\n  return result\nend\n```"], ["-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n-- 2\nlocal function largest_prime_factor(n)\n  if n < 2 then\n    return n\n  elseif n == 2 then\n    return 2\n  elseif n == 3 then\n    return 3\n  elseif n % 2 == 0 then\n    return largest_prime_factor(n / 2)\n  else\n    local factors = {}\n    for I = 2, math.floor(math.sqrt(n)) do\n      if n % I == 0 then\n        table.insert(factors, i)\n      end\n    end\n    return factors[math.random(#factors)] or 1\n  end\nend\n```"], ["-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n(30)\n-- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n-- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n  return n + 1\nend -- function sum_to_n"], ["-- brackets is a string of \"(\" and \")\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('(')\n-- false\n-- >>> correct_bracketing('()')\n-- true\n-- >>> correct_bracketing('(()())')\n-- true\n-- >>> correct_bracketing(')(()')\n-- false\nlocal function correct_bracketing(brackets)\n  local bracket_count = 0\n  local is_open = true\n  for i = 1, #brackets do\n    if brackets[i] == '(' then\n      bracket_count = bracket_count + 1\n    elseif brackets[i] == ')' then\n      bracket_count = bracket_count - 1\n    elseif brackets[i] == '(' and is_open then\n      bracket_count = bracket_count - 1\n    elseif brackets[i] == ')' and is_open then\n      bracket_count = bracket_count + 1\n    else\n      return false\n    end\n    is_open = not is_open\n  end\n  return bracket_count == 0\nend\n```"], ["-- xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n--  Return derivative of this polynomial in the same form.\n-- >>> derivative({3, 1, 2, 4, 5})\n-- {1, 4, 12, 20}\n-- >>> derivative({1, 2, 3})\n-- {2, 6}\nlocal function derivative(xs)\n  local ys = {}\n  for i = 1, #xs do\n    ys[i] = xs[i] + xs[i + 1] * x + xs[i + 2] * x^2 + ...\n  end\n  return ys\nend\n```"], ["-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib(1)\n-- 0\n-- >>> fibfib(5)\n-- 4\n-- >>> fibfib(8)\n-- 24\nlocal function fibfib(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 0\n  elseif n == 2 then\n    return 1\n  else\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n  end\nend\nreturn fibfib(n)"], ["-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count('abcde')\n-- 2\n-- >>> vowels_count('ACEDY')\n-- 3\nlocal function vowels_count(s)\n  local count = 0\n  for i = 1, #s do\n    if s:sub(i, i) == 'a' or s:sub(i, i) == 'e' or s:sub(i, i) == 'i' or s:sub(i, i) == 'o' or s:sub(i, i) == 'u' then\n      count = count + 1\n    end\n  end\n  return count\nend\n```"], ["-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12, 2)\n-- '12'\nlocal function circular_shift(x, shift)\n  local result = \"\"\n  local digits = string.sub(string.rep(\"0\", #x), 1, #x - shift)\n  local reversed_digits = string.sub(digits, 1, #digits - shift)\n  result = string.rep(reversed_digits, shift)\n  result = string.sub(result, 1, #result - 1)\n  return result\nend\n```"], ["-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n-- >>> digitSum('')\n-- 0\n-- >>> digitSum('abAB')\n-- 131\n-- >>> digitSum('abcCd')\n-- 67\n-- >>> digitSum('helloE')\n-- 69\n-- >>> digitSum('woArBld')\n-- 131\n-- >>> digitSum('aAaaaXa')\n-- 153\nlocal function digitSum(s)\n  local sum = 0\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    if c:match('^%d+$') then\n      sum = sum + tonumber(c)\n    end\n  end\n  return sum\nend -- End of function digitSum"], ["-- In this task, you will be given a string that represents a number of apples and oranges \n-- that are distributed in a basket of fruit this basket contains \n-- apples, oranges, and mango fruits. Given the string that represents the total number of \n-- the oranges and apples and an integer that represent the total number of the fruits \n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- >>> fruit_distribution('5 apples and 6 oranges', 19)\n-- 8\n-- >>> fruit_distribution('0 apples and 1 oranges', 3)\n-- 2\n-- >>> fruit_distribution('2 apples and 3 oranges', 100)\n-- 95\n-- >>> fruit_distribution('100 apples and 1 oranges', 120)\n-- 19\nlocal function fruit_distribution(s, n)\n  local fruits = {}\n  for i = 1, n do\n    local f = s:match('(%d+)%s*%s*%d+')\n    if f then\n      table.insert(fruits, f)\n    end\n  end\n  return #fruits\nend"], ["-- \"Given a table representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a table, [ smalest_value, its index ],\n-- If there are no even values or the given table is empty, return [].\n-- Example 1:\n-- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5, 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there are two zeros,\n--              so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\nlocal function pluck(arr)\n  local result = {}\n  for i = 1, #arr do\n    local node = arr[i]\n    if node.value < result[node.value] then\n      result[node.value] = node\n    end\n  end\n  return result\nend\n```"], ["-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than \n-- zero, and has a frequency greater than or equal to the value of the integer itself. \n-- The frequency of an integer is the number of times it appears in the table.\n-- If no such a value exist, return -1.\n-- Examples:\n-- >>> search({4, 1, 2, 2, 3, 1})\n-- 2\n-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})\n-- 3\n-- >>> search({5, 5, 4, 4, 4})\n-- -1\nlocal function search(lst)\n  local max = 0\n  local freq = {}\n  for i = 1, #lst do\n    if lst[i] > max then\n      max = lst[i]\n    end\n    freq[lst[i]] = freq[lst[i]] or 0\n    freq[lst[i]] = freq[lst[i]] + 1\n  end\n  return max, freq[max] or 0\nend\n```"], ["-- Given table of integers, return table in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n-- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>> strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n  local sorted = {}\n  for i = 1, #lst do\n    local min_value = lst[i]\n    for j = i + 1, #lst do\n      local max_value = lst[j]\n      if min_value > max_value then\n        sorted[#sorted + 1] = lst[j]\n        lst[j] = lst[i]\n        lst[i] = min_value\n      end\n    end\n  end\n  return sorted\nend\nreturn strange_sort_list"], ["-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater \n-- than the third side.\n-- Example:\n-- >>> triangle_area(3, 4, 5)\n-- 6.0\n-- >>> triangle_area(1, 2, 10)\n-- -1\nlocal function triangle_area(a, b, c)\n  if a == b and b == c then return 0 end\n  if a == b and c == 0 then return 0 end\n  if a == c and b == 0 then return 0 end\n  return (a + b + c) / 2\nend"], ["-- Write a function that returns true if the object q will fly, and false otherwise.\n-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- >>> will_it_fly({1, 2}, 5)\n-- false\n-- # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- >>> will_it_fly({3, 2, 3}, 1)\n-- false\n-- # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- >>> will_it_fly({3, 2, 3}, 9)\n-- true\n-- # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- >>> will_it_fly({3}, 5)\n-- true\n-- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function will_it_fly(q, w)\n  if q.balanced then\n    return true\n  elseif q.sum < w then\n    return false\n  else\n    return will_it_fly(q.left, w) and will_it_fly(q.right, w)\n  end\nend\nreturn will_it_fly"], ["-- Given a table arr of integers, find the minimum number of elements that\n-- need to be changed to make the table palindromic. A palindromic table is a table that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n-- 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n  local min_change = 0\n  for i = 1, #arr do\n    for j = i, #arr do\n      if arr[i] == arr[j] then\n        table.insert(arr, j)\n        local change = #arr - j\n        if change < min_change then\n          min_change = change\n        end\n      end\n    end\n  end\n  return min_change\nend -- function smallest_change\nreturn smallest_change(arr)"], ["-- Write a function that accepts two tables of strings and returns the table that has \n-- total number of chars in the all strings of the table less than the other table.\n-- if the two tables have the same number of chars, return the first table.\n-- Examples\n-- >>> total_match({}, {})\n-- {}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'Hi'})\n-- {'hI', 'Hi'}\n-- >>> total_match({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'})\n-- {'hi', 'admin'}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'hi', 'hi'})\n-- {'hI', 'hi', 'hi'}\n-- >>> total_match({'4'}, {'1', '2', '3', '4', '5'})\n-- {'4'}\nlocal function total_match(lst1, lst2)\n  local total = {}\n  for i = 1, #lst1 do\n    local c = lst1[i]\n    local c2 = lst2[i]\n    if c == c2 then\n      total[#total+1] = c\n    else\n      total[#total+1] = c\n    end\n  end\n  return total\nend"], ["-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100. \n-- Example:\n-- >>> is_multiply_prime(30)\n-- true\n-- 30 = 2 * 3 * 5\nlocal function is_multiply_prime(a)\n  if a < 100 then\n    return true\n  else\n    return false\n  end\nend\n```"], ["-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2, 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3, 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5, 3)\n-- false\nlocal function is_simple_power(x, n)\n  if n == 1 then\n    return true\n  elseif n == 2 then\n    return x == 1\n  else\n    return x % n == 0 and is_simple_power(x / n, n)\n  end\nend\n```"], ["-- Write a function that takes an integer a and returns true \n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- >>> iscube(1)\n-- true\n-- >>> iscube(2)\n-- false\n-- >>> iscube(-1)\n-- true\n-- >>> iscube(64)\n-- true\n-- >>> iscube(0)\n-- true\n-- >>> iscube(180)\n-- false\nlocal function iscube(a)\n  if a == 0 then\n    return false\n  elseif a == 1 then\n    return true\n  elseif a == 2 then\n    return true\n  elseif a == 4 then\n    return true\n  elseif a == 8 then\n    return true\n  elseif a == 16 then\n    return true\n  elseif a == 32 then\n    return true\n  elseif a == 64 then\n    return true\n  else\n    return false\n  end\nend\nreturn iscube"], ["-- You have been tasked to write a function that receives \n-- a hexadecimal number as a string and counts the number of hexadecimal \n-- digits that are primes (prime number, or a prime, is a natural number \n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7, \n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string, \n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>> hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n-- 2\nlocal function hex_key(num)\n  local count = 0\n  for i = 1, #num do\n    local digit = num:sub(i, i)\n    if digit == 'A' or digit == 'B' or digit == 'C' or digit == 'D' or digit == 'E' or digit == 'F' then\n      count = count + 1\n    end\n  end\n  return count\nend -- end of function hex_key"], ["-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n-- 'db100000db'\nlocal function decimal_to_binary(decimal)\n  local binary = ''\n  local count = 0\n  local digit = decimal\n  while digit > 0 do\n    local char = math.floor(digit / 2)\n    digit = digit % 2\n    binary = binary .. char\n    count = count + 1\n    digit = digit % 2\n  end\n  return binary:sub(1, count) .. 'db' .. binary:sub(#binary + 1, #binary)\nend -- function decimal_to_binary\nreturn decimal_to_binary"], ["-- You are given a string s.\n-- Your task is to check if the string is haplua or not.\n-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- >>> is_happy('a')\n-- false\n-- >>> is_happy('aa')\n-- false\n-- >>> is_happy('abcd')\n-- true\n-- >>> is_happy('aabb')\n-- false\n-- >>> is_happy('adb')\n-- true\n-- >>> is_happy('xyy')\n-- false\nlocal function is_happy(s)\n  if #s == 0 then\n    return false\n  end\n  local n = #s\n  local m = 0\n  for i = 1, n do\n    if s:sub(i, i) == s:sub(i + 1, i + 1) then\n      m = m + 1\n    else\n      m = 0\n    end\n  end\n  if m == 3 then\n    return true\n  else\n    return false\n  end\nend\nreturn is_happy"], ["-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a table of GPAs for some students and you have to write \n-- a function that can output a table of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A \n--         > 3.3                A- \n--         > 3.0                B+\n--         > 2.7                B \n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+ \n--         > 0.7                D \n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})\n-- {'A+', 'B', 'C-', 'C', 'A-'}\nlocal function numerical_letter_grade(grades)\n    local letter_grades = {}\n    for i, grade in ipairs(grades) do\n        if grade > 3.7 then\n            table.insert(letter_grades, 'A+')\n        elseif grade > 3.3 then\n            table.insert(letter_grades, 'A')\n        elseif grade > 3.0 then\n            table.insert(letter_grades, 'A-')\n        elseif grade > 2.7 then\n            table.insert(letter_grades, 'B+')\n        elseif grade > 2.3 then\n            table.insert(letter_grades, 'B')\n        elseif grade > 2.0 then\n            table.insert(letter_grades, 'B-')\n        elseif grade > 1.7 then\n            table.insert(letter_grades, 'C+')\n        elseif"], ["-- Write a function that takes a string and returns true if the string\n-- length is a prime number or false otherwise\n-- Examples\n-- >>> prime_length('Hello')\n-- true\n-- >>> prime_length('abcdcba')\n-- true\n-- >>> prime_length('kittens')\n-- true\n-- >>> prime_length('orange')\n-- false\nlocal function prime_length(string)\n  local length = 0\n  for i = 1, #string do\n    if string:sub(i, i) ~= string:sub(i + 1, i + 1) then\n      length = length + 1\n    end\n  end\n  return length == 2\nend -- end of function prime_length\nreturn prime_length"], ["-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n  local count = 0\n  for i = 1, n do\n    if i % 2 == 1 then\n      count = count + 1\n    else\n      count = count + 0\n    end\n  end\n  return count\nend"], ["-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n-- >>> solve(1000)\n-- '1'\n-- >>> solve(150)\n-- '110'\n-- >>> solve(147)\n-- '1100'\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nlocal function solve(N)\n    local sum = 0\n    for I = 1, N do\n        sum = sum + (N % 2 == 1 and 1 or 0)\n        N = math.floor(N / 2)\n    end\n    return string.format('%0' .. (#sum + 1) .. 'd', sum)\nend -- function solve\nreturn solve -- return the function\n```"], ["-- Given a non-empty table of integers lst. add the even elements that are at odd indices..\n-- Examples:\n-- >>> add({4, 2, 6, 7})\n-- 2\nlocal function add(lst)\n  if #lst == 0 then\n    return {}\n  end\n  local result = {}\n  for I = 1, #lst do\n    local even = lst[i]\n    if even % 2 == 0 then\n      result[even] = result[even] or 0\n      result[even] = result[even] + 1\n    end\n  end\n  return result\nend\n```"], ["-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- >>> anti_shuffle('Hi')\n-- 'Hi'\n-- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n-- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n  local n = #s\n  local res = {}\n  for I = 1, n do\n    local j = math.random(1, n)\n    table.insert(res, s:sub(i, j))\n    table.insert(res, s:sub(j + 1, n))\n  end\n  return table.concat(res)\nend\nreturn anti_shuffle"], ["-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n  local y = {}\n  for i = 1, #lst do\n    y[#y + 1] = lst[i][x]\n  end\n  return y\nend"], ["-- Given a table of non-negative integers, return a colua of the given table after sorting,\n-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given table.\n-- Examples:\n-- >>> sort_array({})\n-- {}\n-- >>> sort_array({5})\n-- {5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5})\n-- {0, 1, 2, 3, 4, 5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})\n-- {6, 5, 4, 3, 2, 1, 0}\nlocal function sort_array(array)\n  if array == nil or #array == 0 then\n    return {}\n  end\n  local sorted = {}\n  for i = 1, #array do\n    sorted[#sorted + 1] = array[i]\n  end\n  return sorted\nend\nreturn sort_array"], ["-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated. \n-- The alphabet should be rotated in a manner such that the letters \n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n-- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal function encrypt(s)\n  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local result = ''\n  for I = 1, #alphabet do\n    result = result .. alphabet:sub(i, i) .. alphabet:sub(i + 2, i + 2)\n  end\n  return result .. s\nend\n```"], ["-- You are given a table of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the table.\n-- Return nil if there is no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5, 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1, 1})\n-- None\nlocal function next_smallest(lst)\n  local min = lst[1]\n  for i = 2, #lst do\n    if lst[i] < min then\n      min = lst[i]\n    end\n  end\n  return min\nend\n```"], ["-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored('Hello world')\n-- 0\n-- >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n-- 1\nlocal function is_bored(S)\n  local count = 0\n  for I, v in ipairs(S) do\n    if v == 'I' then\n      count = count + 1\n    end\n  end\n  return count > 0\nend\n```"], ["-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- >>> any_int(5, 2, 7)\n-- true\n-- >>> any_int(3, 2, 2)\n-- false\n-- >>> any_int(3, -2, 1)\n-- true\n-- >>> any_int(3.6, -2.2, 2)\n-- false\nlocal function any_int(x, y, z)\n  return (x == y + z) and (x == y - z) and (x == y * z) and (x == y / z) end\nreturn any_int } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }"], ["-- Write a function that takes a message, and encodes in such a \n-- way that it swaps case of all letters, replaces all vowels in \n-- the message with the letter that appears 2 places ahead of that \n-- vowel in the english alphabet. \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n-- >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n  local result = ''\n  for i = 1, #message do\n    local letter = message:sub(i, i)\n    local next_letter = message:sub(i + 1, i + 1)\n    if next_letter == 'a' then\n      result = result .. letter\n    elseif next_letter == 'e' then\n      result = result .. letter\n    elseif next_letter == 'i' then\n      result = result .. letter\n    elseif next_letter == 'o' then\n      result = result .. letter\n    elseif next_letter == 'u' then\n      result = result .. letter\n    else\n      result = result .. letter\n    end\n  end\n  return result\nend\n```"], ["-- You are given a table of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- >>> skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n-- >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n-- 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0, 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n  local max = 0\n  local sum = 0\n  for i = 1, #lst do\n    local num = tonumber(lst[i])\n    if num > max then\n      max = num\n      sum = sum + num\n    end\n  end\n  return sum\nend -- end of skjkasdkd\nreturn skjkasdkd"], ["-- Given a table, return true if all keys are strings in lower \n-- case or all keys are strings in upper case, else return false.\n-- The function should return false is the given table is empty.\n-- Examples:\n-- >>> check_dict_case({['a'] = 'apple', ['b'] = 'banana'})\n-- true\n-- >>> check_dict_case({['a'] = 'apple', ['A'] = 'banana', ['B'] = 'banana'})\n-- false\n-- >>> check_dict_case({['a'] = 'apple', [8] = 'banana', ['a'] = 'apple'})\n-- false\n-- >>> check_dict_case({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'})\n-- false\n-- >>> check_dict_case({['STATE'] = 'NC', ['ZIP'] = '12345'})\n-- true\nlocal function check_dict_case(dict)\n  if #dict == 0 then\n    return true\n  end\n  for k, v in pairs(dict) do\n    if type(k) ~= 'string' then\n      return false\n    end\n    if type(v) ~= 'string' then\n      return false\n    end\n    if v:lower() ~= k:lower() then\n      return false\n    end\n  end\n  return true\nend\nreturn check_dict_case"], ["-- Implement a function that takes an non-negative integer and returns a table of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- >>> count_up_to(5)\n-- {2, 3}\n-- >>> count_up_to(11)\n-- {2, 3, 5, 7}\n-- >>> count_up_to(0)\n-- {}\n-- >>> count_up_to(20)\n-- {2, 3, 5, 7, 11, 13, 17, 19}\n-- >>> count_up_to(1)\n-- {}\n-- >>> count_up_to(18)\n-- {2, 3, 5, 7, 11, 13, 17}\nlocal function count_up_to(n)\n  local result = {}\n  for i = 2, n do\n    if is_prime(i) then\n      table.insert(result, i)\n    end\n  end\n  return result\nend -- end of function count_up_to"], ["-- Complete the function that takes two integers and returns \n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020, 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n  if b == 0 then\n    return 1\n  elseif b == 1 then\n    return a\n  else\n    return a * multiply(a, b - 1)\n  end\nend\n```"], ["-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- >>> count_upper('aBCdEf')\n-- 1\n-- >>> count_upper('abcdefg')\n-- 0\n-- >>> count_upper('dBBE')\n-- 0\nlocal function count_upper(s)\n  local count = 0\n  for i = 1, #s do\n    if s:sub(i, i) == 'A' then\n      count = count + 1\n    end\n  end\n  return count\nend -- function count_upper"], ["-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n-- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n  local closest = math.floor(value)\n  if closest == value then\n    return closest\n  end\n  local diff = math.abs(value - closest)\n  if diff < 0.0000000001 then\n    return closest\n  end\n  return closest + 0.5\nend\nreturn closest_integer"], ["-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a table, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n-- {3, 5, 7}\nlocal function make_a_pile(n)\n  local result = {}\n  for i = 1, n do\n    result[i] = 0\n  end\n  return result\nend\n```"], ["-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return a table of the words.\n-- For example:\n-- >>> words_string('Hi, my name is John')\n-- {'Hi', 'my', 'name', 'is', 'John'}\n-- >>> words_string('One, two, three, four, five, six')\n-- {'One', 'two', 'three', 'four', 'five', 'six'}\nlocal function words_string(s)\n  local words = {}\n  for word in string.gmatch(s, '([^,]+)') do\n    table.insert(words, word)\n  end\n  return words\nend -- end of function words_string"], ["-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If \n-- there's no such number, then the function should return -1.\n-- For example:\n-- >>> choose_num(12, 15)\n-- 14\n-- >>> choose_num(13, 12)\n-- -1\nlocal function choose_num(x, y)\n  if x < y then\n    return choose_num(y, x)\n  else\n    return choose_num(x, y - 1)\n  end\nend\n```"], ["-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m). \n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7, 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n-- '0b11010'\nlocal function rounded_avg(n, m)\n  local avg = 0\n  local count = 0\n  for i = n, m do\n    local num = tonumber(i)\n    if num ~= nil then\n      count = count + 1\n      avg = avg + num\n    end\n  end\n  if count == 0 then\n    return -1\n  end\n  return avg / count\nend"], ["-- Given a table of positive integers x. return a sorted table of all \n-- elements that hasn't any even digit.\n-- Note: Returned table should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits({15, 33, 1422, 1})\n-- {1, 15, 33}\n-- >>> unique_digits({152, 323, 1422, 10})\n-- {}\nlocal function unique_digits(x)\n  local result = {}\n  for i = 1, #x do\n    if not (i % 2 == 0) then\n      result[i] = x[i]\n    end\n  end\n  return result\nend"], ["-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting table, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})\n-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}\n--   If the table is empty, return an empty table:\n-- >>> by_length({})\n-- {}\n--   If the table has any strange number ignore it:\n-- >>> by_length({1, -1, 55})\n-- {'One'}\nlocal function by_length(arr)\n  if #arr == 0 then\n    return {}\n  end\n  local result = {}\n  for i = 1, #arr do\n    local name = arr[i]\n    if name ~= nil then\n      result[name] = i\n    end\n  end\n  return result\nend\nreturn by_length"], ["-- Implement the function f that takes n as a parameter,\n-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- >>> f(5)\n-- {1, 2, 6, 24, 15}\nlocal function f(n)\n  if n == 0 then return {} end\n  local result = {}\n  for i = 1, n do\n    result[i] = f(i)\n  end\n  return result\nend\n```"], ["-- Given a positive integer n, return a table that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n-- >>> even_odd_palindrome(3)\n-- {1, 2}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n-- >>> even_odd_palindrome(12)\n-- {4, 6}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned table has the number of even and odd integer palindromes respectively.\nlocal function even_odd_palindrome(n)\n  local result = {}\n  for i = 1, n do\n    local even_odd = even_odd_palindrome(i)\n    result[i] = even_odd[1] + even_odd[2]\n  end\n  return result\nend\n```"], ["-- Write a function count_nums which takes a table of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums({})\n-- 0\n-- >>> count_nums({-1, 11, -11})\n-- 1\n-- >>> count_nums({1, 1, 2})\n-- 3\nlocal function count_nums(arr)\n  local count = 0\n  for _, num in ipairs(arr) do\n    if num > 0 and num:match(\"%d\") then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["-- We have a table 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the table will be randomly ordered. Your task is to determine if\n-- it is possible to get a table sorted in non-decreasing order by performing \n-- the following operation on the given table:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the table by one\n-- position in the right direction. The last element of the table will be moved to\n-- the starting position in the table i.e. 0th index. \n-- If it is possible to obtain the sorted table by performing the above operation\n-- then return true else return false.\n-- If the given table is empty then return true.\n-- Note: The given table is guaranteed to have unique elements.\n-- For Example:\n-- >>> move_one_ball({3, 4, 5, 1, 2})\n-- true\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given table.\n-- >>> move_one_ball({3, 5, 4, 1, 2})\n-- false\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             table by performing any number of right shift operations.\nlocal function move_one_ball(arr)\n  if #arr == 0 then\n    return true\n  end\n  local n = #arr\n  local new_arr = {}\n  for i = 1, n do\n    new_arr[i] = arr[i]\n  end\n  new_arr[n] = arr[n]\n  return move_one_ball(new_arr)\nend\nreturn move_one_ball"], ["-- In this problem, you will implement a function that takes two tables of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a table of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\nlocal function exchange(lst1, lst2)\n  local even = {}\n  for I = 1, #lst1 do\n    if lst1[i] % 2 == 0 then\n      even[i] = lst1[i]\n    end\n  end\n  for I = 1, #lst2 do\n    if lst2[i] % 2 == 0 then\n      lst2[i] = even[lst2[i]]\n    end\n  end\n  return #lst1 == #lst2 and #even == #lst1 and #even == #lst2\nend\nreturn exchange end"], ["-- Given a string representing a space separated lowercase letters, return a table\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- >>> histogram('a b c')\n-- {['a'] = 1, ['b'] = 1, ['c'] = 1}\n-- >>> histogram('a b b a')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('a b c a b')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('b b b b a')\n-- {['b'] = 4}\n-- >>> histogram('')\n-- {}\nlocal function histogram(test)\n  local testString = test:gsub('[^a-z]', '')\n  local table = {}\n  local count = 0\n  for i = 1, #testString do\n    local letter = testString:sub(i, i)\n    if table[letter] then\n      table[letter] = table[letter] + 1\n    else\n      table[letter] = 1\n    end\n  end\n  return table\nend"], ["-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a table containing the result string and true/false for the check.\n-- Example\n-- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n-- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba', 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n  local result = {}\n  local i = 1\n  local j = #s\n  while i <= j do\n    if s:sub(i, j) == c then\n      table.insert(result, s:sub(i, j))\n      i = i + 1\n      j = j - 1\n    else\n      break\n    end\n  end\n  return {table.concat(result, ''), true}\nend"], ["-- Given a table of strings, where each string consists of only digits, return a table.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count({'1234567'})\n-- {'the number of odd elements 4n the str4ng 4 of the 4nput.'}\n-- >>> odd_count({'3', '11111111'})\n-- {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'}\nlocal function odd_count(lst)\n  local count = {}\n  for i = 1, #lst do\n    local num = tonumber(lst[i])\n    if num ~= nil then\n      count[num] = count[num] or 1\n      count[num] = count[num] + 1\n    end\n  end\n  return count\nend\nreturn odd_count(lst)"], ["-- Given a table of integers nums, find the minimum sum of any non-empty sub-table\n-- of nums.\n-- Example\n-- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n-- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n  local min = math.max(nums[1], nums[2])\n  for i = 3, #nums do\n    local sum = 0\n    for j = 1, i do\n      sum = sum + nums[j]\n      if sum < min then\n        min = sum\n      end\n    end\n    min = math.min(min, sum)\n  end\n  return min\nend -- end of function minSubArraySum"], ["-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it, \n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n  local max_fill = 0\n  for I = 1, #grid do\n    for j = 1, #grid[i] do\n      if grid[i][j] == 1 then\n        local bucket = grid[i][j]\n        local bucket_capacity = bucket * capacity\n        if bucket_capacity > max_fill then\n          max_fill = bucket_capacity\n        end\n      end\n    end\n  end\n  return max_fill\nend -- function max_fill\n```"], ["-- In this Kata, you have to sort a table of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2, -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n-- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n  local sorted_arr = {}\n  for i = 1, #arr do\n    local num = arr[i]\n    local num_str = tostring(num)\n    local num_dec = tonumber(num_str)\n    if num_dec > 0 then\n      sorted_arr[#sorted_arr + 1] = num\n    else\n      sorted_arr[#sorted_arr + 1] = -num\n    end\n  end\n  return sorted_arr\nend\nreturn sort_array } }\n```"], ["-- Given a string s and a natural number n, you have been tasked to implement \n-- a function that returns a table of all words from string s that contain exactly \n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty table.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- >>> select_words('Mary had a little lamb', 4)\n-- {'little'}\n-- >>> select_words('Mary had a little lamb', 3)\n-- {'Mary', 'lamb'}\n-- >>> select_words('simple white space', 2)\n-- {}\n-- >>> select_words('Hello world', 4)\n-- {'world'}\n-- >>> select_words('Uncle sam', 3)\n-- {'Uncle'}\nlocal function select_words(s, n)\n  local result = {}\n  for word in string.gmatch(s, \"([^%s]+)%s*\") do\n    if #word == n then\n      table.insert(result, word)\n    end\n  end\n  return result\nend"], ["-- You are given a word. Your task is to find the closest vowel that stands between \n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition. \n-- You may assume that the given string contains English letter only.\n-- Example:\n-- >>> get_closest_vowel('yogurt')\n-- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n-- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local closest_vowel = ''\n  for I = 1, #vowels do\n    local vowel_index = string.find(word, string.format('(%s)', vowels[i]))\n    if vowel_index then\n      local vowel = string.sub(word, vowel_index + 1, vowel_index + 2)\n      if vowels[i] == vowel then\n        closest_vowel = vowel\n      end\n    end\n  end\n  return closest_vowel\nend"], ["-- You are given a table of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(', ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n  if lst[1] == '(' and lst[2] == ')' then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend"], ["-- Given a table arr of integers and a positive integer k, return a sorted table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>> maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4, 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n-- {2}\n-- Note:\n--     1. The length of the table will be in the range of [1, 1000].\n--     2. The elements in the table will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n  local max = {}\n  local max_index = 1\n  for I = 1, k do\n    if arr[i] > max[max_index] then\n      max_index = i\n      max = {arr[i], i}\n    end\n  end\n  return max\nend -- function maximum\nreturn maximum(arr, k)"], ["-- Given a non-empty table of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- >>> solution({5, 8, 7, 1})\n-- 12\n-- >>> solution({3, 3, 3, 3, 3})\n-- 9\n-- >>> solution({30, 13, 24, 321})\n-- 0\nlocal function solution(lst)\n  local sum = 0\n  for I = 1, #lst do\n    if lst[i] % 2 == 0 then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n```"], ["-- Given a non-empty table of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n-- 24\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nlocal function add_elements(arr, k)\n  if k == 0 then\n    return 0\n  end\n  local sum = 0\n  for I = 1, k do\n    local digit = arr[i]\n    if digit > 9 then\n      digit = digit % 10\n    end\n    sum = sum + digit\n  end\n  return sum\nend -- add_elements"], ["-- Given a positive integer n, return a sorted table that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the \n-- previous term as follows: if the previous term is even, the next term is one half of \n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note: \n--     1. Collatz(1) is [1].\n--     2. returned table sorted in increasing order.\n-- For example:\n-- get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n-- >>> get_odd_collatz(5)\n-- {1, 5}\nlocal function get_odd_collatz(n)\n  local table = {}\n  local odd_num = 1\n  local even_num = 1\n  for I = 1, n do\n    if odd_num % 2 == 0 then\n      even_num = even_num + 1\n    else\n      odd_num = odd_num + 1\n    end\n    table[odd_num] = even_num\n  end\n  return table\nend\nreturn get_odd_collatz"], ["-- You have to write a function which validates a given date string and\n-- returns true if the date is valid otherwise false.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- >>> valid_date('03-11-2000')\n-- true\n-- >>> valid_date('15-01-2012')\n-- false\n-- >>> valid_date('04-0-2040')\n-- false\n-- >>> valid_date('06-04-2020')\n-- true\n-- >>> valid_date('06/04/2020')\n-- false\nlocal function valid_date(date)\n  local month = string.match(date, \"%d-%d-%d\")\n  local year = string.match(date, \"%d-%d-%d-%d-%d-%d\")\n  local day = string.match(date, \"%d-%d-%d-%d-%d-%d\")\n  local month_len = tonumber(month)\n  local year_len = tonumber(year)\n  local day_len = tonumber(day)\n  if month_len < 1 or month_len > 12 then\n    return false\n  end\n  if year_len < 1 or year_len > 40 then\n    return false\n  end\n  if day_len < 1 or day_len > 30 then\n    return false\n  end\n  return true\nend\nreturn valid_date"], ["-- Given a string of words, return a table of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n  local words = {}\n  local word = {}\n  local i = 1\n  local j = 1\n  local c = txt:sub(i, i)\n  while c ~= ' ' do\n    if c == ',' then\n      table.insert(words, word)\n      word = {}\n      j = j + 1\n    else\n      word[j] = c\n      j = j + 1\n    end\n    c = txt:sub(i, i)\n    i = i + 1\n  end\n  if j > 1 then\n    table.insert(words, word)\n  end\n  return words\nend\nreturn split_words"], ["-- Given a table of numbers, return whether or not they are sorted\n-- in ascending order. If table has more than 1 duplicate of the same\n-- number, return false. Assume no negative numbers and only integers.\n-- Examples\n-- >>> is_sorted({5})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n-- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3, 4})\n-- false\nlocal function is_sorted(lst)\n  if #lst < 2 then return false end\n  local sorted = {}\n  for i = 1, #lst do\n    local num = lst[i]\n    if sorted[num] then\n      sorted[num] = true\n    else\n      sorted[num] = true\n      sorted[num] = num\n    end\n  end\n  return sorted == lst\nend\nreturn is_sorted"], ["-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two \n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1, interval2)\n  local start1, end1 = interval1.start, interval1.end\n  local start2, end2 = interval2.start, interval2.end\n  if start1 > end2 then\n    return \"NO\"\n  end\n  if start2 > end1 then\n    return \"NO\"\n  end\n  local start = math.min(start1, start2)\n  local end = math.max(end1, end2)\n  return (end - start) % 2 == 1\nend\nreturn intersection(input1, input2)"], ["-- You are given a table arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the table, represented by 1, -1 or 0.\n-- Note: return nil for empty arr.\n-- Example:\n-- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n-- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n  if #arr == 0 then\n    return nil\n  end\n  local prod = 1\n  for i = 1, #arr do\n    local sign = arr[i]\n    if sign == 1 then\n      prod = prod * 1\n    elseif sign == -1 then\n      prod = prod * -1\n    else\n      prod = prod * sign\n    end\n  end\n  return prod\nend -- end of prod_signs\nreturn prod_signs"], ["-- Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered tables of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered table of the values on the cells that the minimum path go through.\n-- Examples:    \n-- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid, k)\n  local visited = {}\n  local visited_lst = {}\n  local visited_lst_size = 0\n  local visited_lst_index = 1\n  local visited_lst_table = {}\n  for I = 1, k do\n    visited_lst[visited_lst_index] = grid[i][visited_lst_index]\n    visited_lst"], ["-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri(1) = 3\n-- tri(n) = 1 + n / 2, if n is even.\n-- tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n-- For example:\n-- tri(2) = 1 + (2 / 2) = 2\n-- tri(4) = 3\n-- tri(3) = tri(2) + tri(1) + tri(4)\n--        = 2 + 3 + 3 = 8 \n-- You are given a non-negative integer number n, you have to a return a table of the \n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- >>> tri(3)\n-- {1, 3, 2, 8}\nlocal function tri(n)\n  local result = {}\n  result[1] = 1\n  result[2] = 3\n  for i = 3, n do\n    result[i] = result[i - 1] + result[i - 2] + result[i - 3]\n  end\n  return result\nend\nreturn tri(1)"], ["-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- >>> digits(1)\n-- 1\n-- >>> digits(4)\n-- 0\n-- >>> digits(235)\n-- 15\nlocal function digits(n)\n  if n == 0 then\n    return 0\n  else\n    local result = 0\n    for i = 1, math.floor(n / 10) do\n      result = result * 10 + n % 10\n      n = math.floor(n / 10)\n    end\n    return result\n  end\nend\n```"], ["-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return true if and only if there is a valid subsequence of brackets \n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n-- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n-- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal function is_nested(string)\n  local brackets = {}\n  for i = 1, #string do\n    if string:sub(i, i) == '[' then\n      table.insert(brackets, string:sub(i, i))\n    else\n      table.insert(brackets, string:sub(i, i))\n    end\n  end\n  return #brackets > 1 and #brackets[1] == #brackets[2] and #brackets[2] > 1 and #brackets[2][1] == #brackets[2][2] and #brackets[2][2] > 1 and #brackets[2][2][1] == #brackets[2][3] and #brackets[2][3] > 1 and #brackets[2][3][1] == #brackets[2][4] and #brackets[2][4] > 1 and #brackets[2][4][1] == #brackets[2][5] and #brackets[2][5] > 1 and #brackets[2][5][1] == #brackets[2][6] and #brackets[2][6] > 1 and #brackets[2][6][1] == #brackets[2][7] and #brackets[2][7] > 1 and #brackets[2][7][1] == #brackets[2][8] and #brackets[2][8] > 1 and #brackets[2][8][1] == #brackets[2][9] and #brackets[2][9] > 1 and"], ["-- You are given a table of numbers.\n-- You need to return the sum of squared numbers in the given table,\n-- round each element in the table to the upper int(Ceiling) first.\n-- Examples:\n-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0, 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n-- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n  local sum = 0\n  for i = 1, #lst do\n    sum = sum + lst[i] * lst[i]\n  end\n  return sum\nend\n```"], ["-- Create a function that returns true if the last character\n-- of a given string is an alphabetical character and is not\n-- a part of a word, and false otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n-- Examples:\n-- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>> check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal function check_if_last_char_is_a_letter(txt)\n  local last_char = txt:sub(#txt - 1, #txt)\n  return last_char ~= ' ' and last_char ~= '.' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?' and last_char ~= '!' and last_char ~= '?'"], ["-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given table will not contain\n-- duplicate values.\n-- Examples:\n-- >>> can_arrange({1, 2, 4, 3, 5})\n-- 3\n-- >>> can_arrange({1, 2, 3})\n-- -1\nlocal function can_arrange(arr)\n  local max_index = 0\n  for i = 1, #arr do\n    if arr[i] > arr[i - 1] then\n      max_index = i\n    end\n  end\n  return max_index + 1\nend -- end of function can_arrange"], ["-- Create a function that returns a table (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n-- If there is no negative or positive integers, return them as nil.\n-- Examples:\n-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n-- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function largest_smallest_integers(lst)\n  local max = 0\n  local min = 0\n  for _, num in ipairs(lst) do\n    if num < 0 then\n      max = max + num\n    else\n      min = min + num\n    end\n  end\n  return {max, min}\nend -- end of function"], ["-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return nil if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one(1, 2.5)\n-- 2.5\n-- >>> compare_one(1, '2,3')\n-- '2,3'\n-- >>> compare_one('5,1', '6')\n-- '6'\n-- >>> compare_one('1', 1)\n-- None\nlocal function compare_one(a, b)\n  if type(a) ~= 'number' or type(b) ~= 'number' then\n    return nil\n  end\n  if type(a) == 'number' and type(b) == 'number' then\n    return a > b\n  elseif type(a) == 'string' and type(b) == 'string' then\n    return a > b\n  else\n    return a > b\n  end\nend\nreturn compare_one"], ["-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even(4)\n-- false\n-- >>> is_equal_to_sum_even(6)\n-- false\n-- >>> is_equal_to_sum_even(8)\n-- true\nlocal function is_equal_to_sum_even(n)\n  if n < 0 then\n    return false\n  elseif n == 0 then\n    return true\n  elseif n == 1 then\n    return true\n  elseif n == 2 then\n    return true\n  elseif n == 3 then\n    return true\n  elseif n == 4 then\n    return true\n  elseif n == 5 then\n    return true\n  elseif n == 6 then\n    return true\n  elseif n == 7 then\n    return true\n  elseif n == 8 then\n    return true\n  elseif n == 9 then\n    return true\n  elseif n == 10 then\n    return true\n  elseif n == 11 then\n    return true\n  elseif n == 12 then\n    return true\n  elseif n == 13 then\n    return true\n  elseif n == 14 then\n    return true\n  elseif n == 15 then\n    return true\n  elseif n == 16 then\n    return true\n  elseif n == 17 then\n    return true\n  elseif n == 18 then\n    return true\n  elseif n == 19 then\n    return true\n  elseif n == 20 then\n    return true\n  elseif n == 21 then\n    return true\n  elseif n == 22 then\n    return true\n  elseif n == 23 then\n    return true\n  elseif n == 24 then\n    return true\n  elseif n == 25 then\n    return true\n  elseif n == 26 then\n    return true\n  elseif n == 27 then\n    return true\n  elseif n == 28 then\n    return true\n  elseif n == 29"], ["-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial(4)\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nlocal function special_factorial(n)\n  if n == 0 then\n    return 1\n  end\n  return n * special_factorial(n-1) * special_factorial(n-2) * ... * 1\nend -- function special_factorial"], ["-- Given a string text, replace all spaces in it with underscores, \n-- and if a string has more than 2 consecutive spaces, \n-- then replace all consecutive spaces with - \n-- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces(' Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n-- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n  local new_text = ''\n  for i = 1, #text do\n    if text:match('^%s+') then\n      new_text = new_text .. '_'\n    else\n      new_text = new_text .. text:sub(i, i)\n    end\n  end\n  return new_text\nend\nreturn fix_spaces"], ["-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions \n-- are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from \n-- the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check('example.txt')\n-- 'Yes'\n-- >>> file_name_check('1example.dll')\n-- 'No'\nlocal function file_name_check(file_name)\n  local file_name_parts = string.gsub(file_name, '[^%a%d%s%_]', '')\n  local file_name_parts_len = #file_name_parts\n  local file_name_parts_len_2 = #file_name_parts_len\n  local file_name_parts_len_3 = #file_name_parts_len_2\n  local file_name_parts_len_4 = #file_name_parts_len_3\n  local file_name_parts_len_5 = #file_name_parts_len_4\n  local file_name_parts_len_6 = #file_name_parts_len_5\n  local file_name_parts_len_7 = #file_name_parts_len_6\n  local file_name_parts_len_8 = #file_name_parts_len_7\n  local file_name_parts_len_9 = #file_name_parts_len_8\n  local file_name_parts_len_10 = #file_name_parts_len_9\n  local file_name_parts_len_11 = #file_name_parts_len_10\n  local file_name_parts_"], ["-- \"\n-- This function will take a table of integers. For all entries in the table, the function shall square the integer entry if its index is a \n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n-- change the entries in the table whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n-- Examples:\n-- >>> lst\n-- {1, 2, 3}\n-- >>> lst\n-- {}\n-- >>> lst\n-- {-1, -5, 2, -1, -5}\nlocal function sum_squares(lst)\n  local sum = 0\n  for i = 1, #lst do\n    if lst[i] % 3 == 0 and lst[i] % 4 ~= 0 then\n      sum = sum + lst[i] * lst[i]\n    elseif lst[i] % 3 ~= 0 then\n      sum = sum + lst[i]\n    elseif lst[i] % 4 ~= 0 then\n      sum = sum + lst[i] * lst[i]\n    end\n  end\n  return sum\nend -- end of function sum_squares"], ["-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n-- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n--     * 1 <= len(sentence) <= 100\n--     * sentence contains only letters\nlocal function words_in_sentence(sentence)\n    local words = {}\n    for word in sentence:gmatch('[^%s]+') do\n        if #word > 1 then\n            table.insert(words, word)\n        end\n    end\n    return table.concat(words, ' ') end -- function to return the words in a sentence\nreturn words_in_sentence(sentence)"], ["-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns true if x * n evaluates to a whole number and false\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n-- >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\nlocal function simplify(x, n)\n  if x == '1' then\n    return true\n  elseif n == '1' then\n    return false\n  elseif x == '0' then\n    return false\n  elseif n == '0' then\n    return true\n  elseif x == '.' and n == '.' then\n    return false\n  elseif x == '.' and n ~= '.' then\n    return simplify(x, n)\n  elseif x ~= '.' and n ~= '.' then\n    return simplify(x, n)\n  else\n    return false\n  end\nend\nreturn simplify"], ["-- Write a function which sorts the given table of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original table.\n-- For example:\n-- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1, -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n  local sorted_nums = {}\n  for _, num in ipairs(nums) do\n    local sum = 0\n    for _, digit in ipairs(num) do\n      sum = sum + digit\n    end\n    sorted_nums[#sorted_nums + 1] = sum\n  end\n  return sorted_nums\nend\n```"], ["-- Write a function that takes a table of numbers as input and returns \n-- the number of elements in the table that are greater than 10 and both \n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter({15, -73, 14, -15})\n-- 1\n-- >>> specialFilter({33, -2, -3, 45, 21, 109})\n-- 2\nlocal function specialFilter(nums)\n  local count = 0\n  for _, num in ipairs(nums) do\n    if num > 10 and (num:match(\"%d%d%d\") ~= nil and num:match(\"%d%d%d\") ~= nil) and (num:match(\"%d%d%d\") ~= nil and num:match(\"%d%d%d\") ~= nil) and (num:match(\"%d%d%d\") ~= nil and num:match(\"%d%d%d\") ~= nil) then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["-- You are given a positive integer n. You have to create an integer table a of length n.\n-- For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n--     and a[i] + a[j] + a[k] is a multiple of 3.\n--     Example :\n--     >>> get_max_triples(5)\n--     1\n-- Explanation: \n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nlocal function get_max_triples(n)\n    local a = {}\n    for i = 1, n do\n        a[i] = i * i - i + 1\n    end\n    return #a\nend\nreturn get_max_triples(1000000)"], ["-- There are eight planets in our solar system: the closerst to the Sun \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2. \n-- The function should return a table containing all planets whose orbits are \n-- located between the orbit of planet1 and the orbit of planet2, sorted by \n-- the proximity to the sun. \n-- The function should return an empty table if planet1 or planet2\n-- are not correct planet names. \n-- Examples\n-- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n-- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\nlocal function bf(planet1, planet2)\n  local table = {}\n  for i = 1, 8 do\n    if planet1 == table[i] and planet2 == table[i + 1] then\n      table[i + 1] = table[i]\n      table[i] = planet2\n    end\n  end\n  return table\nend\n```"], ["-- Write a function that accepts a table of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted table with a sorted order,\n-- The table is always a table of strings and never a table of numbers,\n-- and it may contain duplicates.\n-- The order of the table should be ascending by length of each word, and you\n-- should return the table sorted by that rule.\n-- If two words have the same length, sort the table alphabetically.\n-- The function should return a table of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> list_sort({'aa', 'a', 'aaa'})\n-- {'aa'}\n-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})\n-- {'ab', 'cd'}\nlocal function sorted_list_sum(lst)\n  local sorted_lst = {}\n  for i, v in ipairs(lst) do\n    if v:len() % 2 == 0 then\n      table.insert(sorted_lst, v)\n    else\n      table.insert(sorted_lst, v:sub(1, v:len() - 1))\n    end\n  end\n  return sorted_lst\nend\nreturn sorted_list_sum"], ["-- A simple program which should return the value of x if n is \n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y(7, 34, 12)\n-- 34\n-- >>> x_or_y(15, 8, 5)\n-- 5\nlocal function x_or_y(n, x, y)\n  if n == 2 or n == 3 then\n    return x\n  elseif n == 5 then\n    return y\n  elseif n == 7 then\n    return x + y\n  else\n    return x_or_y(n, x, y)\n  end\nend"], ["-- Given a table of numbers, return the sum of squares of the numbers\n-- in the table that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference({1, 3, 2, 0})\n-- 10\n-- >>> double_the_difference({-1, -2, 0})\n-- 0\n-- >>> double_the_difference({9, -2})\n-- 81\n-- >>> double_the_difference({0})\n-- 0\n-- If the input table is empty, return 0.\nlocal function double_the_difference(lst)\n  if #lst == 0 then\n    return 0\n  end\n  local sum = 0\n  for I = 1, #lst do\n    local num = lst[i]\n    if num ~= 0 and num ~= -1 then\n      sum = sum + num * num\n    end\n  end\n  return sum\nend\n```"], ["-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two tables of scores and guesses of equal length, where each index shows a match. \n-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})\n-- {0, 0, 0, 0, 3, 3}\n-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})\n-- {4, 4, 1, 0, 0, 6}\nlocal function compare(game, guess)\n  local score = 0\n  for i, v in ipairs(game) do\n    if v == guess[i] then\n      score = score + 1\n    end\n  end\n  return {score, score - guess[#game]} end ```"], ["-- You will be given the name of a class (a string) and a table of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters \n-- in the extension's name, the strength is given by the fraction CAP - SM. \n-- You should find the strongest extension and return a string in this \n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the table.\n-- For example, if you are given \"Slices\" as the class and a table of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n-- (its strength is -1).\n-- Example:\n-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name, extensions)\n  local strongest_extension = \"\"\n  for i, extension in ipairs(extensions) do\n    if class_name:find(extension, 1, true) then\n      strongest_extension = extension\n      break\n    end\n  end\n  return strongest_extension\nend\n```"], ["-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check('abcd', 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup', 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef', 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal function cycpattern_check(a, b)\n  local a_len = #a\n  local b_len = #b\n  local i = 1\n  while i <= a_len do\n    local j = 1\n    while j <= b_len do\n      if a[i] == b[j] then\n        local k = j + 1\n        while k <= a_len do\n          if a[k] == b[j] then\n            return true\n          end\n          k = k + 1\n        end\n      end\n      j = j + 1\n    end\n    i = i + 1\n  end\n  return false\nend\n```"], ["-- Given an integer. return a table that has the number of even and odd digits respectively.\n-- Example:\n--     >>> even_odd_count(-12)\n--     {1, 1}\n--     >>> even_odd_count(123)\n--     {1, 2}\nlocal function even_odd_count(num)\n  local result = {}\n  for i = 1, 10 do\n    result[i] = 0\n  end\n  for i = 1, 10 do\n    if i % 2 == 0 then\n      result[i] = result[i] + 1\n    else\n      result[i] = result[i] - 1\n    end\n  end\n  return result\nend\n```"], ["-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n  local result = ''\n  local i = 1\n  while i <= number do\n    local letter = string.char(i)\n    if letter == 'I' then\n      result = result .. 'i'\n    elseif letter == 'V' then\n      result = result .. 'v'\n    elseif letter == 'X' then\n      result = result .. 'x'\n    elseif letter == 'L' then\n      result = result .. 'l'\n    else\n      result = result .. 'i'\n    end\n    i = i + 1\n  end\n  return result\nend -- function int_to_mini_roman\nreturn int_to_mini_roman"], ["-- Given the lengths of the three sides of a triangle. Return true if the three\n-- sides form a right-angled triangle, false otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or \n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle(3, 4, 5)\n-- true\n-- >>> right_angle_triangle(1, 2, 3)\n-- false\nlocal function right_angle_triangle(a, b, c)\n  return a == b and b == c and a == c\nend"], ["-- Write a function that accepts a table of strings.\n-- The table contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max({'name', 'of', 'string'})\n-- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n  local max_word = {}\n  local max_char = 0\n  for word, char in pairs(words) do\n    if char > max_char then\n      max_word = word\n      max_char = char\n    end\n  end\n  return max_word\nend\n```"], ["-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return a table of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat(5, 6, 10)\n-- {11, 4}\n-- >>> eat(4, 8, 9)\n-- {12, 1}\n-- >>> eat(1, 10, 10)\n-- {11, 0}\n-- >>> eat(2, 11, 5)\n-- {7, 0}\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n  if number < 0 or number > 1000 then\n    error(\"number must be between 0 and 1000\")\n  end\n  if need < 0 or need > 1000 then\n    error(\"need must be between 0 and 1000\")\n  end\n  if remaining < 0 or remaining > 1000 then\n    error(\"remaining must be between 0 and 1000\")\n  end\n  local result = {number, need, remaining}\n  return result\nend"], ["-- Given two tables operator, and operand. The first table has basic algebra operations, and \n-- the second table is a table of integers. Use the two given tables to build the algebric \n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + ) \n-- Subtraction ( - ) \n-- Multiplication ( * ) \n-- Floor division ( // ) \n-- Exponentiation ( ** ) \n-- Example:\n-- operator['+', '*', '-']\n-- table = [2, 3, 4, 5]\n-- result = 2 + 3 * 4 - 5\n-- => result = 9\n-- Note:\n--     The length of operator table is equal to the length of operand table minus one.\n--     Operand is a table of of non-negative integers.\n--     Operator table has at least one operator, and operand table has at least two operands.\nlocal function do_algebra(operator, operand)\n    local result = 0\n    for i = 1, #operand do\n        local operand_i = operand[i]\n        if operator[i] == '+' then\n            result = result + operand_i\n        elseif operator[i] == '-' then\n            result = result - operand_i\n        elseif operator[i] == '*' then\n            result = result * operand_i\n        elseif operator[i] == '/' then\n            result = result / operand_i\n        end\n    end\n    return result\nend"], ["-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa, \n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve('1234')\n-- '4321'\n-- >>> solve('ab')\n-- 'AB'\n-- >>> solve('#a@C')\n-- '#A@c'\nlocal function solve(s)\n  local result = ''\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    if c == 'a' or c == 'A' then\n      result = result .. string.upper(c)\n    else\n      result = result .. string.lower(c)\n    end\n  end\n  return result\nend\n```"], ["-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return nil.\n-- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\nlocal function string_to_md5(text)\n  if text == nil then\n    return nil\n  end\n  local hash = {}\n  for i = 1, #text do\n    local char = text:sub(i, i)\n    hash[#hash + 1] = char:byte()\n  end\n  return table.concat(hash, ':')\nend"], ["-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers(2, 8)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10, 14)\n-- {}\nlocal function generate_integers(a, b)\n  if b < a then\n    return generate_integers(b, a)\n  end\n  local result = {}\n  for i = a, b do\n    result[i] = i\n  end\n  return result\nend\n```"]]