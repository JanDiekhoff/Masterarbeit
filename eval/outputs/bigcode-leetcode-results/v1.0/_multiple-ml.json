[["(**Check if in given list of numbers, are any two numbers closer to each other than\n * given threshold.\n * >>> has_close_elements [1.0; 2.0; 3.0] 0.5\n * false\n * >>> has_close_elements [1.0; 2.8; 3.0; 4.0; 5.0; 2.0] 0.3\n * true\n*)\nlet has_close_elements (numbers : float list) (threshold : float) : bool =\n  let rec loop (numbers, threshold) = function\n    | [] -> true\n    | (x, y) :: rest when x <= threshold && y <= threshold ->\n        loop (numbers, threshold) rest\n    | _ -> false\n  in\n  loop (numbers, threshold) numbers\n;;"], ["(**Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n * separate those group into separate strings and return the list of those.\n * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n * Ignore any spaces in the input string.\n * >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n * [\"()\"; \"(())\"; \"(()())\"]\n*)\nlet separate_paren_groups (paren_string : string) : string list =\n  let rec separate_groups (groups : string list) : string list = function\n    | [] -> []\n    | (group : string) :: groups ->\n        let open_braces = group.IndexOf '(' in\n        let open_braces_end = open_braces + 1 in\n        let close_braces = group.IndexOf ')' in\n        let close_braces_end = close_braces + 1 in\n        let open_braces_end_minus_close_braces = open_braces_end - close_braces_end in\n        let open_braces_end_minus_close_braces_minus_one = open_braces_end_minus_close_braces - 1 in\n        let open_braces_end_minus_close_braces_minus_one_minus_one = open_braces_end_minus_close_braces_minus_one - 1 in\n        let open_braces_end_minus_close_braces_minus_one_minus_one_minus_one = open_braces_end_minus_close_braces_minus_one_minus_one - 1 in\n        let open_braces_end_minus_close_braces_minus_one_minus_one_minus_one_minus_one = open_braces_end_minus_close_braces_minus_one_minus_one_minus_one - 1 in\n        let open_braces_end_minus_close_braces_minus_one_minus_one_minus_one_minus_one_minus_one = open_braces_end_minus_close_braces_minus_one_minus"], ["(**Given a positive floating point number, it can be decomposed into\n * and integer part (largest integer smaller than given number) and decimals\n * (leftover part always smaller than 1).\n * Return the decimal part of the number.\n * >>> truncate_number 3.5\n * 0.5\n*)\nlet truncate_number (number : float) : float =\n  let rec truncate_number_rec (number : float) : float =\n    match number with\n    | 0.0 -> 0.0\n    | 1.0 -> 1.0\n    | _ ->\n        let (remainder, remainder_decimals) =\n          let rec remainder_decimals_rec (remainder : float) (decimals : int) =\n            match remainder with\n            | 0.0 -> (remainder, decimals)\n            | _ ->\n                let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1)\n                in (remainder, remainder_decimals)\n          in\n          remainder_decimals_rec number 0\n        in\n        let (remainder, decimals) = remainder_decimals in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1) in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1) in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1) in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1) in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1) in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals + 1) in\n        let (remainder, remainder_decimals) = remainder_decimals_rec remainder (decimals +"], ["(**You're given a list of deposit and withdrawal operations on a bank account that starts with\n * zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n * at that point function should return true. Otherwise it should return false.\n * >>> below_zero [1; 2; 3]\n * false\n * >>> below_zero [1; 2; (~4); 5]\n * true\n*)\nlet below_zero (operations : int list) : bool =\n  let rec loop acc = function\n    | [] -> acc\n    | (x, y) :: xs ->\n        if x < 0 then loop (x + y) xs else loop acc xs\n  in\n  loop [] operations"], ["(**For a given list of input numbers, calculate Mean Absolute Deviation\n * around the mean of this dataset.\n * Mean Absolute Deviation is the average absolute difference between each\n * element and a centerpoint (mean in this case):\n * MAD = average | x - x_mean |\n * >>> mean_absolute_deviation [1.0; 2.0; 3.0; 4.0]\n * 1.0\n*)\nlet mean_absolute_deviation (numbers : float list) : float =\n  let mean = List.fold_left (fun acc x -> acc +. x) 0 numbers in\n  let mean_abs = abs (mean -. (List.sum numbers)) in\n  mean_abs /. (List.length numbers)"], ["(**Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n * >>> intersperse [] 4\n * []\n * >>> intersperse [1; 2; 3] 4\n * [1; 4; 2; 4; 3]\n*)\nlet intersperse (numbers : int list) (delimeter : int) : int list =\n  let rec intersperse_helper (numbers : int list) (delimeter : int) : int list = function\n    | [] -> []\n    | h :: t ->\n        let h_delimeter = delimeter - h in\n        let h_delimeter_t = delimeter - h in\n        let h_t_delimeter = delimeter - h_delimeter in\n        let h_t_delimeter_t = delimeter - h_delimeter_t in\n        let h_t_delimeter_h = delimeter - h_delimeter_t in\n        let h_t_delimeter_h_t = delimeter - h_delimeter_h in\n        let h_t_delimeter_h_t_delimeter = delimeter - h_delimeter_h_t in\n        let h_t_delimeter_h_t_delimeter_t = delimeter - h_delimeter_h_t_delimeter in\n        let h_t_delimeter_h_t_delimeter_h = delimeter - h_delimeter_h_t_delimeter_t in\n        let h_t_delimeter_h_t_delimeter_h_t = delimeter - h_delimeter_h_t_delimeter_h in\n        let h_t_delimeter_h_t_delimeter_h_t_delimeter = delimeter - h_delimeter_h_t_delimeter_h_t_delimeter in\n        let h_t_delimeter_h_t_delimeter_h_t_delimeter_h = delimeter - h_delimeter_h_t_delimeter_h_t_delimeter_h in\n        let h_t_delimeter_h_t_delimeter_h_t_delimeter_h_t = delimeter - h_"], ["(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n * For each of the group, output the deepest level of nesting of parentheses.\n * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n * >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n * [2; 3; 1; 3]\n*)\nlet parse_nested_parens (paren_string : string) : int list =\n  let rec parse_parens_levels (paren_string : string) : int list = function\n    | [] -> []\n    | (paren_string_1, paren_string_2) :: rest ->\n      let (paren_string_3, paren_string_4) = parse_parens_levels paren_string_2 in\n      let (paren_string_5, paren_string_6) = parse_parens_levels paren_string_4 in\n      let (paren_string_7, paren_string_8) = parse_parens_levels paren_string_6 in\n      let (paren_string_9, paren_string_10) = parse_parens_levels paren_string_8 in\n      let (paren_string_11, paren_string_12) = parse_parens_levels paren_string_10 in\n      let (paren_string_13, paren_string_14) = parse_parens_levels paren_string_12 in\n      let (paren_string_15, paren_string_16) = parse_parens_levels paren_string_14 in\n      let (paren_string_17, paren_string_18) = parse_parens_levels paren_string_16 in\n      let (paren_string_19, paren_string_20) = parse_parens_levels paren_string_18 in\n      let (paren_string_21, paren_string_22) = parse_parens_levels paren_string"], ["(**Filter an input list of strings only for ones that contain given substring\n * >>> filter_by_substring [] \"a\"\n * []\n * >>> filter_by_substring [\"abc\"; \"bacd\"; \"cde\"; \"array\"] \"a\"\n * [\"abc\"; \"bacd\"; \"array\"]\n*)\nlet filter_by_substring (strings : string list) (substring : string) : string list =\n  let rec filter_by_substring_rec (strings : string list) (substring : string) : string list =\n    match strings with\n    | [] -> []\n    | [s] -> [s]\n    | (s :: rest) when substring = s -> filter_by_substring_rec rest (substring :: substring)\n    | (s :: rest) when substring = s -> filter_by_substring_rec rest (substring :: substring)\n    | (s :: rest) when substring = s -> filter_by_substring_rec rest (substring :: substring)\n    | _ -> []\n  in\n  filter_by_substring_rec strings substring\n;;"], ["(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n * >>> sum_product []\n * (0, 1)\n * >>> sum_product [1; 2; 3; 4]\n * (10, 24)\n*)\nlet sum_product (numbers : int list) :  int * int =\n  let rec sum_product_helper (numbers : int list) : (int * int) = function\n    | [] -> (0, 1)\n    | x :: xs ->\n        let sum = sum_product_helper xs\n        let product = x * sum.(0)\n        (sum.(1), product)\n  in sum_product_helper numbers\n;;"], ["(**From a given list of integers, generate a list of rolling maximum element found until given moment\n * in the sequence.\n * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]\n * [1; 2; 3; 3; 3; 4; 4]\n*)\nlet rolling_max (numbers : int list) : int list =\n  let rec loop (numbers : int list) (max : int) : int list =\n    match numbers with\n    | [] -> []\n    | head :: tail ->\n        if head > max then\n          loop tail max\n        else\n          head :: (loop tail max)\n  in\n  loop numbers 0\n;;"], ["(**Find the shortest palindrome that begins with a supplied string.\n * Algorithm idea is simple:\n * - Find the longest postfix of supplied string that is a palindrome.\n * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n * >>> make_palindrome \"\"\n * \"\"\n * >>> make_palindrome \"cat\"\n * \"catac\"\n * >>> make_palindrome \"cata\"\n * \"catac\"\n*)\nlet make_palindrome (string : string) : string =\n  let rec loop (string : string) (palindrome : string) : string =\n    match string with\n    | [] -> palindrome\n    | head :: tail ->\n        let prefix = head :: palindrome\n        let suffix = tail :: palindrome\n        let postfix = prefix :: suffix\n        loop tail postfix\n  in loop string palindrome\n;;"], ["(**Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return result also as a string.\n * >>> string_xor \"010\" \"110\"\n * \"100\"\n*)\nlet string_xor (a : string) (b : string) : string =\n  let rec string_xor_rec (a : string) (b : string) : string =\n    match a, b with\n    | \"\", \"\" -> \"\"\n    | \"\", _ -> \"0\"\n    | _, \"\" -> \"1\"\n    | a, b ->\n      let a_b = a ^ b in\n      let a_b_len = String.length a_b in\n      let b_len = String.length b in\n      let a_b_len_minus_b_len = a_b_len - b_len in\n      let a_b_len_minus_1 = a_b_len_minus_b_len + 1 in\n      let a_b_len_minus_1_minus_1 = a_b_len_minus_1 - 1 in\n      let a_b_len_minus_1_minus_1_minus_1 = a_b_len_minus_1_minus_1 - 1 in\n      let a_b_len_minus_1_minus_1_minus_1_minus_1 = a_b_len_minus_1_minus_1_minus_1 - 1 in\n      let a_b_len_minus_1_minus_1_minus_1_minus_1_minus_1 = a_b_len_minus_1_minus_1_minus_1_minus_1 - 1 in\n      let a_b_len_minus_1_minus_1_minus_1_minus_1_minus_1_minus_1 = a_b_len_minus_1_minus_1_minus_1_minus_1_minus_1 - 1 in\n      let a_b_len_minus_1_minus_1_minus_1_minus_1_minus_1_minus_1_minus_1 = a_b_len_minus_1"], ["(**Out of list of strings, return the longest one. Return the first one in case of multiple\n * strings of the same length. Return None in case the input list is empty.\n * >>> longest []\n * Some(None)\n * >>> longest [\"a\"; \"b\"; \"c\"]\n * Some(\"a\")\n * >>> longest [\"a\"; \"bb\"; \"ccc\"]\n * Some(\"ccc\")\n*)\nlet longest (strings : string list) : string option =\n  let longest_length = List.fold_left (fun acc str -> String.length str + acc) 0 strings in\n  if longest_length = 0 then None else Some (String.sub strings 0 (List.hd strings).Length)"], ["(**Return a greatest common divisor of two integers a and b\n * >>> greatest_common_divisor 3 5\n * 1\n * >>> greatest_common_divisor 25 15\n * 5\n*)\nlet greatest_common_divisor (a : int) (b : int) : int =\n  let rec gcd_rec a b =\n    if b = 0 then a\n    else gcd_rec a (b mod a)\n  in\n  gcd_rec a b\n;;"], ["(**Return list of all prefixes from shortest to longest of the input string\n * >>> all_prefixes \"abc\"\n * [\"a\"; \"ab\"; \"abc\"]\n*)\nlet all_prefixes (string : string) : string list =\n  let rec aux acc = function\n    | [] -> acc\n    | (c :: cs) :: rest -> aux (c :: acc) rest\n  in aux [] string\n;;"], ["(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * >>> string_sequence 0\n * \"0\"\n * >>> string_sequence 5\n * \"0 1 2 3 4 5\"\n*)\nlet string_sequence (n : int) : string =\n  let rec string_sequence_helper n = function\n    | [] -> \"\"\n    | (x :: xs) -> x ^ string_sequence_helper (n - 1) xs\n  in string_sequence_helper n []\n"], ["(**Given a string, find out how many distinct characters (regardless of case) does it consist of\n * >>> count_distinct_characters \"xyzXYZ\"\n * 3\n * >>> count_distinct_characters \"Jerry\"\n * 4\n*)\nlet count_distinct_characters (string : string) : int =\n  let rec count_distinct_characters_helper (string : string) : int = function\n    | [] -> 0\n    | (c : char) :: rest ->\n        if c = string.[0] then count_distinct_characters_helper rest 1 else count_distinct_characters_helper rest 2\n  in count_distinct_characters_helper string 1\n;;"], ["(**Input to this function is a string representing musical notes in a special ASCII format.\n * Your task is to parse this string and return list of integers corresponding to how many beats does each\n * not last.\n * Here is a legend:\n * 'o' - whole note, lasts four beats\n * 'o|' - half note, lasts two beats\n * '.|' - quater note, lasts one beat\n * >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]\n*)\nlet parse_music (music_string : string) : int list =\n  let rec parse_note (note : string) : int =\n    match note with\n    | \"o\" -> 4\n    | \"o|\" -> 2\n    | \".|\" -> 1\n    | \".\" -> 1\n    | _ -> 0\n  in\n  let rec parse_beat (note : string) : int =\n    match note with\n    | \"o\" -> 4\n    | \"o|\" -> 2\n    | \".|\" -> 1\n    | \".\" -> 1\n    | _ -> 0\n  in\n  let rec parse_beats (beats : int list) : int list =\n    match beats with\n    | [] -> []\n    | _ :: rest ->\n        let beat = parse_beat (List.hd rest) in\n        let beat_rest = List.tl rest in\n        let beat_rest = parse_beats (beat_rest) in\n        let beat_rest = List.tl beat_rest in\n        let beat_rest = parse_beats (beat_rest) in\n        let beat_rest = List.tl beat_rest in\n        let beat_rest = parse_beats (beat_rest) in\n        let beat_rest = List.tl beat_rest in\n        let beat_rest = parse_beats (beat_rest) in\n        let beat_rest = List.tl beat_rest in\n        let beat_rest = parse_be"], ["(**Find how many times a given substring can be found in the original string. Count overlaping cases.\n * >>> how_many_times \"\" \"a\"\n * 0\n * >>> how_many_times \"aaa\" \"a\"\n * 3\n * >>> how_many_times \"aaaa\" \"aa\"\n * 3\n*)\nlet how_many_times (string : string) (substring : string) : int =\n  let rec loop (string : string) (substring : string) (count : int) : int =\n    if substring = \"\" then count\n    else if substring = string then count + 1\n    else loop (substring :: string) substring (count + 1) in\n  loop string substring 0\n;;"], ["(**Input is a space-delimited string of numberals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n * Return the string with numbers sorted from smallest to largest\n * >>> sort_numbers \"three one five\"\n * \"one three five\"\n*)\nlet sort_numbers (numbers : string) : string =\n  let rec sort_numbers_aux (numbers : string) : string = function\n    | [] -> \"\"\n    | (x :: xs) ->\n        let x_str = String.make 1 x in\n        let xs_str = String.make 1 xs in\n        String.concat \"\" [x_str; xs_str]\n  in\n  sort_numbers_aux numbers\n;;"], ["(**From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n * other and return them in order (smaller number, larger number).\n * >>> find_closest_elements [1.0; 2.0; 3.0; 4.0; 5.0; 2.2]\n * (2.0, 2.2)\n * >>> find_closest_elements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0]\n * (2.0, 2.0)\n*)\nlet find_closest_elements (numbers : float list) :  float * float =\n  let rec find_closest_elements_helper (numbers : float list) (closest : float * float) : float * float =\n    match numbers with\n    | [] -> closest\n    | _ :: rest ->\n        let (min_num, min_num_dist) = find_closest_elements_helper rest closest in\n        let (max_num, max_num_dist) = find_closest_elements_helper rest (min_num, min_num_dist) in\n        if min_num_dist < max_num_dist then\n          (min_num, min_num_dist)\n        else\n          (max_num, max_num_dist)\n    | _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _"], ["(**Given list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1\n * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]\n * [0.0; 0.25; 0.5; 0.75; 1.0]\n*)\nlet rescale_to_unit (numbers : float list) : float list =\n  let rec rescale_to_unit_aux (numbers : float list) : float list = function\n    | [] -> []\n    | [x] -> [x]\n    | [x; y] -> [x; y]\n    | [x; y; z] -> [x; y; z]\n    | [x; y; z; w] -> [x; y; z; w]\n    | _ ->\n        let (min, max) = List.min_elt numbers in\n        let (min_x, max_x) = List.min_elt numbers in\n        let (min_y, max_y) = List.min_elt numbers in\n        let (min_z, max_z) = List.min_elt numbers in\n        let (min_w, max_w) = List.min_elt numbers in\n        let (min_x, max_x) = List.max_elt numbers in\n        let (min_y, max_y) = List.max_elt numbers in\n        let (min_z, max_z) = List.max_elt numbers in\n        let (min_w, max_w) = List.max_elt numbers in\n        let (min_x, max_x) = List.max_elt numbers in\n        let (min_y, max_y) = List.max_elt numbers in\n        let (min_z, max_z) = List.max_elt numbers in\n        let (min_w, max_w) = List.max_elt numbers in\n        let (min_x, max_x) = List.max_elt numbers in\n        let (min_y, max_y)"], ["(**Return length of given string\n * >>> strlen \"\"\n * 0\n * >>> strlen \"abc\"\n * 3\n*)\nlet strlen (string : string) : int =\n  let rec loop (string : string) : int =\n    match string with\n    | [] -> 0\n    | (c :: rest) ->\n        if c = '\\000' then 1\n        else if c = '\\001' then 2\n        else if c = '\\002' then 3\n        else if c = '\\003' then 4\n        else if c = '\\004' then 5\n        else if c = '\\005' then 6\n        else if c = '\\006' then 7\n        else if c = '\\007' then 8\n        else if c = '\\008' then 9\n        else if c = '\\009' then 10\n        else if c = '\\010' then 11\n        else if c = '\\011' then 12\n        else if c = '\\012' then 13\n        else if c = '\\013' then 14\n        else if c = '\\014' then 15\n        else if c = '\\015' then 16\n        else if c = '\\016' then 17\n        else if c = '\\017' then 18\n        else if c = '\\018' then 19\n        else if c = '\\019' then 20\n        else if c = '\\020' then 21\n        else if c = '\\021' then 22\n        else if c = '\\022' then 23\n        else if c = '\\023' then 24\n        else if c = '\\024' then 25\n        else if c = '\\025' then 26\n        else if c = '\\026' then 27\n        else if c = '\\027' then 28\n        else if c = '\\030' then 29\n        else if c = '\\031"], ["(**For a given number n, find the largest number that divides n evenly, smaller than n\n * >>> largest_divisor 15\n * 5\n*)\nlet largest_divisor (n : int) : int =\n  let rec loop n =\n    if n = 1 then n\n    else if n mod 2 = 0 then n\n    else loop (n / 2)\n  in loop n\n;;"], ["(**Return list of prime factors of given integer in the order from smallest to largest.\n * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n * Input number should be equal to the product of all factors\n * >>> factorize 8\n * [2; 2; 2]\n * >>> factorize 25\n * [5; 5]\n * >>> factorize 70\n * [2; 5; 7]\n*)\nlet factorize (n : int) : int list =\n  let rec factorize_helper n =\n    if n = 1 then [n]\n    else if n mod 2 = 0 then [n / 2]\n    else factorize_helper n / 2\n  in factorize_helper n\n;;"], ["(**From a list of integers, remove all elements that occur more than once.\n * Keep order of elements left the same as in the input.\n * >>> remove_duplicates [1; 2; 3; 2; 4]\n * [1; 3; 4]\n*)\nlet remove_duplicates (numbers : int list) : int list =\n  let rec remove_duplicates_aux acc = function\n    | [] -> acc\n    | x :: xs -> if List.mem x acc then remove_duplicates_aux (x :: acc) xs else remove_duplicates_aux (x :: acc) xs\n  in remove_duplicates_aux [] numbers\n;;"], ["(**For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * >>> flip_case \"Hello\"\n * \"hELLO\"\n*)\nlet flip_case (string : string) : string =\n  let rec flip_case_rec (string : string) : string =\n    match string with\n    | [] -> string\n    | [c] -> c\n    | (c1, c2) :: rest ->\n        if c1 = c2 then flip_case_rec rest else c1 :: flip_case_rec (c2 :: rest)\n  in\n  flip_case_rec string\n;;"], ["(**Concatenate list of strings into a single string\n * >>> concatenate []\n * \"\"\n * >>> concatenate [\"a\"; \"b\"; \"c\"]\n * \"abc\"\n*)\nlet concatenate (strings : string list) : string =\n  let rec concatenate_rec (strings : string list) : string = function\n    | [] -> \"\"\n    | (s1 :: s2 :: rest) -> s1 ^ concatenate_rec (s2 :: rest)\n  in concatenate_rec strings\n;;"], ["(**Filter an input list of strings only for ones that start with a given prefix.\n * >>> filter_by_prefix [] \"a\"\n * []\n * >>> filter_by_prefix [\"abc\"; \"bcd\"; \"cde\"; \"array\"] \"a\"\n * [\"abc\"; \"array\"]\n*)\nlet filter_by_prefix (strings : string list) (prefix : string) : string list =\n  List.filter (fun s -> String.starts_with s prefix) strings\n;;"], ["(**Return only positive numbers in the list.\n * >>> get_positive [(~1); 2; (~4); 5; 6]\n * [2; 5; 6]\n * >>> get_positive [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]\n * [5; 3; 2; 3; 9; 123; 1]\n*)\nlet get_positive (l : int list) : int list =\n  List.filter (fun x -> x > 0) l\n;;"], ["(**Return true if a given number is prime, and false otherwise.\n * >>> is_prime 6\n * false\n * >>> is_prime 101\n * true\n * >>> is_prime 11\n * true\n * >>> is_prime 13441\n * true\n * >>> is_prime 61\n * true\n * >>> is_prime 4\n * false\n * >>> is_prime 1\n * false\n*)\nlet is_prime (n : int) : bool =\n  if n < 2 then false\n  else if n = 2 then true\n  else if n mod 2 = 0 then false\n  else if n = 3 then true\n  else if n = 5 then true\n  else if n = 7 then true\n  else if n = 11 then true\n  else if n = 13 then true\n  else if n = 17 then true\n  else if n = 19 then true\n  else if n = 23 then true\n  else if n = 29 then true\n  else if n = 31 then true\n  else if n = 37 then true\n  else if n = 41 then true\n  else if n = 43 then true\n  else if n = 47 then true\n  else if n = 53 then true\n  else if n = 59 then true\n  else if n = 61 then true\n  else if n = 67 then true\n  else if n = 71 then true\n  else if n = 73 then true\n  else if n = 79 then true\n  else if n = 83 then true\n  else if n = 89 then true\n  else if n = 97 then true\n  else if n = 101 then true\n  else if n = 103 then true\n  else if n = 107 then true\n  else if n = 109 then true\n  else if n = 113 then true\n  else if n = 119 then true\n  else if n = 121 then true\n  else if n = 127 then true\n  else if n = 1"], ["(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n * to the values of the corresponding indicies of l, but sorted.\n * >>> sort_third [1; 2; 3]\n * [1; 2; 3]\n * >>> sort_third [5; 6; 3; 4; 8; 9; 2]\n * [2; 6; 3; 4; 8; 9; 5]\n*)\nlet sort_third (l : int list) : int list =\n  let rec sort_third_aux l =\n    match l with\n    | [] -> []\n    | h :: t ->\n        let h_i = List.nth l 0 in\n        let t_i = List.nth t 0 in\n        if h_i mod 3 = 0 then List.sort_uniq (fun h_i t_i -> h_i - t_i) t\n        else List.sort_uniq (fun h_i t_i -> h_i - t_i) (h :: t)\n  in\n  sort_third_aux l\n;;"], ["(**Return sorted unique elements in a list\n * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]\n * [0; 2; 3; 5; 9; 123]\n*)\nlet unique (l : int list) : int list =\n  let rec aux l =\n    match l with\n    | [] -> []\n    | h :: t -> if h = h then aux t else h :: aux (h :: t)\n  in aux l\n;;"], ["(**Return maximum element in the list.\n * >>> max_element [1; 2; 3]\n * 3\n * >>> max_element [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]\n * 123\n*)\nlet max_element (l : int list) : int =\n  let rec aux l = match l with\n    | [] -> raise Not_found\n    | h::t -> if h > l then aux t else aux h\n  in aux l\n"], ["(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n * >>> fizz_buzz 50\n * 0\n * >>> fizz_buzz 78\n * 2\n * >>> fizz_buzz 79\n * 3\n*)\nlet fizz_buzz (n : int) : int =\n  let rec fizz_buzz_helper n =\n    if n mod 11 = 7 || n mod 13 = 7 then 3\n    else 0\n  in\n  fizz_buzz_helper n\n;;"], ["(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n * to the values of the even indicies of l, but sorted.\n * >>> sort_even [1; 2; 3]\n * [1; 2; 3]\n * >>> sort_even [5; 6; 3; 4]\n * [3; 6; 5; 4]\n*)\nlet sort_even (l : int list) : int list =\n  let rec sort_even_aux (l : int list) : int list =\n    match l with\n    | [] -> []\n    | hd :: tl ->\n        let hd_sorted = sort_even_aux tl in\n        let tl_sorted = sort_even_aux hd_sorted in\n        hd :: tl_sorted\n  in\n  sort_even_aux l\n;;"], ["(**prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n * >>> prime_fib 1\n * 2\n * >>> prime_fib 2\n * 3\n * >>> prime_fib 3\n * 5\n * >>> prime_fib 4\n * 13\n * >>> prime_fib 5\n * 89\n*)\nlet prime_fib (n : int) : int =\n  let rec fib (n : int) : int =\n    if n < 2 then n else fib (n - 1) + fib (n - 2)\n  in fib n\n;;"], ["(**triples_sum_to_zero takes a list of integers as an input.\n * it returns true if there are three distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> triples_sum_to_zero [1; 3; 5; 0]\n * false\n * >>> triples_sum_to_zero [1; 3; (~2); 1]\n * true\n * >>> triples_sum_to_zero [1; 2; 3; 7]\n * false\n * >>> triples_sum_to_zero [2; 4; (~5); 3; 9; 7]\n * true\n * >>> triples_sum_to_zero [1]\n * false\n*)\nlet triples_sum_to_zero (l : int list) : bool =\n  let rec sum_to_zero_rec (l : int list) : bool =\n    match l with\n    | [] -> true\n    | [x] -> true\n    | (x :: xs) :: rest ->\n        if x + sum_to_zero_rec rest = 0 then true\n        else sum_to_zero_rec xs\n  in sum_to_zero_rec l\n;;"], ["(**Imagine a road that's a perfectly straight infinitely long line.\n * n cars are driving left to right;  simultaneously, a different set of n cars\n * are driving right to left.   The two sets of cars start out being very far from\n * each other.  All cars move in the same speed.  Two cars are said to collide\n * when a car that's moving left to right hits a car that's moving right to left.\n * However, the cars are infinitely sturdy and strong; as a result, they continue moving\n * in their trajectory as if they did not collide.\n * This function outputs the number of such collisions.\n*)\nlet car_race_collision (n : int) : int =\n  let rec loop n =\n    if n = 0 then 0\n    else\n      let rec loop_n n =\n        if n = 0 then 0\n        else\n          let rec loop_n_n n =\n            if n = 0 then 0\n            else\n              let rec loop_n_n_n n =\n                if n = 0 then 0\n                else\n                  let rec loop_n_n_n_n n =\n                    if n = 0 then 0\n                    else\n                      let rec loop_n_n_n_n_n n =\n                        if n = 0 then 0\n                        else\n                          let rec loop_n_n_n_n_n_n n =\n                            if n = 0 then 0\n                            else\n                              let rec loop_n_n_n_n_n_n_n n =\n                                if n = 0 then 0\n                                else\n                                  let rec loop_n_n_n_n_n_n_n_n n =\n                                    if n = 0 then 0\n                                    else\n                                      let rec loop_n_n_n_n_n_n_n_n_n n =\n                                        if n = 0 then 0\n                                        else\n                                          let rec loop_n_n_n_n_n_n_n_n_n_n n =\n                                           "], ["(**Return list with elements incremented by 1.\n * >>> incr_list [1; 2; 3]\n * [2; 3; 4]\n * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]\n * [6; 4; 6; 3; 4; 4; 10; 1; 124]\n*)\nlet incr_list (l : int list) : int list =\n  let rec incr_list_aux l =\n    match l with\n    | [] -> []\n    | h :: t ->\n        let h_new = h + 1 in\n        [h_new] :: incr_list_aux t\n  in\n  incr_list_aux l\n;;"], ["(**pairs_sum_to_zero takes a list of integers as an input.\n * it returns true if there are two distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> pairs_sum_to_zero [1; 3; 5; 0]\n * false\n * >>> pairs_sum_to_zero [1; 3; (~2); 1]\n * false\n * >>> pairs_sum_to_zero [1; 2; 3; 7]\n * false\n * >>> pairs_sum_to_zero [2; 4; (~5); 3; 5; 7]\n * true\n * >>> pairs_sum_to_zero [1]\n * false\n*)\nlet pairs_sum_to_zero (l : int list) : bool =\n  let rec pairs_sum_to_zero_aux (l : int list) : bool =\n    match l with\n    | [] -> true\n    | hd :: tl ->\n        let hd_sum = hd + 1 in\n        let tl_sum = List.fold_left (fun acc x -> x + hd_sum) 0 tl in\n        hd_sum = tl_sum && pairs_sum_to_zero_aux tl\n  in pairs_sum_to_zero_aux l\n;;"], ["(**Change numerical base of input number x to base.\n * return string representation after the conversion.\n * base numbers are less than 10.\n * >>> change_base 8 3\n * \"22\"\n * >>> change_base 8 2\n * \"1000\"\n * >>> change_base 7 2\n * \"111\"\n*)\nlet change_base (x : int) (base : int) : string =\n  let rec change_base_rec (x : int) (base : int) : string =\n    match x with\n    | 0 -> \"0\"\n    | n ->\n        let n_base = n / base in\n        let n_base_str = change_base_rec n_base base in\n        n_base_str\n  in\n  change_base_rec x base\n;;"], ["(**Given length of a side and high return area for a triangle.\n * >>> triangle_area 5 3\n * 7.5\n*)\nlet triangle_area (a : int) (h : int) : float =\n  let rec triangle_area_rec (a : int) (h : int) : float =\n    if a = 0 then 0.0\n    else if h = 0 then 0.0\n    else if h = 1 then 0.5 * a * h\n    else if h = 2 then 0.25 * a * h\n    else if h = 3 then 0.125 * a * h\n    else if h = 4 then 0.0625 * a * h\n    else if h = 5 then 0.03125 * a * h\n    else if h = 6 then 0.015625 * a * h\n    else if h = 7 then 0.0078125 * a * h\n    else if h = 8 then 0.00390625 * a * h\n    else if h = 9 then 0.001953125 * a * h\n    else if h = 10 then 0.0009765625 * a * h\n    else if h = 11 then 0.00048828125 * a * h\n    else if h = 12 then 0.000244140625 * a * h\n    else 0.0\n  in\n  triangle_area_rec a h\n;;"], ["(**The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n * >>> fib4 5\n * 4\n * >>> fib4 6\n * 8\n * >>> fib4 7\n * 14\n*)\nlet fib4 (n : int) : int =\n  let rec fib4_helper n =\n    if n = 0 then 0\n    else fib4_helper (n - 1) + fib4_helper (n - 2) + fib4_helper (n - 3) + fib4_helper (n - 4)\n  in fib4_helper 0\n;;"], ["(**Return median of elements in the list l.\n * >>> median [3; 1; 2; 4; 5]\n * 3.0\n * >>> median [(~10); 4; 6; 1000; 10; 20]\n * 15.0\n*)\nlet median (l : int list) : float =\n  let rec loop (l : int list) : float =\n    match l with\n    | [] -> 0.0\n    | hd :: tl ->\n        let hd_med = (loop tl) /. 2.0\n        if hd_med > hd then hd_med else hd\n  in\n  loop l\n;;"], ["(**Checks if given string is a palindrome\n * >>> is_palindrome \"\"\n * true\n * >>> is_palindrome \"aba\"\n * true\n * >>> is_palindrome \"aaaaa\"\n * true\n * >>> is_palindrome \"zbcd\"\n * false\n*)\nlet is_palindrome (text : string) : bool =\n  let rec is_palindrome_helper (text : string) : bool =\n    match text with\n    | \"\" -> true\n    | _ ->\n        let (left, right) = text |> String.split_on_char ' ' in\n        is_palindrome_helper left && is_palindrome_helper right\n  in\n  is_palindrome_helper text\n;;"], ["(**Return 2^n modulo p (be aware of numerics).\n * >>> modp 3 5\n * 3\n * >>> modp 1101 101\n * 2\n * >>> modp 0 101\n * 1\n * >>> modp 3 11\n * 8\n * >>> modp 100 101\n * 1\n*)\nlet modp (n : int) (p : int) : int =\n  let rec modp_rec n p =\n    if n = 0 then 0\n    else if n mod p = 0 then n mod p\n    else modp_rec (n mod p) (p mod n)\n  in modp_rec n p\n;;"], ["(**remove_vowels is a function that takes string and returns string without vowels.\n * >>> remove_vowels \"\"\n * \"\"\n * >>> remove_vowels \"abcdef\"\n * \"bcdf\"\n * >>> remove_vowels \"aaaaa\"\n * \"\"\n * >>> remove_vowels \"aaBAA\"\n * \"B\"\n * >>> remove_vowels \"zbcd\"\n * \"zbcd\"\n*)\nlet remove_vowels (text : string) : string =\n  let rec loop (text : string) : string =\n    match text with\n    | [] -> text\n    | (c :: cs) :: rest ->\n        if c = ' ' || c = '\\t' then\n          loop rest\n        else\n          if c = 'a' || c = 'A' then\n            loop (c :: cs)\n          else\n            (c :: loop cs)\n  in\n  loop text\n;;"], ["(**Return true if all numbers in the list l are below threshold t.\n * >>> below_threshold [1; 2; 4; 10] 100\n * true\n * >>> below_threshold [1; 20; 4; 10] 5\n * false\n*)\nlet below_threshold (l : int list) (t : int) : bool =\n  List.exists (fun x -> x <= t) l"], ["(**Add two numbers x and y\n * >>> add 2 3\n * 5\n * >>> add 5 7\n * 12\n*)\nlet add (x : int) (y : int) : int = x + y"], ["(**Check if two words have the same characters.\n * >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n * true\n * >>> same_chars \"abcd\" \"dddddddabc\"\n * true\n * >>> same_chars \"dddddddabc\" \"abcd\"\n * true\n * >>> same_chars \"eabcd\" \"dddddddabc\"\n * false\n * >>> same_chars \"abcd\" \"dddddddabce\"\n * false\n * >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n * false\n*)\nlet same_chars (s0 : string) (s1 : string) : bool =\n  let rec aux (s0 : string) (s1 : string) : bool =\n    match s0, s1 with\n    | \"\", \"\" -> true\n    | _ ->\n        let s0 = String.concat \"\" s0 in\n        let s1 = String.concat \"\" s1 in\n        String.length s0 = String.length s1 &&\n          String.iter (fun c -> if c <> s1.(i) then false) s0 &&\n          String.iter (fun c -> if c <> s1.(i) then false) s1\n  in aux s0 s1\n;;"], ["(**Return n-th Fibonacci number.\n * >>> fib 10\n * 55\n * >>> fib 1\n * 1\n * >>> fib 8\n * 21\n*)\nlet fib (n : int) : int =\n  let rec fib_helper n =\n    if n = 0 then 0\n    else if n = 1 then 1\n    else fib_helper (n - 1) + fib_helper (n - 2)\n  in fib_helper n\n;;"], ["(**brackets is a string of \"<\" and \">\".\n * return true if every opening bracket has a corresponding closing bracket.\n * >>> correct_bracketing \"<\"\n * false\n * >>> correct_bracketing \"<>\"\n * true\n * >>> correct_bracketing \"<<><>>\"\n * true\n * >>> correct_bracketing \"><<>\"\n * false\n*)\nlet correct_bracketing (brackets : string) : bool =\n  let rec loop (brackets : string) : bool =\n    match brackets with\n    | \"<\" -> loop (brackets [\">\"])\n    | \">\" -> loop (brackets [\">\"])\n    | _ -> false\n  in loop brackets\n;;"], ["(**Return true is list elements are monotonically increasing or decreasing.\n * >>> monotonic [1; 2; 4; 20]\n * true\n * >>> monotonic [1; 20; 4; 10]\n * false\n * >>> monotonic [4; 1; 0; (~10)]\n * true\n*)\nlet monotonic (l : int list) : bool =\n  let rec loop acc = function\n    | [] -> acc\n    | x :: xs ->\n        if x > acc then loop (x :: acc) xs\n        else loop acc xs\n  in\n  loop [] l\n"], ["(**Return sorted unique common elements for two lists.\n * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]\n * [1; 5; 653]\n * >>> common [5; 3; 2; 8] [3; 2]\n * [2; 3]\n*)\nlet common (l1 : int list) (l2 : int list) : int list =\n  let rec common_helper l1 l2 =\n    match l1, l2 with\n    | [], [] -> []\n    | [x], [] -> [x]\n    | [x; y], [] -> [x; y]\n    | [x; y; z], [] -> [x; y; z]\n    | [x; y; z; w], [] -> [x; y; z; w]\n    | [x; y; z; w; v], [] -> [x; y; z; w; v]\n    | [x; y; z; w; v; u], [] -> [x; y; z; w; v; u]\n    | [x; y; z; w; v; u; v2], [] -> [x; y; z; w; v; u; v2]\n    | [x; y; z; w; v; u; v2; v3], [] -> [x; y; z; w; v; u; v2; v3]\n    | [x; y; z; w; v; u; v2; v3; v4], [] -> [x; y; z; w; v; u; v2; v3; v4]\n    | [x; y; z; w; v; u; v2; v3; v4; v5], [] -> [x; y; z; w; v; u; v2; v3; v4; v5]\n    | [x; y; z; w; v; u; v2; v3; v4; v5; v6], [] -> [x; y; z; w; v;"], ["(**Return the largest prime factor of n. Assume n > 1 and is not a prime.\n * >>> largest_prime_factor 13195\n * 29\n * >>> largest_prime_factor 2048\n * 2\n*)\nlet largest_prime_factor (n : int) : int =\n  let rec loop n =\n    if n = 1 then 1\n    else if n mod 2 = 0 then n / 2\n    else loop (n / 2)\n  in loop n\n;;"], ["(**sum_to_n is a function that sums numbers from 1 to n.\n * >>> sum_to_n 30\n * 465\n * >>> sum_to_n 100\n * 5050\n * >>> sum_to_n 5\n * 15\n * >>> sum_to_n 10\n * 55\n * >>> sum_to_n 1\n * 1\n*)\nlet sum_to_n (n : int) : int =\n  let rec sum_to_n_helper n = function\n    | [] -> n\n    | x :: xs -> sum_to_n_helper (n + x) xs\n  in sum_to_n_helper 0 []\n;;"], ["(**brackets is a string of \"(\" and \")\".\n * return true if every opening bracket has a corresponding closing bracket.\n * >>> correct_bracketing \"(\"\n * false\n * >>> correct_bracketing \"()\"\n * true\n * >>> correct_bracketing \"(()())\"\n * true\n * >>> correct_bracketing \")(()\"\n * false\n*)\nlet correct_bracketing (brackets : string) : bool =\n  let rec loop (bracket : string) (opening : string) (closing : string) : bool =\n    match brackets with\n    | [] -> true\n    | _ :: _ ->\n        let (bracket, opening, closing) = brackets |> String.split_on_char '(' |> String.split_on_char ')' in\n        if opening = opening && closing = closing then loop opening opening closing else false\n    | _ :: _ -> false\n  in loop \"\" \"\" \"\"\n;;"], ["(**xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * Return derivative of this polynomial in the same form.\n * >>> derivative [3; 1; 2; 4; 5]\n * [1; 4; 12; 20]\n * >>> derivative [1; 2; 3]\n * [2; 6]\n*)\nlet derivative (xs : int list) : int list =\n  let rec derivative_rec (xs : int list) : int list =\n    match xs with\n    | [] -> []\n    | x :: xs' ->\n        let f = (fun x -> x) in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ [x] in\n        let xs' = xs' @ ["], ["(**The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n * >>> fibfib 1\n * 0\n * >>> fibfib 5\n * 4\n * >>> fibfib 8\n * 24\n*)\nlet fibfib (n : int) : int =\n  let rec fibfib_helper n =\n    if n = 0 then 0\n    else fibfib_helper (n - 1) + fibfib_helper (n - 2) + fibfib_helper (n - 3)\n  in fibfib_helper n\nin fibfib 0"], ["(**Write a function vowels_count which takes a string representing\n * a word as input and returns the number of vowels in the string.\n * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n * vowel, but only when it is at the end of the given word.\n * Example:\n * >>> vowels_count \"abcde\"\n * 2\n * >>> vowels_count \"ACEDY\"\n * 3\n*)\nlet vowels_count (s : string) : int =\n  let rec loop (s : string) : int =\n    match s with\n    | [] -> 0\n    | h :: t ->\n        if h = 'a' || h = 'e' || h = 'i' || h = 'o' || h = 'u' then\n          loop t\n        else\n          loop t\n  in\n  loop s\n;;"], ["(**Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n * If shift > number of digits, return digits reversed.\n * >>> circular_shift 12 1\n * \"21\"\n * >>> circular_shift 12 2\n * \"12\"\n*)\nlet circular_shift (x : int) (shift : int) : string =\n  let rec helper (x : int) (shift : int) : string =\n    match x with\n    | 0 -> \"\"\n    | n ->\n        let digits = String.sub x 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits = String.sub digits 0 shift in\n        let digits"], ["(**Task\n * Write a function that takes a string as input and returns the sum of the upper characters only'\n * ASCII codes.\n * Examples:\n * >>> digitSum \"\"\n * 0\n * >>> digitSum \"abAB\"\n * 131\n * >>> digitSum \"abcCd\"\n * 67\n * >>> digitSum \"helloE\"\n * 69\n * >>> digitSum \"woArBld\"\n * 131\n * >>> digitSum \"aAaaaXa\"\n * 153\n*)\nlet digitSum (s : string) : int =\n  let rec loop (s : string) : int =\n    match s with\n    | [] -> 0\n    | h :: t ->\n        let c = char_of_int (ord h)\n        let c' = char_of_int (ord h)\n        if c = c' then loop t else loop (h :: t)\n  loop s\nin\ndigitSum"], ["(**In this task, you will be given a string that represents a number of apples and oranges \n * that are distributed in a basket of fruit this basket contains \n * apples, oranges, and mango fruits. Given the string that represents the total number of \n * the oranges and apples and an integer that represent the total number of the fruits \n * in the basket return the number of the mango fruits in the basket.\n * for examble:\n * >>> fruit_distribution \"5 apples and 6 oranges\" 19\n * 8\n * >>> fruit_distribution \"0 apples and 1 oranges\" 3\n * 2\n * >>> fruit_distribution \"2 apples and 3 oranges\" 100\n * 95\n * >>> fruit_distribution \"100 apples and 1 oranges\" 120\n * 19\n*)\nlet fruit_distribution (s : string) (n : int) : int =\n  let rec aux n =\n    match s with\n    | \"0\" -> 0\n    | \"1\" -> 1\n    | \"2\" -> 2\n    | \"3\" -> 3\n    | \"4\" -> 4\n    | \"5\" -> 5\n    | \"6\" -> 6\n    | \"7\" -> 7\n    | \"8\" -> 8\n    | \"9\" -> 9\n    | \"10\" -> 10\n    | \"11\" -> 11\n    | \"12\" -> 12\n    | \"13\" -> 13\n    | \"14\" -> 14\n    | \"15\" -> 15\n    | \"16\" -> 16\n    | \"17\" -> 17\n    | \"18\" -> 18\n    | \"19\" -> 19\n    | \"20\" -> 20\n    | \"21\" -> 21\n    | \"22\" -> 22\n    | \"23\" -> 23\n    | \"24\" -> 24\n    | \"25\" -> 25\n    | \"26\" -> 26"], ["(**\"Given a list representing a branch of a tree that has non-negative integer nodes\n * your task is to pluck one of the nodes and return it.\n * The plucked node should be the node with the smallest even value.\n * If multiple nodes with the same smallest even value are found return the node that has smallest index.\n * The plucked node should be returned in a list, [ smalest_value, its index ],\n * If there are no even values or the given list is empty, return [].\n * Example 1:\n * >>> pluck [4; 2; 3]\n * [2; 1]\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 2:\n * >>> pluck [1; 2; 3]\n * [2; 1]\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 3:\n * >>> pluck []\n * []\n * Example 4:\n * >>> pluck [5; 0; 3; 0; 4; 2]\n * [0; 1]\n * Explanation: 0 is the smallest value, but  there are two zeros,\n * so we will choose the first zero, which has the smallest index.\n * Constraints:\n * * 1 <= nodes.length <= 10000\n * * 0 <= node.value\n*)\nlet pluck (arr : int list) : int list =\n    let rec pluck_helper (arr : int list) (i : int) : int list =\n        match arr with\n        | [] -> []\n        | hd :: tl ->\n            if hd < i then pluck_helper tl (i + 1)\n            else if hd == i then [ hd ]\n            else pluck_helper tl (i + 1)\n    in pluck_helper arr 0\n"], ["(**You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n * zero, and has a frequency greater than or equal to the value of the integer itself. \n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exist, return -1.\n * Examples:\n * >>> search [4; 1; 2; 2; 3; 1]\n * 2\n * >>> search [1; 2; 2; 3; 3; 3; 4; 4; 4]\n * 3\n * >>> search [5; 5; 4; 4; 4]\n * (~1)\n*)\nlet search (lst : int list) : int =\n  let rec aux lst = function\n    | [] -> -1\n    | hd :: tl -> if hd > lst then aux tl else aux (hd :: lst)\n  in aux lst\n"], ["(**Given list of integers, return list in strange order.\n * Strange sorting, is when you start with the minimum value,\n * then maximum of the remaining integers, then minimum and so on.\n * Examples:\n * >>> strange_sort_list [1; 2; 3; 4]\n * [1; 4; 2; 3]\n * >>> strange_sort_list [5; 5; 5; 5]\n * [5; 5; 5; 5]\n * >>> strange_sort_list []\n * []\n*)\nlet strange_sort_list (lst : int list) : int list =\n  let rec sort_list lst =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let min_val = hd\n        let max_val = hd\n        let min_val_index = List.find (fun x -> x < min_val) tl\n        let max_val_index = List.find (fun x -> x > max_val) tl\n        let min_val_index_minus_max_val_index = List.find (fun x -> x < max_val) tl\n        let max_val_index_minus_min_val_index = List.find (fun x -> x > min_val) tl\n        let min_val_index_minus_max_val_index_minus_min_val_index = List.find (fun x -> x < max_val) tl\n        let max_val_index_minus_min_val_index_minus_min_val_index_minus_max_val_index = List.find (fun x -> x > min_val) tl\n        let min_val_index_minus_max_val_index_minus_min_val_index_minus_max_val_index_minus_min_val_index = List.find (fun x -> x < max_val) tl\n        let min_val_index_minus_max_val_index_minus_min_val_index_minus_max_val_index_minus_min_val_index_minus_max_val_index = List.find (fun x -> x > min_val"], ["(**Given the lengths of the three sides of a triangle. Return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n * Otherwise return -1\n * Three sides make a valid triangle when the sum of any two sides is greater \n * than the third side.\n * Example:\n * >>> triangle_area 3 4 5\n * 6.0\n * >>> triangle_area 1 2 10\n * (~1).0\n*)\nlet triangle_area (a : int) (b : int) (c : int) : float =\n  let rec triangle_area_rec (a : int) (b : int) (c : int) : float =\n    if a > b && a > c then\n      let rec triangle_area_rec_aux (a : int) (b : int) (c : int) : float =\n        if a > b && a > c then\n          let rec triangle_area_rec_aux_aux (a : int) (b : int) (c : int) : float =\n            if a > b && a > c then\n              let rec triangle_area_rec_aux_aux_aux (a : int) (b : int) (c : int) : float =\n                if a > b && a > c then\n                  let rec triangle_area_rec_aux_aux_aux_aux (a : int) (b : int) (c : int) : float =\n                    if a > b && a > c then\n                      let rec triangle_area_rec_aux_aux_aux_aux_aux (a : int) (b : int) (c : int) : float =\n                        if a > b && a > c then\n                          let rec triangle_area_rec_aux_aux_aux_aux_aux_aux (a : int) (b : int) (c : int) : float =\n                            if a > b && a > c then\n                              let rec triangle_area_rec_aux_aux_aux_aux_aux_aux_aux (a : int) (b : int) (c : int) : float =\n                                if a > b && a > c then\n                                  let rec triangle_"], ["(**Write a function that returns true if the object q will fly, and false otherwise.\n * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n * Example:\n * >>> will_it_fly [1; 2] 5\n * false\n * # 1+2 is less than the maximum possible weight, but it's unbalanced.\n * >>> will_it_fly [3; 2; 3] 1\n * false\n * # it's balanced, but 3+2+3 is more than the maximum possible weight.\n * >>> will_it_fly [3; 2; 3] 9\n * true\n * # 3+2+3 is less than the maximum possible weight, and it's balanced.\n * >>> will_it_fly [3] 5\n * true\n * # 3 is less than the maximum possible weight, and it's balanced.\n*)\nlet will_it_fly (q : int list) (w : int) : bool =\n  let rec loop q w = match q with\n    | [] -> true\n    | h :: t ->\n        let sum = List.fold_left (fun acc x -> acc + x) 0 h\n        if sum <= w then loop t (sum + w)\n        else false\n  in loop q w\n;;"], ["(**Given a list arr of integers, find the minimum number of elements that\n * need to be changed to make the list palindromic. A palindromic list is a list that\n * is read the same backwards and forwards. In one change, you can change one element to any other element.\n * For example:\n * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]\n * 4\n * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]\n * 1\n * >>> smallest_change [1; 2; 3; 2; 1]\n * 0\n*)\nlet smallest_change (arr : int list) : int =\n  let rec loop (arr : int list) : int =\n    match arr with\n    | [] -> 0\n    | hd :: tl ->\n        if hd = tl then loop tl else if hd < tl then loop (hd :: tl) else loop (hd :: tl)\n  in\n  loop arr\n;;"], ["(**Write a function that accepts two lists of strings and returns the list that has \n * total number of chars in the all strings of the list less than the other list.\n * if the two lists have the same number of chars, return the first list.\n * Examples\n * >>> total_match [] []\n * []\n * >>> total_match [\"hi\"; \"admin\"] [\"hI\"; \"Hi\"]\n * [\"hI\"; \"Hi\"]\n * >>> total_match [\"hi\"; \"admin\"] [\"hi\"; \"hi\"; \"admin\"; \"project\"]\n * [\"hi\"; \"admin\"]\n * >>> total_match [\"hi\"; \"admin\"] [\"hI\"; \"hi\"; \"hi\"]\n * [\"hI\"; \"hi\"; \"hi\"]\n * >>> total_match [\"4\"] [\"1\"; \"2\"; \"3\"; \"4\"; \"5\"]\n * [\"4\"]\n*)\nlet total_match (lst1 : string list) (lst2 : string list) : string list =\n  let rec helper lst1 lst2 =\n    match lst1 with\n    | [] -> lst2\n    | h :: t ->\n        if h < lst2 then\n          helper t (h :: lst2)\n        else\n          h :: helper lst1 t\n  in\n  helper lst1 lst2\n"], ["(**Write a function that returns true if the given number is the multiplication of 3 prime numbers\n * and false otherwise.\n * Knowing that (a) is less then 100. \n * Example:\n * >>> is_multiply_prime 30\n * true\n * 30 = 2 * 3 * 5\n*)\nlet is_multiply_prime (a : int) : bool =\n  let rec is_prime_rec (n : int) : bool =\n    if n < 2 then false\n    else if n mod 2 = 0 then false\n    else if n mod 3 = 0 then false\n    else if n mod 5 = 0 then false\n    else if n mod 7 = 0 then false\n    else if n mod 11 = 0 then false\n    else if n mod 13 = 0 then false\n    else if n mod 17 = 0 then false\n    else if n mod 21 = 0 then false\n    else if n mod 23 = 0 then false\n    else if n mod 29 = 0 then false\n    else if n mod 31 = 0 then false\n    else if n mod 37 = 0 then false\n    else if n mod 41 = 0 then false\n    else if n mod 43 = 0 then false\n    else if n mod 47 = 0 then false\n    else if n mod 53 = 0 then false\n    else if n mod 59 = 0 then false\n    else if n mod 61 = 0 then false\n    else if n mod 67 = 0 then false\n    else if n mod 71 = 0 then false\n    else if n mod 73 = 0 then false\n    else if n mod 79 = 0 then false\n    else if n mod 83 = 0 then false\n    else if n mod 89 = 0 then false\n    else if n mod 97 = 0 then false\n    else if n mod 101 = 0 then false\n    else if n mod 103 = 0 then false\n    else if n mod 107 = 0 then false\n"], ["(**Your task is to write a function that returns true if a number x is a simple\n * power of n and false in other cases.\n * x is a simple power of n if n**int=x\n * For example:\n * >>> is_simple_power 1 4\n * true\n * >>> is_simple_power 2 2\n * true\n * >>> is_simple_power 8 2\n * true\n * >>> is_simple_power 3 2\n * false\n * >>> is_simple_power 3 1\n * false\n * >>> is_simple_power 5 3\n * false\n*)\nlet is_simple_power (x : int) (n : int) : bool =\n  let rec is_simple_power_helper (x : int) (n : int) : bool =\n    match x with\n    | 0 -> true\n    | _ -> false\n  in\n  is_simple_power_helper x n\n;;"], ["(**Write a function that takes an integer a and returns true \n * if this ingeger is a cube of some integer number.\n * Note: you may assume the input is always valid.\n * Examples:\n * >>> iscube 1\n * true\n * >>> iscube 2\n * false\n * >>> iscube (~1)\n * true\n * >>> iscube 64\n * true\n * >>> iscube 0\n * true\n * >>> iscube 180\n * false\n*)\nlet iscube (a : int) : bool =\n  let rec iscube_rec (a : int) : bool =\n    match a with\n    | 0 -> true\n    | _ -> iscube_rec (a / 2)\n  in\n  iscube_rec a\n;;"], ["(**You have been tasked to write a function that receives \n * a hexadecimal number as a string and counts the number of hexadecimal \n * digits that are primes (prime number, or a prime, is a natural number \n * greater than 1 that is not a product of two smaller natural numbers).\n * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n * So you have to determine a number of the following digits: 2, 3, 5, 7, \n * B (=decimal 11), D (=decimal 13).\n * Note: you may assume the input is always correct or empty string, \n * and symbols A,B,C,D,E,F are always uppercase.\n * Examples:\n * >>> hex_key \"AB\"\n * 1\n * >>> hex_key \"1077E\"\n * 2\n * >>> hex_key \"ABED1A33\"\n * 4\n * >>> hex_key \"123456789ABCDEF0\"\n * 6\n * >>> hex_key \"2020\"\n * 2\n*)\nlet hex_key (num : string) : int =\n  let rec count_digits (num : string) : int =\n    match num with\n    | \"0\" -> 0\n    | \"1\" -> 1\n    | \"2\" -> 2\n    | \"3\" -> 3\n    | \"4\" -> 4\n    | \"5\" -> 5\n    | \"6\" -> 6\n    | \"7\" -> 7\n    | \"8\" -> 8\n    | \"9\" -> 9\n    | \"A\" -> 10\n    | \"B\" -> 11\n    | \"C\" -> 12\n    | \"D\" -> 13\n    | \"E\" -> 14\n    | \"F\" -> "], ["(**You will be given a number in decimal form and your task is to convert it to\n * binary format. The function should return a string, with each character representing a binary\n * number. Each character in the string will be '0' or '1'.\n * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n * The extra characters are there to help with the format.\n * Examples:\n * >>> decimal_to_binary 15\n * \"db1111db\"\n * >>> decimal_to_binary 32\n * \"db100000db\"\n*)\nlet decimal_to_binary (decimal : int) : string =\n  let rec binary_to_decimal (decimal : int) : int = function\n    | 0 -> decimal\n    | n -> binary_to_decimal (decimal * 2) + decimal\n  in\n  let rec binary_to_decimal_reverse (decimal : int) : int = function\n    | 0 -> decimal\n    | n -> binary_to_decimal_reverse (decimal * 2) + decimal\n  in\n  let rec binary_to_decimal_reverse_reverse (decimal : int) : int = function\n    | 0 -> decimal\n    | n -> binary_to_decimal_reverse_reverse (decimal * 2) + decimal\n  in\n  let rec binary_to_decimal_reverse_reverse_reverse (decimal : int) : int = function\n    | 0 -> decimal\n    | n -> binary_to_decimal_reverse_reverse_reverse (decimal * 2) + decimal\n  in\n  let rec binary_to_decimal_reverse_reverse_reverse_reverse (decimal : int) : int = function\n    | 0 -> decimal\n    | n -> binary_to_decimal_reverse_reverse_reverse_reverse (decimal * 2) + decimal\n  in\n  let rec binary_to_decimal_reverse_reverse_reverse_reverse_reverse (decimal : int) : int = function\n    | 0 -> decimal\n    | n -> binary_to_decimal_reverse_reverse_reverse_reverse_reverse (decimal * "], ["(**You are given a string s.\n * Your task is to check if the string is hapml or not.\n * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct\n * For example:\n * >>> is_happy \"a\"\n * false\n * >>> is_happy \"aa\"\n * false\n * >>> is_happy \"abcd\"\n * true\n * >>> is_happy \"aabb\"\n * false\n * >>> is_happy \"adb\"\n * true\n * >>> is_happy \"xyy\"\n * false\n*)\nlet is_happy (s : string) : bool =\n  let rec loop (s : string) =\n    if s = \"\" then true\n    else if s = \"a\" then false\n    else if s = \"ab\" then loop (s |> String.sub 1 2)\n    else if s = \"abc\" then loop (s |> String.sub 1 3)\n    else if s = \"abcd\" then loop (s |> String.sub 1 4)\n    else if s = \"aabb\" then loop (s |> String.sub 1 3)\n    else if s = \"abcd\" then loop (s |> String.sub 1 4)\n    else if s = \"aabb\" then loop (s |> String.sub 1 3)\n    else if s = \"abcd\" then loop (s |> String.sub 1 4)\n    else if s = \"aabb\" then loop (s |> String.sub 1 3)\n    else if s = \"abcd\" then loop (s |> String.sub 1 4)\n    else if s = \"aabb\" then loop (s |> String.sub 1 3)\n    else if s = \"abcd\" then loop (s |> String.sub 1 4)\n    else if s = \"aabb\" then loop (s |> String.sub 1 3)\n    else if s = \"abcd\" then loop (s |> String.sub 1 4)\n    else if s = \"aabb\" then loop (s |> String.sub"], ["(**It is the last week of the semester and the teacher has to give the grades\n * to students. The teacher has been making her own algorithm for grading.\n * The only problem is, she has lost the code she used for grading.\n * She has given you a list of GPAs for some students and you have to write \n * a function that can output a list of letter grades using the following table:\n * GPA       |    Letter grade\n * 4.0                A+\n * > 3.7                A \n * > 3.3                A- \n * > 3.0                B+\n * > 2.7                B \n * > 2.3                B-\n * > 2.0                C+\n * > 1.7                C\n * > 1.3                C-\n * > 1.0                D+ \n * > 0.7                D \n * > 0.0                D-\n * 0.0                E\n * Example:\n * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]\n * [\"A+\"; \"B\"; \"C-\"; \"C\"; \"A-\"]\n*)\nlet numerical_letter_grade (grades : float list) : string list =\n    let rec loop (grades : float list) : string list =\n        match grades with\n        | [] -> []\n        | [g] -> [g]\n        | (g :: gs) :: rest ->\n            let letter = match g with\n                | 4.0 -> \"A+\"\n                | _ -> \"A-\"\n            in\n            let grades = loop gs in\n            [letter; g] :: loop rest\n    in\n    loop grades"], ["(**Write a function that takes a string and returns true if the string\n * length is a prime number or false otherwise\n * Examples\n * >>> prime_length \"Hello\"\n * true\n * >>> prime_length \"abcdcba\"\n * true\n * >>> prime_length \"kittens\"\n * true\n * >>> prime_length \"orange\"\n * false\n*)\nlet prime_length (string : string) : bool =\n  let rec loop (string : string) : bool =\n    match string with\n    | [] -> true\n    | _ :: rest ->\n        if rest = string then true\n        else loop rest\n  in loop string\n;;"], ["(**Given a positive integer n, return the count of the numbers of n-digit\n * positive integers that start or end with 1.\n*)\nlet starts_one_ends (n : int) : int =\n  let rec loop n =\n    if n < 0 then 0\n    else if n = 0 then 1\n    else if n = 1 then 1\n    else loop (n - 1) + loop (n - 2)\n  in loop n"], ["(**Given a positive integer N, return the total sum of its digits in binary.\n * Example\n * >>> solve 1000\n * \"1\"\n * >>> solve 150\n * \"110\"\n * >>> solve 147\n * \"1100\"\n * Variables:\n * @N integer\n * Constraints: 0 \u2264 N \u2264 10000.\n * Output:\n * a string of binary number\n*)\nlet solve (N : int) : string =\n  let rec aux n =\n    match n with\n    | 0 -> \"0\"\n    | _ ->\n        let digits = List.map (fun x -> if x = 0 then '1' else '0') (List.init n (fun _ -> '0')) in\n        let digits = List.rev digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '1' then '1' else '0') digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '1' then '1' else '0') digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '1' then '1' else '0') digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '1' then '1' else '0') digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '1' then '1' else '0') digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '1' then '1' else '0') digits in\n        let digits = List.filter (fun x -> x <> '0') digits in\n        let digits = List.map (fun x -> if x = '"], ["(**Given a non-empty list of integers lst. add the even elements that are at odd indices..\n * Examples:\n * >>> add [4; 2; 6; 7]\n * 2\n*)\nlet add (lst : int list) : int =\n  let rec loop (lst : int list) : int =\n    match lst with\n    | [] -> 0\n    | hd :: tl ->\n        if hd % 2 = 0\n        then loop tl\n        else hd + loop tl\n  in loop lst\n;;"], ["(**Write a function that takes a string and returns an ordered version of it.\n * Ordered version of string, is a string where all words (separated by space)\n * are replaced by a new word where all the characters arranged in\n * ascending order based on ascii value.\n * Note: You should keep the order of words and blank spaces in the sentence.\n * For example:\n * >>> anti_shuffle \"Hi\"\n * \"Hi\"\n * >>> anti_shuffle \"hello\"\n * \"ehllo\"\n * >>> anti_shuffle \"Hello World!!!\"\n * \"Hello !!!Wdlor\"\n*)\nlet anti_shuffle (s : string) : string =\n  let rec aux (s : string) : string =\n    match s with\n    | [] -> \"\"\n    | h :: t ->\n        let h_ascii = String.get h 0 in\n        let t_ascii = String.get t 0 in\n        if h_ascii < t_ascii then\n          aux t\n        else\n          aux h\n  in aux s\n;;"], ["(**You are given a 2 dimensional data, as a nested lists,\n * which is similar to matrix, however, unlike matrices,\n * each row may contain a different number of columns.\n * Given lst, and integer x, find integers x in the list,\n * and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n * each tuple is a coordinate - (row, columns), starting with 0.\n * Sort coordinates initially by rows in ascending order.\n * Also, sort coordinates of the row by columns in descending order.\n * Examples:\n * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1\n * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]\n * >>> get_row [] 1\n * []\n * >>> get_row [[]; [1]; [1; 2; 3]] 3\n * [(2, 2)]\n*)\nlet get_row (lst : int list list) (x : int) :  int * int list =\n  let rec aux lst x =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let (x1, y1) = hd in\n        let (x2, y2) = aux tl x in\n        let (x3, y3) = aux tl x2 in\n        let (x4, y4) = aux tl x3 in\n        let (x5, y5) = aux tl x4 in\n        let (x6, y6) = aux tl x5 in\n        let (x7, y7) = aux tl x6 in\n        let (x8, y8) = aux tl x7 in\n        let (x9, y9) = aux tl x8 in\n        let (x10, y10) = aux tl x9 in\n        let (x11, y11) = aux tl x10"], ["(**Given a list of non-negative integers, return a coml of the given list after sorting,\n * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n * Note:\n * * don't change the given list.\n * Examples:\n * >>> sort_array []\n * []\n * >>> sort_array [5]\n * [5]\n * >>> sort_array [2; 4; 3; 0; 1; 5]\n * [0; 1; 2; 3; 4; 5]\n * >>> sort_array [2; 4; 3; 0; 1; 5; 6]\n * [6; 5; 4; 3; 2; 1; 0]\n*)\nlet sort_array (array : int list) : int list =\n  let rec sort_helper (array : int list) (i : int) (j : int) : int list =\n    if j = 0 then array else\n      if i = j then array else\n        let temp = array.(j) in\n        array.(j) <- array.(i);\n        sort_helper (array.(i + 1)) j (j - 1);\n        array.(j) :: temp\n  in\n  sort_helper [] 0 (Array.length array - 1)\n;;"], ["(**Create a function encrypt that takes a string as an argument and\n * returns a string encrypted with the alphabet being rotated. \n * The alphabet should be rotated in a manner such that the letters \n * shift down by two multiplied to two places.\n * For example:\n * >>> encrypt \"hi\"\n * \"lm\"\n * >>> encrypt \"asdfghjkl\"\n * \"ewhjklnop\"\n * >>> encrypt \"gf\"\n * \"kj\"\n * >>> encrypt \"et\"\n * \"ix\"\n*)\nlet encrypt (s : string) : string =\n  let rot = 2 * (s.Length mod 2) in\n  let rot_str = String.create rot in\n  let rec loop (i : int) (j : int) =\n    if j >= s.Length then ()\n    else if i >= s.Length then ()\n    else if s.[i] = ' ' then loop (i + 1) j\n    else if s.[j] = ' ' then loop (i + 1) (j - 1)\n    else rot_str.[i] <- s.[j];\n    loop (i + 1) j\n  in\n  loop 0 0\n;;"], ["(**You are given a list of integers.\n * Write a function next_smallest() that returns the 2nd smallest element of the list.\n * Return None if there is no such element.\n * >>> next_smallest [1; 2; 3; 4; 5]\n * Some(2)\n * >>> next_smallest [5; 1; 4; 3; 2]\n * Some(2)\n * >>> next_smallest []\n * Some(None)\n * >>> next_smallest [1; 1]\n * Some(None)\n*)\nlet next_smallest (lst : int list) : int option =\n    match lst with\n    | [] -> None\n    | hd :: tl -> if hd < next_smallest tl then Some hd else next_smallest tl\n"], ["(**You'll be given a string of words, and your task is to count the number\n * of boredoms. A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n * For example:\n * >>> is_bored \"Hello world\"\n * 0\n * >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n * 1\n*)\nlet is_bored (S : string) : int =\n  let rec count_boredness (s : string) : int =\n    match s with\n    | \"I\" -> 1\n    | \".\" -> 1\n    | \"?\" -> 1\n    | \"!\" -> 1\n    | _ -> 0\n  in\n  count_boredness S\n;;"], ["(**Create a function that takes 3 numbers.\n * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n * Returns false in any other cases.\n * Examples\n * >>> any_int 5 2 7\n * true\n * >>> any_int 3 2 2\n * false\n * >>> any_int 3 (~2) 1\n * true\n * >>> any_int 3.6 -2.2 2\n * false\n*)\nlet any_int (x : float) (y : float) (z : float) : bool =\n  let rec loop (x : float) (y : float) (z : float) : bool =\n    match (x, y, z) with\n    | (x, y, z) ->\n        if x = y then loop x y z\n        else if x = z then loop x y z\n        else false\n    | _ -> true\n  in loop x y z"], ["(**Write a function that takes a message, and encodes in such a \n * way that it swaps case of all letters, replaces all vowels in \n * the message with the letter that appears 2 places ahead of that \n * vowel in the english alphabet. \n * Assume only letters. \n * Examples:\n * >>> encode \"test\"\n * \"TGST\"\n * >>> encode \"This is a message\"\n * \"tHKS KS C MGSSCGG\"\n*)\nlet encode (message : string) : string =\n    let swap_case_letters (c : char) =\n        match c with\n        | 'A' -> 'a'\n        | 'a' -> 'A'\n        | 'E' -> 'e'\n        | 'e' -> 'E'\n        | 'I' -> 'i'\n        | 'i' -> 'I'\n        | 'O' -> 'o'\n        | 'o' -> 'O'\n        | 'U' -> 'u'\n        | 'u' -> 'U'\n        | _ -> c\n    let swap_vowels (c : char) =\n        match c with\n        | 'a' -> 'A'\n        | 'a' -> 'A'\n        | 'e' -> 'E'\n        | 'e' -> 'E'\n        | 'i' -> 'I'\n        | 'i' -> 'I'\n        | 'o' -> 'O'\n        | 'o' -> 'O'\n        | 'u' -> 'U'\n        | 'u' -> 'U'\n        | _ -> c\n    let swap_letters (c : char) =\n        match c with\n        | 'a' -> 'A'\n        | 'a' -> 'A'\n        | 'e' -> 'E'\n        | 'e' -> 'E'\n        | 'i' -> 'I'\n        | 'i' -> 'I'\n        | 'o' -> 'O'\n        | 'o' -> 'O'\n        | 'u' -> 'U'\n        | 'u' -> 'U'\n        | _ -> c\n    let swap_vowels_"], ["(**You are given a list of integers.\n * You need to find the largest prime value and return the sum of its digits.\n * Examples:\n * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]\n * 10\n * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]\n * 25\n * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]\n * 13\n * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]\n * 11\n * >>> skjkasdkd [0; 81; 12; 3; 1; 21]\n * 3\n * >>> skjkasdkd [0; 8; 1; 2; 1; 7]\n * 7\n*)\nlet skjkasdkd (lst : int list) : int =\n  let rec aux lst =\n    match lst with\n    | [] -> 0\n    | hd :: tl ->\n        let sum = aux tl\n        if hd mod 2 = 0 then sum + hd else sum\n  in aux lst"], ["(**Given an association list, return true if all keys are strings in lower \n * case or all keys are strings in upper case, else return false.\n * The function should return false is the given association list is empty.\n * Examples:\n * >>> check_dict_case [(\"a\", \"apple\"); (\"b\", \"banana\")]\n * true\n * >>> check_dict_case [(\"a\", \"apple\"); (\"A\", \"banana\"); (\"B\", \"banana\")]\n * false\n * >>> check_dict_case [(\"a\", \"apple\"); (8, \"banana\"); (\"a\", \"apple\")]\n * false\n * >>> check_dict_case [(\"Name\", \"John\"); (\"Age\", \"36\"); (\"City\", \"Houston\")]\n * false\n * >>> check_dict_case [(\"STATE\", \"NC\"); (\"ZIP\", \"12345\")]\n * true\n*)\nlet check_dict_case (dict : (string, string) list) : bool =\n  let rec check_dict_case_aux (dict : (string, string) list) (key : string) (value : string) : bool =\n    match dict with\n    | [] -> false\n    | (k, v) :: rest ->\n        if k = key && v = value then\n          check_dict_case_aux rest (key) (value)\n        else\n          check_dict_case_aux rest (key) (value)\n    | _ -> false\n  in check_dict_case_aux dict (key) (value)\n"], ["(**Implement a function that takes an non-negative integer and returns a list of the first n\n * integers that are prime numbers and less than n.\n * for example:\n * >>> count_up_to 5\n * [2; 3]\n * >>> count_up_to 11\n * [2; 3; 5; 7]\n * >>> count_up_to 0\n * []\n * >>> count_up_to 20\n * [2; 3; 5; 7; 11; 13; 17; 19]\n * >>> count_up_to 1\n * []\n * >>> count_up_to 18\n * [2; 3; 5; 7; 11; 13; 17]\n*)\nlet count_up_to (n : int) : int list =\n  let rec aux n acc =\n    if n <= 0 then\n      acc\n    else\n      let rec aux_aux n acc =\n        if n <= 0 then\n          acc\n        else\n          aux_aux (n - 1) (aux n (acc @ [n]))\n      in\n      aux_aux n []\n  in\n  aux n []\n;;"], ["(**Complete the function that takes two integers and returns \n * the product of their unit digits.\n * Assume the input is always valid.\n * Examples:\n * >>> multiply 148 412\n * 16\n * >>> multiply 19 28\n * 72\n * >>> multiply 2020 1851\n * 0\n * >>> multiply 14 (~15)\n * 20\n*)\nlet multiply (a : int) (b : int) : int =\n  let rec loop (a : int) (b : int) : int =\n    match (a, b) with\n    | (a, 0) -> a\n    | (0, b) -> b\n    | (a, b) -> a * b\n  in loop a b"], ["(**Given a string s, count the number of uppercase vowels in even indices.\n * For example:\n * >>> count_upper \"aBCdEf\"\n * 1\n * >>> count_upper \"abcdefg\"\n * 0\n * >>> count_upper \"dBBE\"\n * 0\n*)\nlet count_upper (s : string) : int =\n  let rec count_upper_aux (s : string) : int =\n    match s with\n    | [] -> 0\n    | [x] -> 1\n    | x :: xs ->\n        if x = 'A' || x = 'a' then count_upper_aux xs\n        else count_upper_aux (x :: xs)\n  in count_upper_aux s\n;;"], ["(**Create a function that takes a value (string) representing a number\n * and returns the closest integer to it. If the number is equidistant\n * from two integers, round it away from zero.\n * Examples\n * >>> closest_integer \"10\"\n * 10\n * >>> closest_integer \"15.3\"\n * 15\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n*)\nlet closest_integer (value : string) : int =\n  let rec closest_integer_rec (value : string) : int =\n    match value with\n    | \"0\" -> 0\n    | \"1\" -> 1\n    | \"2\" -> 2\n    | \"3\" -> 3\n    | \"4\" -> 4\n    | \"5\" -> 5\n    | \"6\" -> 6\n    | \"7\" -> 7\n    | \"8\" -> 8\n    | \"9\" -> 9\n    | \"10\" -> 10\n    | \"11\" -> 11\n    | \"12\" -> 12\n    | \"13\" -> 13\n    | \"14\" -> 14\n    | \"15\" -> 15\n    | \"16\" -> 16\n    | \"17\" -> 17\n    | \"18\" -> 18\n    | \"19\" -> 19\n    | \"20\" -> 20\n    | \"21\" -> 21\n    | \"22\" -> 22\n    | \"23\" -> 23\n    | \"24\" -> 24\n    | \"25\" -> 25\n    | \"26\" -> 26\n    | \"27\" -> 27\n    | \"28\" -> 28\n    | \"29\" -> 29\n    | \""], ["(**Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n * Examples:\n * >>> make_a_pile 3\n * [3; 5; 7]\n*)\nlet make_a_pile (n : int) : int list =\n  let rec make_a_pile_helper n =\n    if n = 0 then []\n    else\n      let rec make_a_pile_helper_helper n =\n        if n = 0 then []\n        else\n          let rec make_a_pile_helper_helper_helper n =\n            if n = 0 then []\n            else\n              let rec make_a_pile_helper_helper_helper_helper n =\n                if n = 0 then []\n                else\n                  let rec make_a_pile_helper_helper_helper_helper_helper n =\n                    if n = 0 then []\n                    else\n                      let rec make_a_pile_helper_helper_helper_helper_helper_helper n =\n                        if n = 0 then []\n                        else\n                          let rec make_a_pile_helper_helper_helper_helper_helper_helper_helper n =\n                            if n = 0 then []\n                            else\n                              let rec make_a_pile_helper_helper_helper_helper_helper_helper_helper_helper n =\n                                if n = 0 then []\n                                else\n                                  let rec make_a_pile_helper_helper_helper_helper_helper_helper_helper_helper_helper n =\n                                    if n = 0 then []\n                                    else\n                                      let rec make_a_pile_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n =\n                                        if n ="], ["(**You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return a list of the words.\n * For example:\n * >>> words_string \"Hi, my name is John\"\n * [\"Hi\"; \"my\"; \"name\"; \"is\"; \"John\"]\n * >>> words_string \"One, two, three, four, five, six\"\n * [\"One\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"]\n*)\nlet words_string (s : string) : string list =\n  let rec aux acc = function\n    | [] -> acc\n    | x :: xs -> aux (x :: acc) xs\n  in aux [] s\n;;"], ["(**This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive. If \n * there's no such number, then the function should return -1.\n * For example:\n * >>> choose_num 12 15\n * 14\n * >>> choose_num 13 12\n * (~1)\n*)\nlet choose_num (x : int) (y : int) : int =\n  let rec choose_num_rec (x, y) =\n    if x > y then\n      x\n    else\n      if x > 0 then\n        choose_num_rec (x - 1, y)\n      else\n        y\n  in\n  choose_num_rec (x, y)\n;;"], ["(**Given a list of positive integers x. return a sorted list of all \n * elements that hasn't any even digit.\n * Note: Returned list should be sorted in increasing order.\n * For example:\n * >>> unique_digits [15; 33; 1422; 1]\n * [1; 15; 33]\n * >>> unique_digits [152; 323; 1422; 10]\n * []\n*)\nlet unique_digits (x : int list) : int list =\n  let rec aux x = function\n    | [] -> []\n    | [x] -> [x]\n    | (x :: xs) :: xs' -> aux xs' (x :: x :: xs)\n  in aux x []\n;;"], ["(**Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting list, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n * For example:\n * >>> by_length [2; 1; 1; 4; 5; 8; 2; 3]\n * [\"Eight\"; \"Five\"; \"Four\"; \"Three\"; \"Two\"; \"Two\"; \"One\"; \"One\"]\n * If the list is empty, return an empty list:\n * >>> by_length []\n * []\n * If the list has any strange number ignore it:\n * >>> by_length [1; (~1); 55]\n * [\"One\"]\n*)\nlet by_length (arr : int list) : string list =\n  let rec by_length_aux arr = function\n    | [] -> []\n    | x :: xs ->\n        let name = match x with | 1 -> \"One\" | 2 -> \"Two\" | 3 -> \"Three\" | 4 -> \"Four\" | 5 -> \"Five\" | 6 -> \"Six\" | 7 -> \"Seven\" | 8 -> \"Eight\" | 9 -> \"Nine\" | _ -> \"Unknown\" in\n        by_length_aux xs name\n  in by_length_aux arr\n"], ["(**Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * >>> f 5\n * [1; 2; 6; 24; 15]\n*)\nlet f (n : int) : int list =\n  let rec aux n =\n    if n = 0 then []\n    else aux (n - 1) @ [n]\n  in aux 1\n;;"], ["(**Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n * Example 1:\n * >>> even_odd_palindrome 3\n * (1, 2)\n * Explanation:\n * Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n * Example 2:\n * >>> even_odd_palindrome 12\n * (4, 6)\n * Explanation:\n * Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n * Note:\n * 1. 1 <= n <= 10^3\n * 2. returned tuple has the number of even and odd integer palindromes respectively.\n*)\nlet even_odd_palindrome (n : int) :  int * int =\n  let rec even_odd_palindrome_helper (n : int) : int * int =\n    match n with\n    | 0 -> (0, 0)\n    | _ ->\n        let even_palindrome = n / 2\n        let odd_palindrome = n - even_palindrome\n        let even_odd_palindrome_helper (n : int) =\n          if even_palindrome > 0 then even_odd_palindrome_helper (n - even_palindrome)\n          else even_odd_palindrome_helper (n + odd_palindrome)\n        even_odd_palindrome_helper (n + 1)\n    in even_odd_palindrome_helper n\n  in even_odd_palindrome_helper n\n;;"], ["(**Write a function count_nums which takes a list of integers and returns\n * the number of elements which has a sum of digits > 0.\n * If a number is negative, then its first signed digit will be negative:\n * e.g. -123 has signed digits -1, 2, and 3.\n * >>> count_nums []\n * 0\n * >>> count_nums [(~1); 11; (~11)]\n * 1\n * >>> count_nums [1; 1; 2]\n * 3\n*)\nlet count_nums (arr : int list) : int =\n  let rec count_nums_helper arr = function\n    | [] -> 0\n    | x :: xs ->\n        if x > 0 && arr.(x) > 0 then count_nums_helper xs else count_nums_helper xs + 1\n  in count_nums_helper arr\n;;"], ["(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n * numbers in the list will be randomly ordered. Your task is to determine if\n * it is possible to get a list sorted in non-decreasing order by performing \n * the following operation on the given list:\n * You are allowed to perform right shift operation any number of times.\n * One right shift operation means shifting all elements of the list by one\n * position in the right direction. The last element of the list will be moved to\n * the starting position in the list i.e. 0th index. \n * If it is possible to obtain the sorted list by performing the above operation\n * then return true else return false.\n * If the given list is empty then return true.\n * Note: The given list is guaranteed to have unique elements.\n * For Example:\n * >>> move_one_ball [3; 4; 5; 1; 2]\n * true\n * Explanation: By performin 2 right shift operations, non-decreasing order can\n * be achieved for the given list.\n * >>> move_one_ball [3; 5; 4; 1; 2]\n * false\n * Explanation:It is not possible to get non-decreasing order for the given\n * list by performing any number of right shift operations.\n*)\nlet move_one_ball (arr : int list) : bool =\n  let rec move_one_ball_helper (arr : int list) (i : int) : bool =\n    match arr with\n    | [] -> true\n    | _ :: rest ->\n        if i >= rest |> Array.length then\n          move_one_ball_helper rest (i + 1)\n        else\n          move_one_ball_helper rest (i + 1)\n    |> Array.map (fun x -> x + 1)\n  in\n  move_one_ball_helper arr 0\n;;"], ["(**In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]\n * \"YES\"\n * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]\n * \"NO\"\n * It is assumed that the input lists will be non-empty.\n*)\nlet exchange (lst1 : int list) (lst2 : int list) : string =\n  let rec exchange_helper lst1 lst2 =\n    match lst1 with\n    | [] -> \"YES\"\n    | hd :: tl ->\n        if hd = lst2.(0) then\n          exchange_helper tl (tl @ [lst2.(0)])\n        else\n          if hd = lst2.(1) then\n            exchange_helper (tl @ [lst2.(1)]) tl\n          else\n            if hd = lst2.(2) then\n              exchange_helper (tl @ [lst2.(2)]) (tl @ [lst2.(0)])\n            else\n              if hd = lst2.(3) then\n                exchange_helper (tl @ [lst2.(3)]) (tl @ [lst2.(1)])\n              else\n                \"NO\"\n          else\n            \"NO\"\n  in\n  exchange_helper lst1 lst2\n;;"], ["(**Given a string representing a space separated lowercase letters, return an association list\n * of the letter with the most repetition and containing the corresponding count.\n * If several letters have the same occurrence, return all of them.\n * Example:\n * >>> histogram \"a b c\"\n * [(\"a\", 1); (\"b\", 1); (\"c\", 1)]\n * >>> histogram \"a b b a\"\n * [(\"a\", 2); (\"b\", 2)]\n * >>> histogram \"a b c a b\"\n * [(\"a\", 2); (\"b\", 2)]\n * >>> histogram \"b b b b a\"\n * [(\"b\", 4)]\n * >>> histogram \"\"\n * []\n*)\nlet histogram (test : string) : (string, int) list =\n  let rec loop (lst : string list) (count : int) : (string, int) list =\n    match lst with\n    | [] -> []\n    | h :: t ->\n        let rec loop2 (lst : string list) (count : int) =\n          match lst with\n          | [] -> []\n          | h :: t ->\n              let rec loop3 (lst : string list) (count : int) =\n                match lst with\n                | [] -> []\n                | h :: t ->\n                    let rec loop4 (lst : string list) (count : int) =\n                      match lst with\n                      | [] -> []\n                      | h :: t ->\n                          let rec loop5 (lst : string list) (count : int) =\n                            match lst with\n                            | [] -> []\n                            | h :: t ->\n                                let rec loop6 (lst : string list) (count : int) =\n                                  match lst with\n                                  | [] -> []\n                                  | h :: t ->\n                                      let rec loop7 (lst : string list) (count : int) =\n                                        match lst with\n                                        | [] -> []\n                                        | h :: t ->\n                                            let rec loop8 (lst : string list) (count : int) =\n                                              match lst with\n                                              | [] -> []\n                                              | h :: t ->\n"], ["(**Task\n * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n * then check if the result string is palindrome.\n * A string is called palindrome if it reads the same backward as forward.\n * You should return a tuple containing the result string and true/false for the check.\n * Example\n * >>> reverse_delete \"abcde\" \"ae\"\n * (\"bcd\", false)\n * >>> reverse_delete \"abcdef\" \"b\"\n * (\"acdef\", false)\n * >>> reverse_delete \"abcdedcba\" \"ab\"\n * (\"cdedc\", true)\n*)\nlet reverse_delete (s : string) (c : string) :  string * bool =\n  let rec reverse_delete_aux s c =\n    match s with\n    | [] -> (c, true)\n    | h::t ->\n        if h = c then reverse_delete_aux t c\n        else (reverse_delete_aux t (h::c), false)\n  in reverse_delete_aux s c\n;;"], ["(**Given a list of strings, where each string consists of only digits, return a list.\n * Each element i of the output should be \"the number of odd elements in the\n * string i of the input.\" where all the i's should be replaced by the number\n * of odd digits in the i'th string of the input.\n * >>> odd_count [\"1234567\"]\n * [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n * >>> odd_count [\"3\"; \"11111111\"]\n * [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"; \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n*)\nlet odd_count (lst : string list) : string list =\n  let rec odd_count_aux lst =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let n = List.length hd in\n        let n_odd = odd n in\n        let n_even = even n in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in\n        let n_odd_str = string_of_int n_odd in\n        let n_even_str = string_of_int n_even in"], ["(**Given a list of integers nums, find the minimum sum of any non-empty sub-list\n * of nums.\n * Example\n * >>> minSubArraySum [2; 3; 4; 1; 2; 4]\n * 1\n * >>> minSubArraySum [(~1); (~2); (~3)]\n * (~6)\n*)\nlet minSubArraySum (nums : int list) : int =\n  let rec minSubArraySum_aux (nums, acc) = function\n    | [] -> acc\n    | (x, xs) :: xs' when x < 0 -> minSubArraySum_aux (xs, acc + x) xs'\n    | (x, xs) :: xs' -> minSubArraySum_aux (xs, acc + x) xs'\n  in minSubArraySum_aux nums []"], ["(**You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n * Example 1:\n * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1\n * 6\n * Example 2:\n * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2\n * 5\n * Example 3:\n * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5\n * 0\n * Constraints:\n * * all wells have the same length\n * * 1 <= grid.length <= 10^2\n * * 1 <= grid[:,1].length <= 10^2\n * * grid[i][j] -> 0 | 1\n * * 1 <= capacity <= 10\n*)\nlet max_fill (grid : int list list) (capacity : int) : int =\n    let rec fill_buckets (buckets : int list) (capacity : int) : int =\n        match buckets with\n        | [] -> 0\n        | [b] -> b\n        | [b; b2] -> fill_buckets [b; b2] (capacity - b)\n        | [b; b1; b2] -> fill_buckets [b; b1; b2] (capacity - b1 - b)\n        | [b; b1; b2; b3] -> fill_buckets [b; b1; b2; b3] (capacity - b1 - b2 - b)\n        | [b; b1; b2"], ["(**In this Kata, you have to sort a list of non-negative integers according to\n * number of ones in their binary representation in ascending order.\n * For similar number of ones, sort based on decimal value.\n * It must be implemented like this:\n * >>> sort_array [1; 5; 2; 3; 4]\n * [1; 2; 3; 4; 5]\n * >>> sort_array [(~2); (~3); (~4); (~5); (~6)]\n * [(~6); (~5); (~4); (~3); (~2)]\n * >>> sort_array [1; 0; 2; 3; 4]\n * [0; 1; 2; 3; 4]\n*)\nlet sort_array (arr : int list) : int list =\n  let rec sort_helper (arr : int list) : int list = function\n    | [] -> []\n    | hd :: tl ->\n        let rec sort_helper_helper (arr : int list) : int list = function\n          | [] -> []\n          | hd :: tl ->\n              let rec sort_helper_helper_helper (arr : int list) : int list = function\n                | [] -> []\n                | hd :: tl ->\n                    let rec sort_helper_helper_helper_helper (arr : int list) : int list = function\n                      | [] -> []\n                      | hd :: tl ->\n                          let rec sort_helper_helper_helper_helper_helper (arr : int list) : int list = function\n                            | [] -> []\n                            | hd :: tl ->\n                                let rec sort_helper_helper_helper_helper_helper_helper (arr : int list) : int list = function\n                                  | [] -> []\n                                  | hd :: tl ->\n                                      let rec sort_helper_helper_helper_helper_helper_helper_helper (arr : int list) : int list = function\n                                        | [] -> []\n                                        | hd :: tl ->\n                                            let rec sort_helper_helper_helper_helper_helper_helper_helper_helper_"], ["(**Given a string s and a natural number n, you have been tasked to implement \n * a function that returns a list of all words from string s that contain exactly \n * n consonants, in order these words appear in the string s.\n * If the string s is empty then the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n * Examples:\n * >>> select_words \"Mary had a little lamb\" 4\n * [\"little\"]\n * >>> select_words \"Mary had a little lamb\" 3\n * [\"Mary\"; \"lamb\"]\n * >>> select_words \"simple white space\" 2\n * []\n * >>> select_words \"Hello world\" 4\n * [\"world\"]\n * >>> select_words \"Uncle sam\" 3\n * [\"Uncle\"]\n*)\nlet select_words (s : string) (n : int) : string list =\n  let rec select_words_aux (s : string) (n : int) (words : string list) : string list =\n    match s with\n    | \"\" -> words\n    | _ ->\n        let rec select_words_aux_aux (s : string) (n : int) (words : string list) : string list =\n          match s with\n          | _ when n = 0 -> words\n          | _ when n = 1 -> words\n          | _ ->\n              let rec select_words_aux_aux_aux (s : string) (n : int) (words : string list) : string list =\n                match s with\n                | _ when n = 0 -> words\n                | _ when n = 1 -> words\n                | _ ->\n                    let rec select_words_aux_aux_aux_aux (s : string) (n : int) (words : string list) : string list =\n                      match s with\n                      | _ when n = 0 -> words\n                      | _ when n = 1 -> words\n                      | _ ->\n                          let rec select_words_aux_aux_aux_aux_aux (s : string) (n : int) (words : string list) : string list =\n                            match s with\n                            | _ when"], ["(**You are given a word. Your task is to find the closest vowel that stands between \n * two consonants from the right side of the word (case sensitive).\n * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n * find any vowel met the above condition. \n * You may assume that the given string contains English letter only.\n * Example:\n * >>> get_closest_vowel \"yogurt\"\n * \"u\"\n * >>> get_closest_vowel \"FULL\"\n * \"U\"\n * >>> get_closest_vowel \"quick\"\n * \"\"\n * >>> get_closest_vowel \"ab\"\n * \"\"\n*)\nlet get_closest_vowel (word : string) : string =\n  let rec helper (word : string) (vowel : string) =\n    if vowel = \"\" then \"\"\n    else if vowel = \"a\" then word\n    else if vowel = \"e\" then word\n    else if vowel = \"i\" then word\n    else if vowel = \"o\" then word\n    else if vowel = \"u\" then word\n    else if vowel = \"A\" then word\n    else if vowel = \"E\" then word\n    else if vowel = \"I\" then word\n    else if vowel = \"O\" then word\n    else if vowel = \"U\" then word\n    else \"\"\n  in\n  helper word \"\"\n;;"], ["(**You are given a list of two strings, both strings consist of open\n * parentheses '(' or close parentheses ')' only.\n * Your job is to check if it is possible to concatenate the two strings in\n * some order, that the resulting string will be good.\n * A string S is considered to be good if and only if all parentheses in S\n * are balanced. For example: the string '(())()' is good, while the string\n * '())' is not.\n * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n * Examples:\n * >>> match_parens [\"()(\"; \")\"]\n * \"Yes\"\n * >>> match_parens [\")\"; \")\"]\n * \"No\"\n*)\nlet match_parens (lst : string list) : string =\n  let rec loop (lst : string list) : string option =\n    match lst with\n    | [] -> None\n    | h :: t ->\n        if h = \"(\" && t = \")\" then Some (h :: t)\n        else if h = \"(\" && t = \")\" && h <> \"(\" then loop t\n        else loop (h :: t)\n  in\n  loop lst\n;;"], ["(**Given a list arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n * Example 1:\n * >>> maximum [(~3); (~4); 5] 3\n * [(~4); (~3); 5]\n * Example 2:\n * >>> maximum [4; (~4); 4] 2\n * [4; 4]\n * Example 3:\n * >>> maximum [(~3); 2; 1; 2; (~1); (~2); 1] 1\n * [2]\n * Note:\n * 1. The length of the list will be in the range of [1, 1000].\n * 2. The elements in the list will be in the range of [-1000, 1000].\n * 3. 0 <= k <= len(arr)\n*)\nlet maximum (arr : int list) (k : int) : int list =\n  let rec helper arr k =\n    match arr with\n    | [] -> []\n    | h :: t ->\n        let max = if k = 0 then h else if k = 1 then h + 1 else h + max (helper t k - 1) in\n        if k = 0 then [max]\n        else if k = 1 then [max]\n        else if k = 2 then [max; h]\n        else if k = 3 then [max; h; max]\n        else if k = 4 then [max; h; max; max]\n        else if k = 5 then [max; h; max; max; max]\n        else if k = 6 then [max; h; max; max; max; max]\n        else if k = 7 then [max; h; max; max; max; max; max]\n        else if k = 8 then [max; h; max; max; max; max; max; max]\n        else if k = 9 then [max; h; max; max; max; max; max; max; max]\n        else if k = 10 then [max; h; max; max; max; max; max; max; max"], ["(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n * Examples\n * >>> solution [5; 8; 7; 1]\n * 12\n * >>> solution [3; 3; 3; 3; 3]\n * 9\n * >>> solution [30; 13; 24; 321]\n * 0\n*)\nlet solution (lst : int list) : int =\n  let rec sum lst = function\n    | [] -> 0\n    | x :: xs -> x + sum xs\n  in sum lst\n;;"], ["(**Given a non-empty list of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n * Example:\n * >>> add_elements [111; 21; 3; 4000; 5; 6; 7; 8; 9] 4\n * 24\n * Constraints:\n * 1. 1 <= len(arr) <= 100\n * 2. 1 <= k <= len(arr)\n*)\nlet add_elements (arr : int list) (k : int) : int =\n  let rec aux arr k =\n    match arr with\n    | [] -> 0\n    | hd :: tl ->\n        let sum = aux tl (k - 1) in\n        sum + hd\n  in aux arr k\n;;"], ["(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n * as follows: start with any positive integer n. Then each term is obtained from the \n * previous term as follows: if the previous term is even, the next term is one half of \n * the previous term. If the previous term is odd, the next term is 3 times the previous\n * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n * Note: \n * 1. Collatz(1) is [1].\n * 2. returned list sorted in increasing order.\n * For example:\n * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n * >>> get_odd_collatz 5\n * [1; 5]\n*)\nlet get_odd_collatz (n : int) : int list =\n    let rec collatz_helper (n : int) : int list =\n        match n with\n        | 0 -> [n]\n        | 1 -> [n]\n        | _ ->\n            let half = n / 2\n            let next = collatz_helper (half)\n            let prev = collatz_helper (half - 1)\n            [next; prev; half]\n    in collatz_helper n\nin get_odd_collatz 1"], ["(**You have to write a function which validates a given date string and\n * returns true if the date is valid otherwise false.\n * The date is valid if all of the following rules are satisfied:\n * 1. The date string is not empty.\n * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n * 3. The months should not be less than 1 or higher than 12.\n * 4. The date should be in the format: mm-dd-yyyy\n * >>> valid_date \"03-11-2000\"\n * true\n * >>> valid_date \"15-01-2012\"\n * false\n * >>> valid_date \"04-0-2040\"\n * false\n * >>> valid_date \"06-04-2020\"\n * true\n * >>> valid_date \"06/04/2020\"\n * false\n*)\nlet valid_date (date : string) : bool =\n  let rec loop (date : string) : bool =\n    match date with\n    | \"\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-00-00\" -> true\n    | \"0000-0"], ["(**Given a list of numbers, return whether or not they are sorted\n * in ascending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n * >>> is_sorted [5]\n * true\n * >>> is_sorted [1; 2; 3; 4; 5]\n * true\n * >>> is_sorted [1; 3; 2; 4; 5]\n * false\n * >>> is_sorted [1; 2; 3; 4; 5; 6]\n * true\n * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]\n * true\n * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]\n * false\n * >>> is_sorted [1; 2; 2; 3; 3; 4]\n * true\n * >>> is_sorted [1; 2; 2; 2; 3; 4]\n * false\n*)\nlet is_sorted (lst : int list) : bool =\n  let rec helper lst =\n    match lst with\n    | [] -> true\n    | hd :: tl -> if hd > lst then false else if hd < lst then helper tl else helper tl\n  in helper lst\n;;"], ["(**You are given two intervals,\n * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n * The given intervals are closed which means that the interval (start, end)\n * includes both start and end.\n * For each given interval, it is assumed that its start is less or equal its end.\n * Your task is to determine whether the length of intersection of these two \n * intervals is a prime number.\n * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n * which its length is 1, which not a prime number.\n * If the length of the intersection is a prime number, return \"YES\",\n * otherwise, return \"NO\".\n * If the two intervals don't intersect, return \"NO\".\n * [input/output] samples:\n * >>> intersection (1, 2) (2, 3)\n * \"NO\"\n * >>> intersection ((~1), 1) (0, 4)\n * \"NO\"\n * >>> intersection ((~3), (~1)) ((~5), 5)\n * \"YES\"\n*)\nlet intersection (interval1 :  int * int) (interval2 :  int * int) : string =\n  let rec intersection_helper (i1 : int) (i2 : int) : string =\n    match (i1, i2) with\n    | (1, _) -> \"YES\"\n    | (_, 1) -> \"YES\"\n    | (_, _) -> \"NO\"\n    | (i1, j1) -> if j1 = 0 then \"YES\" else intersection_helper (i1 + 1, j1 - 1)\n  in\n  match interval1 with\n  | (start1, end1) -> intersection_helper (start1, end1)\n  | _ -> \"NO\"\n;;"], ["(**You are given a list arr of integers and you need to return\n * sum of magnitudes of integers multiplied by product of all signs\n * of each number in the list, represented by 1, -1 or 0.\n * Note: return None for empty arr.\n * Example:\n * >>> prod_signs [1; 2; 2; (~4)]\n * Some(9)\n * >>> prod_signs [0; 1]\n * Some(0)\n * >>> prod_signs []\n * Some(None)\n*)\nlet prod_signs (arr : int list) : int option =\n  let rec prod_signs_helper (arr : int list) : int option = function\n    | [] -> None\n    | (x :: xs) ->\n      let sign = if x < 0 then -1 else if x > 0 then 1 else 0\n      let product = sign * prod_signs_helper xs\n      Some (product)\n  in prod_signs_helper arr\n"], ["(**Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n * You have to find the minimum path of length k in the grid. You can start\n * from any cell, and in each step you can move to any of the neighbor cells,\n * in other words, you can go to cells which share an edge with you current\n * cell.\n * Please note that a path of length k means visiting exactly k cells (not\n * necessarily distinct).\n * You CANNOT go off the grid.\n * A path A (of length k) is considered less than a path B (of length k) if\n * after making the ordered lists of the values on the cells that A and B go\n * through (let's call them lst_A and lst_B), lst_A is lexicographically less\n * than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n * lst_A[j] = lst_B[j].\n * It is guaranteed that the answer is unique.\n * Return an ordered list of the values on the cells that the minimum path go through.\n * Examples:    \n * >>> minPath [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 3\n * [1; 2; 1]\n * >>> minPath [[5; 9; 3]; [4; 1; 6]; [7; 8; 2]] 1\n * [1]\n*)\nlet minPath (grid : int list list) (k : int) : int list =\n  let rec minPath_helper (grid, k) = function\n    | [] -> []\n    | (x, y) :: rest when x < k ->\n        let (min_x, min_y) = minPath_helper (grid, k - x) rest in\n        (x, y) :: (min_x, min_"], ["(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n * the last couple centuries. However, what people don't know is Tribonacci sequence.\n * Tribonacci sequence is defined by the recurrence:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, if n is even.\n * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n * For example:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8 \n * You are given a non-negative integer number n, you have to a return a list of the \n * first n + 1 numbers of the Tribonacci sequence.\n * Examples:\n * >>> tri 3\n * [1; 3; 2; 8]\n*)\nlet tri (n : int) : int list =\n  let rec tri_helper n acc =\n    if n = 0 then acc\n    else tri_helper (n - 1) (acc + 1)\n  in tri_helper n []\n  ;;"], ["(**Given a positive integer n, return the product of the odd digits.\n * Return 0 if all digits are even.\n * For example:\n * >>> digits 1\n * 1\n * >>> digits 4\n * 0\n * >>> digits 235\n * 15\n*)\nlet digits (n : int) : int =\n  let rec loop n =\n    if n < 10 then n\n    else if n mod 10 = 0 then loop (n / 10)\n    else loop (n / 10) * 10 + n mod 10\n  in loop n\n;;"], ["(**Create a function that takes a string as input which contains only square brackets.\n * The function should return true if and only if there is a valid subsequence of brackets \n * where at least one bracket in the subsequence is nested.\n * >>> is_nested \"[[]]\"\n * true\n * >>> is_nested \"[]]]]]]][[[[[]\"\n * false\n * >>> is_nested \"[][]\"\n * false\n * >>> is_nested \"[]\"\n * false\n * >>> is_nested \"[[][]]\"\n * true\n * >>> is_nested \"[[]][[\"\n * true\n*)\nlet is_nested (string : string) : bool =\n    let rec loop (string : string) : bool =\n        match string with\n        | [] -> true\n        | [x] -> false\n        | (x :: xs) :: rest ->\n            match x with\n            | '[' -> loop xs\n            | ']' -> loop rest\n            | _ -> loop xs :: rest\n    loop string\nin\nis_nested \"\""], ["(**You are given a list of numbers.\n * You need to return the sum of squared numbers in the given list,\n * round each element in the list to the upper int(Ceiling) first.\n * Examples:\n * >>> lst [1.0; 2.0; 3.0]\n * 14\n * >>> lst [1.0; 4.0; 9.0]\n * 98\n * >>> lst [1.0; 3.0; 5.0; 7.0]\n * 84\n * >>> lst [1.4; 4.2; 0.0]\n * 29\n * >>> lst [-2.4; 1.0; 1.0]\n * 6\n*)\nlet sum_squares (lst : float list) : int =\n  let rec sum_squares_helper lst =\n    match lst with\n    | [] -> 0\n    | [x] -> x\n    | (x :: xs) -> x +. sum_squares_helper xs\n  in sum_squares_helper lst\nin sum_squares_helper lst\n"], ["(**Create a function that returns true if the last character\n * of a given string is an alphabetical character and is not\n * a part of a word, and false otherwise.\n * Note: \"word\" is a group of characters separated by space.\n * Examples:\n * >>> check_if_last_char_is_a_letter \"apple pie\"\n * false\n * >>> check_if_last_char_is_a_letter \"apple pi e\"\n * true\n * >>> check_if_last_char_is_a_letter \"apple pi e \"\n * false\n * >>> check_if_last_char_is_a_letter \"\"\n * false\n*)\nlet check_if_last_char_is_a_letter (txt : string) : bool =\n  let rec check_last_char_is_letter (txt : string) : bool =\n    match txt with\n    | [] -> true\n    | [c] -> c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'\n    | _ -> false\n  in\n  check_last_char_is_letter txt\n;;"], ["(**Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given list will not contain\n * duplicate values.\n * Examples:\n * >>> can_arrange [1; 2; 4; 3; 5]\n * 3\n * >>> can_arrange [1; 2; 3]\n * (~1)\n*)\nlet can_arrange (arr : int list) : int =\n  let rec aux arr = function\n    | [] -> -1\n    | x :: xs -> if x > arr then aux xs else aux (x :: arr)\n  in aux arr"], ["(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n * Example\n * >>> is_equal_to_sum_even 4\n * false\n * >>> is_equal_to_sum_even 6\n * false\n * >>> is_equal_to_sum_even 8\n * true\n*)\nlet is_equal_to_sum_even (n : int) : bool =\n  let rec is_even_sum (n : int) : bool =\n    match n with\n    | 0 -> true\n    | _ -> is_even_sum (n / 2)\n  in\n  is_even_sum n\n;;"], ["(**The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n * where n > 0\n * For example:\n * >>> special_factorial 4\n * 288\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n*)\nlet special_factorial (n : int) : int =\n  let rec aux n =\n    if n = 0 then 1\n    else aux (n - 1) * n\n  in aux n\n;;"], ["(**Given a string text, replace all spaces in it with underscores, \n * and if a string has more than 2 consecutive spaces, \n * then replace all consecutive spaces with - \n * >>> fix_spaces \" Example\"\n * \"Example\"\n * >>> fix_spaces \" Example 1\"\n * \"Example_1\"\n * >>> fix_spaces \" Example 2\"\n * \"_Example_2\"\n * >>> fix_spaces \" Example 3\"\n * \"_Example-3\"\n*)\nlet fix_spaces (text : string) : string =\n  let rec fix_spaces_rec (text : string) : string =\n    match text with\n    | \"\" -> text\n    | s ->\n        let (spaces, rest) = String.split_on_char ' ' s in\n        let (spaces, rest) = fix_spaces_rec rest in\n        sprintf \"%s%s\" spaces (fix_spaces_rec spaces)\n  in fix_spaces_rec text\n;;"], ["(**Create a function which takes a string representing a file's name, and returns\n * 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n * A file's name is considered to be valid if and only if all the following conditions \n * are met:\n * - There should not be more than three digits ('0'-'9') in the file's name.\n * - The file's name contains exactly one dot '.'\n * - The substring before the dot should not be empty, and it starts with a letter from \n * the latin alphapet ('a'-'z' and 'A'-'Z').\n * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n * Examples:\n * >>> file_name_check \"example.txt\"\n * \"Yes\"\n * >>> file_name_check \"1example.dll\"\n * \"No\"\n*)\nlet file_name_check (file_name : string) : string =\n  let is_valid = function\n    | \"\" -> true\n    | _ -> String.length file_name > 3 && String.length file_name < 10 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String.length file_name < 26 && String.length file_name > 1 && String"], ["(**\"\n * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n * Examples:\n * >>> lst\n * [1; 2; 3]\n * >>> lst\n * []\n * >>> lst\n * [(~1); (~5); 2; (~1); (~5)]\n*)\nlet sum_squares (lst : int list) : int =\n  let rec sum_squares_helper lst = function\n    | [] -> 0\n    | (x :: xs) -> x + (sum_squares_helper xs)\n  in sum_squares_helper lst"], ["(**You are given a string representing a sentence,\n * the sentence contains some words separated by a space,\n * and you have to return a string that contains the words from the original sentence,\n * whose lengths are prime numbers,\n * the order of the words in the new string should be the same as the original one.\n * Example 1:\n * >>> words_in_sentence \"This is a test\"\n * \"is\"\n * Example 2:\n * >>> words_in_sentence \"lets go for swimming\"\n * \"go for\"\n * Constraints:\n * * 1 <= len(sentence) <= 100\n * * sentence contains only letters\n*)\nlet words_in_sentence (sentence : string) : string =\n  let rec words_in_sentence_helper (sentence : string) (words : string list) : string list =\n    match sentence with\n    | \"\" -> words\n    | _ :: rest ->\n        let rec words_in_sentence_helper_rest (rest : string) (words : string list) : string list =\n          match rest with\n          | \"\" -> words\n          | _ :: rest ->\n              let rec words_in_sentence_helper_rest_rest (rest : string) (words : string list) : string list =\n                match rest with\n                | \"\" -> words\n                | _ :: rest ->\n                    let rec words_in_sentence_helper_rest_rest_rest (rest : string) (words : string list) : string list =\n                      match rest with\n                      | \"\" -> words\n                      | _ :: rest ->\n                          let rec words_in_sentence_helper_rest_rest_rest_rest (rest : string) (words : string list) : string list =\n                            match rest with\n                            | \"\" -> words\n                            | _ :: rest ->\n                                let rec words_in_sentence_helper_rest_rest_rest_rest_rest (rest : string) (words : string list) : string list =\n                                  match rest with\n                                  | \"\" -> words\n                                  | _ :: rest ->\n                                      let rec words_in_sentence_helper_rest_rest_rest_rest_rest_"], ["(**Your task is to implement a function that will simplify the expression\n * x * n. The function returns true if x * n evaluates to a whole number and false\n * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n * >>> simplify \"1/5\" \"5/1\"\n * true\n * >>> simplify \"1/6\" \"2/1\"\n * false\n * >>> simplify \"7/10\" \"10/2\"\n * false\n*)\nlet simplify (x : string) (n : string) : bool =\n  let rec helper (x : string) (n : string) : bool =\n    match x, n with\n    | \"1\", \"1\" -> true\n    | \"1\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    | \"0\", _ -> false\n    |"], ["(**Write a function which sorts the given list of integers\n * in ascending order according to the sum of their digits.\n * Note: if there are several items with similar sum of their digits,\n * order them based on their index in original list.\n * For example:\n * >>> order_by_points [1; 11; (~1); (~11); (~12)]\n * [(~1); (~11); 1; (~12); 11]\n * >>> order_by_points []\n * []\n*)\nlet order_by_points (nums : int list) : int list =\n  let rec sort_by_sum (nums : int list) : int list =\n    match nums with\n    | [] -> []\n    | hd :: tl ->\n        let sum = List.fold_left (fun acc x -> x + acc) 0 hd :: List.fold_left (fun acc x -> x + acc) tl []\n        sort_by_sum (hd :: tl)\n  in\n  sort_by_sum nums\n;;"], ["(**Write a function that takes a list of numbers as input and returns \n * the number of elements in the list that are greater than 10 and both \n * first and last digits of a number are odd (1, 3, 5, 7, 9).\n * For example:\n * >>> specialFilter [15; (~73); 14; (~15)]\n * 1\n * >>> specialFilter [33; (~2); (~3); 45; 21; 109]\n * 2\n*)\nlet specialFilter (nums : int list) : int =\n  let rec loop (nums : int list) (count : int) : int =\n    match nums with\n    | [] -> count\n    | x :: xs ->\n        if x > 10 && (x mod 10) = 1 && (x mod 10) mod 2 = 1 then loop xs (count + 1)\n        else loop xs (count + 1)\n  in loop nums 0\n"], ["(**You are given a positive integer n. You have to create an integer list a of length n.\n * For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n * Example :\n * >>> get_max_triples 5\n * 1\n * Explanation: \n * a = [1, 3, 7, 13, 21]\n * The only valid triple is (1, 7, 13).\n*)\nlet get_max_triples (n : int) : int =\n  let rec get_max_triples_helper n = function\n    | [] -> 0\n    | (a, b, c) :: rest when a * a + b * b + c * c = n ->\n      let d = a * a + b * b + c * c in\n      if d > n then get_max_triples_helper d rest else\n        (a, b, c) :: get_max_triples_helper d rest\n    | _ -> get_max_triples_helper n rest\n  in\n  get_max_triples_helper n [1; 3; 5; 7; 9; 11; 13; 15; 17; 19; 21; 23; 25; 27; 29; 31; 33; 35; 37; 39; 41; 43; 45; 47; 49; 51; 53; 55; 57; 59; 61; 63; 65; 67; 69; 71; 73; 75; 77; 79; 81; 83; 85; 87; 89; 91; 93; 95; 9"], ["(**Write a function that accepts a list of strings as a parameter,\n * deletes the strings that have odd lengths from it,\n * and returns the resulted list with a sorted order,\n * The list is always a list of strings and never a list of numbers,\n * and it may contain duplicates.\n * The order of the list should be ascending by length of each word, and you\n * should return the list sorted by that rule.\n * If two words have the same length, sort the list alphabetically.\n * The function should return a list of strings in sorted order.\n * You may assume that all words will have the same length.\n * For example:\n * >>> list_sort [\"aa\"; \"a\"; \"aaa\"]\n * [\"aa\"]\n * >>> list_sort [\"ab\"; \"a\"; \"aaa\"; \"cd\"]\n * [\"ab\"; \"cd\"]\n*)\nlet sorted_list_sum (lst : string list) : string list =\n  let rec sort_lst lst =\n    match lst with\n    | [] -> []\n    | hd :: tl ->\n        let len = String.length hd in\n        if len > 1 then\n          let sorted_lst = List.sort_uniq (fun x y -> String.length x - String.length y) tl in\n          List.rev (sort_lst sorted_lst)\n        else\n          [hd]\n    | [] -> []\n  in\n  sort_lst lst\n;;"], ["(**A simple program which should return the value of x if n is \n * a prime number and should return the value of y otherwise.\n * Examples:\n * >>> x_or_y 7 34 12\n * 34\n * >>> x_or_y 15 8 5\n * 5\n*)\nlet x_or_y (n : int) (x : int) (y : int) : int =\n  if n = 2 then x\n  else if n mod 2 = 0 then y\n  else x + y"], ["(**Given a list of numbers, return the sum of squares of the numbers\n * in the list that are odd. Ignore numbers that are negative or not integers.\n * >>> double_the_difference [1; 3; 2; 0]\n * 10\n * >>> double_the_difference [(~1); (~2); 0]\n * 0\n * >>> double_the_difference [9; (~2)]\n * 81\n * >>> double_the_difference [0]\n * 0\n * If the input list is empty, return 0.\n*)\nlet double_the_difference (lst : float list) : int =\n  let rec double_the_difference_aux lst =\n    match lst with\n    | [] -> 0\n    | x :: xs -> x + double_the_difference_aux xs\n  in double_the_difference_aux lst\n;;"], ["(**I think we all remember that feeling when the result of some long-awaited\n * event is finally known. The feelings and thoughts you have at that moment are\n * definitely worth noting down and comparing.\n * Your task is to determine if a person correctly guessed the results of a number of matches.\n * You are given two lists of scores and guesses of equal length, where each index shows a match. \n * Return a list of the same length denoting how far off each guess was. If they have guessed correctly,\n * the value is 0, and if not, the value is the absolute difference between the guess and the score.\n * example:\n * >>> compare [1; 2; 3; 4; 5; 1] [1; 2; 3; 4; 2; (~2)]\n * [0; 0; 0; 0; 3; 3]\n * >>> compare [0; 5; 0; 0; 0; 4] [4; 1; 1; 0; 0; (~2)]\n * [4; 4; 1; 0; 0; 6]\n*)\nlet compare (game : int list) (guess : int list) : int list =\n    let rec loop (game, guess) =\n        match game with\n        | [] -> guess\n        | hd :: tl ->\n            if hd = guess then loop tl (hd :: guess)\n            else loop (hd :: tl, guess)\n    in\n    loop game guess\n"], ["(**You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class. The\n * strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters \n * in the extension's name, the strength is given by the fraction CAP - SM. \n * You should find the strongest extension and return a string in this \n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n * (its strength is -1).\n * Example:\n * >>> Strongest_Extension \"my_class\" [\"AA\"; \"Be\"; \"CC\"]\n * \"my_class.AA\"\n*)\nlet Strongest_Extension (class_name : string) (extensions : string list) : string =\n  let rec strongest_extension_helper (class_name : string) (extensions : string list) : string =\n    match extensions with\n    | [] -> class_name\n    | [ext] -> if class_name = ext then class_name else strongest_extension_helper class_name (ext :: extensions)\n    | _ -> if class_name = ext then class_name else strongest_extension_helper class_name (ext :: extensions)\n  in strongest_extension_helper class_name extensions\n;;"], ["(**You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n * >>> cycpattern_check \"abcd\" \"abd\"\n * false\n * >>> cycpattern_check \"hello\" \"ell\"\n * true\n * >>> cycpattern_check \"whassup\" \"psus\"\n * false\n * >>> cycpattern_check \"abab\" \"baa\"\n * true\n * >>> cycpattern_check \"efef\" \"eeff\"\n * false\n * >>> cycpattern_check \"himenss\" \"simen\"\n * true\n*)\nlet cycpattern_check (a : string) (b : string) : bool =\n  let rec check_sub (a : string) (b : string) : bool =\n    match a, b with\n    | \"\", \"\" -> true\n    | a, b ->\n        let (a, b) = (a, b) in\n        a = b || check_sub a b\n  in\n  check_sub a b\n;;"], ["(**Given an integer. return a tuple that has the number of even and odd digits respectively.\n * Example:\n * >>> even_odd_count (~12)\n * (1, 1)\n * >>> even_odd_count 123\n * (1, 2)\n*)\nlet even_odd_count (num : int) :  int * int =\n  let rec even_odd_count_helper (num : int) : int * int =\n    match num with\n    | 0 -> (0, 0)\n    | 1 -> (1, 0)\n    | _ ->\n        let even_num = num mod 2\n        let odd_num = num / 2\n        even_odd_count_helper odd_num\n      |> (even_num, odd_num)\n  in even_odd_count_helper num\n;;"], ["(**Given a positive integer, obtain its roman numeral equivalent as a string,\n * and return it in lowercase.\n * Restrictions: 1 <= num <= 1000\n * Examples:\n * >>> int_to_mini_roman 19\n * \"xix\"\n * >>> int_to_mini_roman 152\n * \"clii\"\n * >>> int_to_mini_roman 426\n * \"cdxxvi\"\n*)\nlet int_to_mini_roman (number : int) : string =\n  let rec loop (n : int) (roman : string) : string =\n    match n with\n    | 0 -> roman\n    | _ ->\n        let (remainder, remainder_roman) =\n          match n with\n          | n when n > 0 ->\n              let (remainder, remainder_roman) =\n                if n mod 100 = 0 then\n                  (n / 100, \"m\")\n                else\n                  (n / 1000, \"cm\")\n              in\n              (remainder, remainder_roman)\n          | n when n > 100 ->\n              let (remainder, remainder_roman) =\n                if n mod 1000 = 0 then\n                  (n / 1000, \"d\")\n                else\n                  (n / 100, \"cd\")\n              in\n              (remainder, remainder_roman)\n          | n when n > 1000 ->\n              let (remainder, remainder_roman) =\n                if n mod 10000 = 0 then\n                  (n / 10000, \"c\")\n                else\n                  (n / 100, \"cc\")\n              in\n              (remainder, remainder_roman)\n          | n when n > 10000 ->\n              let (remainder, remainder_roman) =\n                if n mod 100000 = 0 then\n                  (n / 100000, \"b\")"], ["(**Given the lengths of the three sides of a triangle. Return true if the three\n * sides form a right-angled triangle, false otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or \n * 90 degree.\n * Example:\n * >>> right_angle_triangle 3 4 5\n * true\n * >>> right_angle_triangle 1 2 3\n * false\n*)\nlet right_angle_triangle (a : int) (b : int) (c : int) : bool =\n  let rec triangle_check (a : int) (b : int) (c : int) : bool =\n    match (a, b, c) with\n    | (a, b, c) ->\n        if a = b && b = c then true\n        else if a = c then true\n        else if b = c then true\n        else false\n  in\n  triangle_check a b c\n;;"], ["(**Write a function that accepts a list of strings.\n * The list contains different words. Return the word with maximum number\n * of unique characters. If multiple strings have maximum number of unique\n * characters, return the one which comes first in lexicographical order.\n * >>> find_max [\"name\"; \"of\"; \"string\"]\n * \"string\"\n * >>> find_max [\"name\"; \"enam\"; \"game\"]\n * \"enam\"\n * >>> find_max [\"aaaaaaa\"; \"bb\"; \"cc\"]\n * \"aaaaaaa\"\n*)\nlet find_max (words : string list) : string =\n  let rec find_max_helper (words : string list) (max : string) : string =\n    match words with\n    | [] -> max\n    | _::_ ->\n        let (max_word, max_count) = List.hd words in\n        let max_count = List.hd (List.rev (List.sort (fun (x, _) (y, _) -> x > y) words)) in\n        if max_count > max_word.length then find_max_helper (words @ [max_word]) max_word\n        else max_word\n  in find_max_helper words \"\"\n;;"], ["(**You're a hungry rabbit, and you already have eaten a certain number of carrots,\n * but now you need to eat more carrots to complete the day's meals.\n * you should return a list of [ total number of eaten carrots after your meals,\n * the number of carrots left after your meals ]\n * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n * Example:\n * >>> eat 5 6 10\n * [11; 4]\n * >>> eat 4 8 9\n * [12; 1]\n * >>> eat 1 10 10\n * [11; 0]\n * >>> eat 2 11 5\n * [7; 0]\n * Variables:\n * @number : integer\n * the number of carrots that you have eaten.\n * @need : integer\n * the number of carrots that you need to eat.\n * @remaining : integer\n * the number of remaining carrots thet exist in stock\n * Constrain:\n * * 0 <= number <= 1000\n * * 0 <= need <= 1000\n * * 0 <= remaining <= 1000\n * Have fun :)\n*)\nlet eat (number : int) (need : int) (remaining : int) : int list =\n  if need <= 0 || need > remaining then raise (Invalid_argument \"eat\")\n  else if need == 0 then [0]\n  else if need == remaining then [0]\n  else if need == 1 then [1]\n  else if need == 2 then [2]\n  else if need == 3 then [3]\n  else if need == 4 then [4]\n  else if need == 5 then [5]\n  else if need == 6 then [6]\n  else if need == 7 then [7]\n  else if need == 8 then [8]\n  else if need == 9 then [9]\n  else if need == 10 then [10]\n  else if need == 11 then [1"], ["(**Given two lists operator, and operand. The first list has basic algebra operations, and \n * the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n * Example:\n * operator['+', '*', '-']\n * list = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n*)\nlet do_algebra (operator : string list) (operand : int list) : int =\n  let rec eval_expr (expr : string) : int =\n    match expr with\n    | \"+\" -> (eval_expr (operand @ [expr]) + eval_expr (operand @ [expr]))\n    | \"-\" -> (eval_expr (operand @ [expr]) - eval_expr (operand @ [expr]))\n    | \"*\" -> (eval_expr (operand @ [expr]) * eval_expr (operand @ [expr]))\n    | \"/\" -> (eval_expr (operand @ [expr]) / eval_expr (operand @ [expr]))\n    | \"**\" -> (eval_expr (operand @ [expr]) ** eval_expr (operand @ [expr]))\n    | _ -> failwith (\"Invalid expression: \" ^ expr)\n  in eval_expr (operator @ [operand])"], ["(**You are given a string s.\n * if s[i] is a letter, reverse its case from lower to upper or vise versa, \n * otherwise keep it as it is.\n * If the string contains no letters, reverse the string.\n * The function should return the resulted string.\n * Examples\n * >>> solve \"1234\"\n * \"4321\"\n * >>> solve \"ab\"\n * \"AB\"\n * >>> solve \"#a@C\"\n * \"#A@c\"\n*)\nlet solve (s : string) : string =\n  let rec reverse_string (s : string) : string =\n    match s with\n    | \"\" -> \"\"\n    | x :: xs -> x ^ reverse_string xs\n  in\n  reverse_string s\n;;"], ["(**Given a string 'text', return its md5 hash equivalent string.\n * If 'text' is an empty string, return None.\n * >>> string_to_md5 \"Hello world\"\n * Some(\"3e25960a79dbc69b674cd4ec67a72c62\")\n*)\nlet string_to_md5 (text : string) : string option =\n  let md5 = MD5.compute_md5 text in\n  Some (string_of_int md5)\n;;"], ["(**Given two positive integers a and b, return the even digits between a\n * and b, in ascending order.\n * For example:\n * >>> generate_integers 2 8\n * [2; 4; 6; 8]\n * >>> generate_integers 8 2\n * [2; 4; 6; 8]\n * >>> generate_integers 10 14\n * []\n*)\nlet generate_integers (a : int) (b : int) : int list =\n  let rec aux a b =\n    if a > b then []\n    else if a == b then [a]\n    else if a < b then aux a (b - 1)\n    else aux a (b + 1)\n  in aux a b\n;;"]]