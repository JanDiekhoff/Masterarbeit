[["(**Check if in given list of numbers, are any two numbers closer to each other than\n * given threshold.\n * >>> has_close_elements [1.0; 2.0; 3.0] 0.5\n * false\n * >>> has_close_elements [1.0; 2.8; 3.0; 4.0; 5.0; 2.0] 0.3\n * true\n*)\nlet has_close_elements (numbers : float list) (threshold : float) : bool =\n  numbers.length > threshold"], ["(**Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n * separate those group into separate strings and return the list of those.\n * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n * Ignore any spaces in the input string.\n * >>> separate_paren_groups \"( ) (( )) (( )( ))\"\n * [\"()\"; \"(())\"; \"(()())\"]\n*)\nlet separate_paren_groups (paren_string : string) : string list =\n  let rec parse_paren_string (paren_string_list : string list) =\n    match paren_string_list with\n    | [] -> []\n    | _ ->\n      let rec parse_paren_string_list (paren_string_list_list : string list) =\n        match paren_string_list_list with\n        | [] -> []\n        | _ ->\n          let rec parse_paren_string_list_list (paren_string_list_list_list : string list) =\n            match paren_string_list_list_list with\n            | [] -> []\n            | _ ->\n              let rec parse_paren_string_list_list_list (paren_string_list_list_list_list : string list) =\n                match paren_string_list_list_list_list with\n                | [] -> []\n                | _ ->\n                  let rec parse_paren_string_list_list_list_list (paren_string_list_list_list_list_list : string list) =\n                    match paren_string_list_list_list_list_list with\n                    | [] -> []\n                    | _ ->\n                      let rec parse_paren_string_list_list_list_list_list (paren_string_list_list_list_list_list_list : string list) =\n                        match paren_string_list_list_list_list_list_list with\n                        | [] -> []\n                        | _ ->\n                          let rec parse_paren_string_list_list_list_list_list_list (paren_string_list_list"], ["(**Given a positive floating point number, it can be decomposed into\n * and integer part (largest integer smaller than given number) and decimals\n * (leftover part always smaller than 1).\n * Return the decimal part of the number.\n * >>> truncate_number 3.5\n * 0.5\n*)\nlet truncate_number (number : float) : float =\n  if number < 0.0 then\n    -number\n  else\n    number"], ["(**You're given a list of deposit and withdrawal operations on a bank account that starts with\n * zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n * at that point function should return true. Otherwise it should return false.\n * >>> below_zero [1; 2; 3]\n * false\n * >>> below_zero [1; 2; (~4); 5]\n * true\n*)\nlet below_zero (operations : int list) : bool =\n    operations.length === 0\n    && (operations.length === 1 && operations[0] === 0)\n    && (operations.length === 2 && operations[0] === 0 && operations[1] === 0)\n    && (operations.length === 3 && operations[0] === 0 && operations[1] === 0 && operations[2] === 0)\n    && (operations.length === 4 && operations[0] === 0 && operations[1] === 0 && operations[2] === 0 && operations[3] === 0)\n    && (operations.length === 5 && operations[0] === 0 && operations[1] === 0 && operations[2] === 0 && operations[3] === 0 && operations[4] === 0)\n    && (operations.length === 6 && operations[0] === 0 && operations[1] === 0 && operations[2] === 0 && operations[3] === 0 && operations[4] === 0 && operations[5] === 0)\n    && (operations.length === 7 && operations[0] === 0 && operations[1] === 0 && operations[2] === 0 && operations[3] === 0 && operations[4] === 0 && operations[5] === 0 && operations[6] === 0)\n    && (operations.length === 8 && operations[0] === 0 && operations[1] === 0 && operations[2] === 0 && operations[3] === 0 && operations[4] === 0 && operations[5] === 0 && operations[6] === 0 && operations[7] === 0)\n"], ["(**For a given list of input numbers, calculate Mean Absolute Deviation\n * around the mean of this dataset.\n * Mean Absolute Deviation is the average absolute difference between each\n * element and a centerpoint (mean in this case):\n * MAD = average | x - x_mean |\n * >>> mean_absolute_deviation [1.0; 2.0; 3.0; 4.0]\n * 1.0\n*)\nlet mean_absolute_deviation (numbers : float list) : float =\n  numbers.map (n => n - n.mean)"], ["(**Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n * >>> intersperse [] 4\n * []\n * >>> intersperse [1; 2; 3] 4\n * [1; 4; 2; 4; 3]\n*)\nlet intersperse (numbers : int list) (delimeter : int) : int list =\n    numbers.map (x => x + delimeter)"], ["(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n * For each of the group, output the deepest level of nesting of parentheses.\n * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n * >>> parse_nested_parens \"(()()) ((())) () ((())()())\"\n * [2; 3; 1; 3]\n*)\nlet parse_nested_parens (paren_string : string) : int list =\n  let rec parse_nested_parens_rec (paren_list : list list) =\n    match paren_string with\n    | \"(\" -> parse_nested_parens_rec paren_list\n    | \") -> parse_nested_parens_rec paren_list\n    | _ -> parse_nested_parens_rec (paren_list : paren_list)\n  in\n  parse_nested_parens_rec paren_list"], ["(**Filter an input list of strings only for ones that contain given substring\n * >>> filter_by_substring [] \"a\"\n * []\n * >>> filter_by_substring [\"abc\"; \"bacd\"; \"cde\"; \"array\"] \"a\"\n * [\"abc\"; \"bacd\"; \"array\"]\n*)\nlet filter_by_substring (strings : string list) (substring : string) : string list =\n    if (strings.length > 0)\n        strings\n    else\n        [substring]"], ["(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n * >>> sum_product []\n * (0, 1)\n * >>> sum_product [1; 2; 3; 4]\n * (10, 24)\n*)\nlet sum_product (numbers : int list) :  int * int =\n  let rec sum_product_rec (numbers : int list) =\n    match numbers with\n      | [] -> []\n      | _ -> sum_product_rec (numbers ++ [numbers])\n  in sum_product_rec []"], ["(**From a given list of integers, generate a list of rolling maximum element found until given moment\n * in the sequence.\n * >>> rolling_max [1; 2; 3; 2; 3; 4; 2]\n * [1; 2; 3; 3; 3; 4; 4]\n*)\nlet rolling_max (numbers : int list) : int list =\n  numbers.map (n => n + 1)"], ["(**Find the shortest palindrome that begins with a supplied string.\n * Algorithm idea is simple:\n * - Find the longest postfix of supplied string that is a palindrome.\n * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n * >>> make_palindrome \"\"\n * \"\"\n * >>> make_palindrome \"cat\"\n * \"catac\"\n * >>> make_palindrome \"cata\"\n * \"catac\"\n*)\nlet make_palindrome (string : string) : string =\n  let prefix = string\n  in\n  let suffix = string\n  in\n  if string = \"\" then\n    \"\"\n  else\n    if string = prefix then\n      string\n    else\n      string\n      + \" \"\n      + make_palindrome (string : string)\n      + \" \"\n      + suffix\n  end"], ["(**Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return result also as a string.\n * >>> string_xor \"010\" \"110\"\n * \"100\"\n*)\nlet string_xor (a : string) (b : string) : string =\n  a ^ b"], ["(**Out of list of strings, return the longest one. Return the first one in case of multiple\n * strings of the same length. Return None in case the input list is empty.\n * >>> longest []\n * Some(None)\n * >>> longest [\"a\"; \"b\"; \"c\"]\n * Some(\"a\")\n * >>> longest [\"a\"; \"bb\"; \"ccc\"]\n * Some(\"ccc\")\n*)\nlet longest (strings : string list) : string option =\n  if (strings.length > 0)\n    if (strings.head.length > 0)\n      longest (strings.head)\n    else\n      None"], ["(**Return a greatest common divisor of two integers a and b\n * >>> greatest_common_divisor 3 5\n * 1\n * >>> greatest_common_divisor 25 15\n * 5\n*)\nlet greatest_common_divisor (a : int) (b : int) : int =\n  if a > b then a else b"], ["(**Return list of all prefixes from shortest to longest of the input string\n * >>> all_prefixes \"abc\"\n * [\"a\"; \"ab\"; \"abc\"]\n*)\nlet all_prefixes (string : string) : string list =\n  string.split ().map (_.toString)"], ["(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n * >>> string_sequence 0\n * \"0\"\n * >>> string_sequence 5\n * \"0 1 2 3 4 5\"\n*)\nlet string_sequence (n : int) : string =\n  let rec string_sequence_loop (n : int) =\n    match n with\n    | 0 -> \"0\"\n    | _ -> string_sequence_loop (n - 1)\n  in string_sequence_loop n"], ["(**Given a string, find out how many distinct characters (regardless of case) does it consist of\n * >>> count_distinct_characters \"xyzXYZ\"\n * 3\n * >>> count_distinct_characters \"Jerry\"\n * 4\n*)\nlet count_distinct_characters (string : string) : int =\n  let rec count_distinct_characters_rec (characters : string) (count : int) =\n    match characters with\n    | \"\" -> count\n    | _ -> count_distinct_characters_rec (characters ++ \" \") count\n  in\n  count_distinct_characters_rec (string) 0"], ["(**Input to this function is a string representing musical notes in a special ASCII format.\n * Your task is to parse this string and return list of integers corresponding to how many beats does each\n * not last.\n * Here is a legend:\n * 'o' - whole note, lasts four beats\n * 'o|' - half note, lasts two beats\n * '.|' - quater note, lasts one beat\n * >>> parse_music \"o o| .| o| o| .| .| .| .| o o\"\n * [4; 2; 1; 2; 2; 1; 1; 1; 1; 4; 4]\n*)\nlet parse_music (music_string : string) : int list =\n  let rec parse_music_list (music_list : int list) =\n    match music_string with\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \"o o| .| .| .| .| .| .| .| o o\" -> music_list\n    | \""], ["(**Find how many times a given substring can be found in the original string. Count overlaping cases.\n * >>> how_many_times \"\" \"a\"\n * 0\n * >>> how_many_times \"aaa\" \"a\"\n * 3\n * >>> how_many_times \"aaaa\" \"aa\"\n * 3\n*)\nlet how_many_times (string : string) (substring : string) : int =\n  if string = \"\" then 0\n  else if substring = \"\" then 0\n  else how_many_times string substring"], ["(**Input is a space-delimited string of numberals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n * Return the string with numbers sorted from smallest to largest\n * >>> sort_numbers \"three one five\"\n * \"one three five\"\n*)\nlet sort_numbers (numbers : string) : string =\n  numbers.split('').sort().reverse().map(number => number.toInt).join('')"], ["(**From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n * other and return them in order (smaller number, larger number).\n * >>> find_closest_elements [1.0; 2.0; 3.0; 4.0; 5.0; 2.2]\n * (2.0, 2.2)\n * >>> find_closest_elements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0]\n * (2.0, 2.0)\n*)\nlet find_closest_elements (numbers : float list) :  float * float =\n    let rec find_closest_elements_rec (numbers : float list) : float * float =\n        let rec find_closest_elements_rec_rec (numbers : float list) : float * float =\n            let rec find_closest_elements_rec_rec_rec (numbers : float list) : float * float =\n                let rec find_closest_elements_rec_rec_rec_rec (numbers : float list) : float * float =\n                    let rec find_closest_elements_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                        let rec find_closest_elements_rec_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                            let rec find_closest_elements_rec_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                                let rec find_closest_elements_rec_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                                    let rec find_closest_elements_rec_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                                        let rec find_closest_elements_rec_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                                            let rec find_closest_elements_rec_rec_rec_rec_rec_rec (numbers : float list) : float * float =\n                                               "], ["(**Given list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1\n * >>> rescale_to_unit [1.0; 2.0; 3.0; 4.0; 5.0]\n * [0.0; 0.25; 0.5; 0.75; 1.0]\n*)\nlet rescale_to_unit (numbers : float list) : float list =\n  numbers.map (n => n / 100.0)"], ["(**Return length of given string\n * >>> strlen \"\"\n * 0\n * >>> strlen \"abc\"\n * 3\n*)\nlet strlen (string : string) : int =\n    if string == \"\" then 0\n    else strlen string"], ["(**For a given number n, find the largest number that divides n evenly, smaller than n\n * >>> largest_divisor 15\n * 5\n*)\nlet largest_divisor (n : int) : int =\n    if n < 1 then 1 else\n        if n % 2 == 0 then\n            n\n        else\n            n + largest_divisor (n / 2)\n)"], ["(**Return list of prime factors of given integer in the order from smallest to largest.\n * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n * Input number should be equal to the product of all factors\n * >>> factorize 8\n * [2; 2; 2]\n * >>> factorize 25\n * [5; 5]\n * >>> factorize 70\n * [2; 5; 7]\n*)\nlet factorize (n : int) : int list =\n    let rec factorize_list (n : int list) =\n        match n with\n        | [] -> []\n        | h :: t ->\n            let rec factorize_list_rec (n : int list) =\n                match n with\n                | [] -> []\n                | h :: t ->\n                    factorize_list_rec (n :: t)\n            in\n            factorize_list_rec (h :: t)\n    in\n    factorize_list (n)"], ["(**From a list of integers, remove all elements that occur more than once.\n * Keep order of elements left the same as in the input.\n * >>> remove_duplicates [1; 2; 3; 2; 4]\n * [1; 3; 4]\n*)\nlet remove_duplicates (numbers : int list) : int list =\n  numbers.map (x => x.toInt)\n    .filter (x => numbers.indexOf (x) === -1)\n    .map (x => x.toInt)\n    .sort ()\n    .reverse ()"], ["(**For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * >>> flip_case \"Hello\"\n * \"hELLO\"\n*)\nlet flip_case (string : string) : string =\n  string\n  |> String.replace (String.concat (String.concat (string, \" \"), \" \"))\n  |> String.concat (String.concat (string, \" \"), \" \")"], ["(**Concatenate list of strings into a single string\n * >>> concatenate []\n * \"\"\n * >>> concatenate [\"a\"; \"b\"; \"c\"]\n * \"abc\"\n*)\nlet concatenate (strings : string list) : string =\n  strings.map (s => s.concat ())"], ["(**Filter an input list of strings only for ones that start with a given prefix.\n * >>> filter_by_prefix [] \"a\"\n * []\n * >>> filter_by_prefix [\"abc\"; \"bcd\"; \"cde\"; \"array\"] \"a\"\n * [\"abc\"; \"array\"]\n*)\nlet filter_by_prefix (strings : string list) (prefix : string) : string list =\n  if (strings.length > 0)\n    strings.head\n  else\n    prefix"], ["(**Return only positive numbers in the list.\n * >>> get_positive [(~1); 2; (~4); 5; 6]\n * [2; 5; 6]\n * >>> get_positive [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]\n * [5; 3; 2; 3; 9; 123; 1]\n*)\nlet get_positive (l : int list) : int list =\n  let rec get_positive_rec (l : int list) =\n    match l with\n      [] -> []\n      (x : int) ->\n        let rec get_positive_rec_rec (l : int list) =\n          match l with\n            [] -> []\n            (x : int) ->\n              let rec get_positive_rec_rec_rec_rec (l : int list) =\n                match l with\n                  [] -> []\n                  (x : int) ->\n                    let rec get_positive_rec_rec_rec_rec_rec_rec (l : int list) =\n                      match l with\n                        [] -> []\n                        (x : int) ->\n                          let rec get_positive_rec_rec_rec_rec_rec_rec_rec_rec (l : int list) =\n                            match l with\n                              [] -> []\n                              (x : int) ->\n                                let rec get_positive_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec (l : int list) =\n                                  match l with\n                                    [] -> []\n                                    (x : int) ->\n                                      let rec get_positive_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_rec_"], ["(**Return true if a given number is prime, and false otherwise.\n * >>> is_prime 6\n * false\n * >>> is_prime 101\n * true\n * >>> is_prime 11\n * true\n * >>> is_prime 13441\n * true\n * >>> is_prime 61\n * true\n * >>> is_prime 4\n * false\n * >>> is_prime 1\n * false\n*)\nlet is_prime (n : int) : bool =\n  n >= 2 && n <= 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"], ["(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n * to the values of the corresponding indicies of l, but sorted.\n * >>> sort_third [1; 2; 3]\n * [1; 2; 3]\n * >>> sort_third [5; 6; 3; 4; 8; 9; 2]\n * [2; 6; 3; 4; 8; 9; 5]\n*)\nlet sort_third (l : int list) : int list =\n    let rec sort_third_rec (l : int list) (i : int) =\n        match l with\n        | [] -> []\n        | h :: t ->\n            if i < h.length then\n                sort_third_rec (h.slice i h.length) (i + 1)\n            else\n                sort_third_rec (h.slice i h.length) (i + 1)\n            | h :: t' ->\n                sort_third_rec (h.slice i h.length) (i + 1)\n            | _ -> []\n    in sort_third_rec (l) (0)"], ["(**Return sorted unique elements in a list\n * >>> unique [5; 3; 5; 2; 3; 3; 9; 0; 123]\n * [0; 2; 3; 5; 9; 123]\n*)\nlet unique (l : int list) : int list =\n    l.map(x => x.toInt()).toArray();"], ["(**Return maximum element in the list.\n * >>> max_element [1; 2; 3]\n * 3\n * >>> max_element [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]\n * 123\n*)\nlet max_element (l : int list) : int =\n  if l.length > 0 then\n    l.head\n  else\n    max_element (l.tail)"], ["(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n * >>> fizz_buzz 50\n * 0\n * >>> fizz_buzz 78\n * 2\n * >>> fizz_buzz 79\n * 3\n*)\nlet fizz_buzz (n : int) : int =\n  if n < 10 then\n    n\n  else\n    fizz_buzz (n - 1) +\n    fizz_buzz (n - 2) +\n    fizz_buzz (n - 3) +\n    fizz_buzz (n - 4) +\n    fizz_buzz (n - 5) +\n    fizz_buzz (n - 6) +\n    fizz_buzz (n - 7) +\n    fizz_buzz (n - 8) +\n    fizz_buzz (n - 9)\n  end"], ["(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n * to the values of the even indicies of l, but sorted.\n * >>> sort_even [1; 2; 3]\n * [1; 2; 3]\n * >>> sort_even [5; 6; 3; 4]\n * [3; 6; 5; 4]\n*)\nlet sort_even (l : int list) : int list =\n  let rec sort_even_rec (l : int list) =\n    match l with\n    | [] -> []\n    | x::xs -> sort_even_rec (x::xs)\n  in\n  sort_even_rec (l)"], ["(**prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n * >>> prime_fib 1\n * 2\n * >>> prime_fib 2\n * 3\n * >>> prime_fib 3\n * 5\n * >>> prime_fib 4\n * 13\n * >>> prime_fib 5\n * 89\n*)\nlet prime_fib (n : int) : int =\n  if n < 2 then 2\n  else if n < 3 then 3\n  else if n < 5 then 5\n  else if n < 7 then 7\n  else if n < 10 then 10\n  else if n < 12 then 12\n  else if n < 15 then 15\n  else if n < 18 then 18\n  else if n < 21 then 21\n  else if n < 24 then 24\n  else if n < 27 then 27\n  else if n < 30 then 30\n  else if n < 33 then 33\n  else if n < 36 then 36\n  else if n < 39 then 39\n  else if n < 42 then 42\n  else if n < 45 then 45\n  else if n < 48 then 48\n  else if n < 51 then 51\n  else if n < 54 then 54\n  else if n < 57 then 57\n  else if n < 60 then 60\n  else if n < 63 then 63\n  else if n < 66 then 66\n  else if n < 69 then 69\n  else if n < 72 then 72\n  else if n < 75 then 75\n  else if n < 78 then 78\n  else if n < 81 then 81\n  else if n < 84 then 84\n  else if n < 88 then 88\n  else if n < 91"], ["(**triples_sum_to_zero takes a list of integers as an input.\n * it returns true if there are three distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> triples_sum_to_zero [1; 3; 5; 0]\n * false\n * >>> triples_sum_to_zero [1; 3; (~2); 1]\n * true\n * >>> triples_sum_to_zero [1; 2; 3; 7]\n * false\n * >>> triples_sum_to_zero [2; 4; (~5); 3; 9; 7]\n * true\n * >>> triples_sum_to_zero [1]\n * false\n*)\nlet triples_sum_to_zero (l : int list) : bool =\n  let rec sum_to_zero = (fun x y z -> x + y + z) in\n  sum_to_zero (l)"], ["(**Imagine a road that's a perfectly straight infinitely long line.\n * n cars are driving left to right;  simultaneously, a different set of n cars\n * are driving right to left.   The two sets of cars start out being very far from\n * each other.  All cars move in the same speed.  Two cars are said to collide\n * when a car that's moving left to right hits a car that's moving right to left.\n * However, the cars are infinitely sturdy and strong; as a result, they continue moving\n * in their trajectory as if they did not collide.\n * This function outputs the number of such collisions.\n*)\nlet car_race_collision (n : int) : int =\n  let collision_count = 0 in\n  for i in 1 .. n do\n    for j in 1 .. n do\n      if (i < j) then\n        collision_count = collision_count + 1\n      end if\n    end for\n  end for\n  collision_count"], ["(**Return list with elements incremented by 1.\n * >>> incr_list [1; 2; 3]\n * [2; 3; 4]\n * >>> incr_list [5; 3; 5; 2; 3; 3; 9; 0; 123]\n * [6; 4; 6; 3; 4; 4; 10; 1; 124]\n*)\nlet incr_list (l : int list) : int list =\n  let rec incr_list_rec (l : int list) acc =\n    match l with\n    | [] -> acc\n    | h::tl -> incr_list_rec (h::tl) acc\n  in\n  incr_list_rec (l = [])"], ["(**pairs_sum_to_zero takes a list of integers as an input.\n * it returns true if there are two distinct elements in the list that\n * sum to zero, and false otherwise.\n * >>> pairs_sum_to_zero [1; 3; 5; 0]\n * false\n * >>> pairs_sum_to_zero [1; 3; (~2); 1]\n * false\n * >>> pairs_sum_to_zero [1; 2; 3; 7]\n * false\n * >>> pairs_sum_to_zero [2; 4; (~5); 3; 5; 7]\n * true\n * >>> pairs_sum_to_zero [1]\n * false\n*)\nlet pairs_sum_to_zero (l : int list) : bool =\n  l.length == 2 &&\n  (l.length == 0 ||\n    (l.length == 1 &&\n      (~l.head.sumToZero ||\n        (~l.head.sumToZero && l.head.sumToZero)))\n  )"], ["(**Change numerical base of input number x to base.\n * return string representation after the conversion.\n * base numbers are less than 10.\n * >>> change_base 8 3\n * \"22\"\n * >>> change_base 8 2\n * \"1000\"\n * >>> change_base 7 2\n * \"111\"\n*)\nlet change_base (x : int) (base : int) : string =\n  if (x < 10)\n    \"0\" + change_base (x - 10) (base)\n  else\n    \"1000\" + change_base (x - 10) (base)"], ["(**Given length of a side and high return area for a triangle.\n * >>> triangle_area 5 3\n * 7.5\n*)\nlet triangle_area (a : int) (h : int) : float =\n  a * a * a"], ["(**The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n * >>> fib4 5\n * 4\n * >>> fib4 6\n * 8\n * >>> fib4 7\n * 14\n*)\nlet fib4 (n : int) : int =\n    if n < 0 then 0 else\n        fib4 (n - 1) + fib4 (n - 2) + fib4 (n - 3) + fib4 (n - 4)"], ["(**Return median of elements in the list l.\n * >>> median [3; 1; 2; 4; 5]\n * 3.0\n * >>> median [(~10); 4; 6; 1000; 10; 20]\n * 15.0\n*)\nlet median (l : int list) : float = {\n  if (l.length < 2) {\n    return 0.0\n  }\n  let median_of_two = median (l.slice (1, l.length))\n  return median_of_two + median (l.slice (l.length - 1, l.length))\n}"], ["(**Checks if given string is a palindrome\n * >>> is_palindrome \"\"\n * true\n * >>> is_palindrome \"aba\"\n * true\n * >>> is_palindrome \"aaaaa\"\n * true\n * >>> is_palindrome \"zbcd\"\n * false\n*)\nlet is_palindrome (text : string) : bool =\n  let\n    is_palindrome_1 (text : string) =\n      text == text\n    is_palindrome_2 (text : string) =\n      text == \"\"\n  in\n  is_palindrome_1 text\n  is_palindrome_2 text"], ["(**Return 2^n modulo p (be aware of numerics).\n * >>> modp 3 5\n * 3\n * >>> modp 1101 101\n * 2\n * >>> modp 0 101\n * 1\n * >>> modp 3 11\n * 8\n * >>> modp 100 101\n * 1\n*)\nlet modp (n : int) (p : int) : int =\n  if n < 0 || n > 1101 || p < 0 || p > 101\n  then 0\n  else if p < 0 || p > 101\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n  then 0\n  else if n < 0 || n > 1000000000\n"], ["(**remove_vowels is a function that takes string and returns string without vowels.\n * >>> remove_vowels \"\"\n * \"\"\n * >>> remove_vowels \"abcdef\"\n * \"bcdf\"\n * >>> remove_vowels \"aaaaa\"\n * \"\"\n * >>> remove_vowels \"aaBAA\"\n * \"B\"\n * >>> remove_vowels \"zbcd\"\n * \"zbcd\"\n*)\nlet remove_vowels (text : string) : string =\n  text.replaceAll (\"\\\\p{Vowel}\",\"\")"], ["(**Return true if all numbers in the list l are below threshold t.\n * >>> below_threshold [1; 2; 4; 10] 100\n * true\n * >>> below_threshold [1; 20; 4; 10] 5\n * false\n*)\nlet below_threshold (l : int list) (t : int) : bool =\n  l.length == 0\n  && t >= l.head.value\n  && t <= l.tail.value\n  && l.head.value <= t\n  && l.tail.value >= t"], ["(**Add two numbers x and y\n * >>> add 2 3\n * 5\n * >>> add 5 7\n * 12\n*)\nlet add (x : int) (y : int) : int =\n  x + y"], ["(**Check if two words have the same characters.\n * >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n * true\n * >>> same_chars \"abcd\" \"dddddddabc\"\n * true\n * >>> same_chars \"dddddddabc\" \"abcd\"\n * true\n * >>> same_chars \"eabcd\" \"dddddddabc\"\n * false\n * >>> same_chars \"abcd\" \"dddddddabce\"\n * false\n * >>> same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n * false\n*)\nlet same_chars (s0 : string) (s1 : string) : bool =\n  s0 == s1"], ["(**Return n-th Fibonacci number.\n * >>> fib 10\n * 55\n * >>> fib 1\n * 1\n * >>> fib 8\n * 21\n*)\nlet fib (n : int) : int =\n    if (n <= 0)\n        return 0\n    else\n        return fib (n - 1) + fib (n - 2)"], ["(**brackets is a string of \"<\" and \">\".\n * return true if every opening bracket has a corresponding closing bracket.\n * >>> correct_bracketing \"<\"\n * false\n * >>> correct_bracketing \"<>\"\n * true\n * >>> correct_bracketing \"<<><>>\"\n * true\n * >>> correct_bracketing \"><<>\"\n * false\n*)\nlet correct_bracketing (brackets : string) : bool =\n  brackets.length == brackets.length\n  && brackets.every (\n    (bracket : string) =>\n      bracket.length == brackets.length\n      && bracket.every (\n        (opening : string) =>\n          opening.length == brackets.length\n          && opening.every (\n            (closing : string) =>\n              closing.length == brackets.length\n              && closing.every (\n                (closing_bracket : string) =>\n                  closing_bracket.length == brackets.length\n                  && closing_bracket.every (\n                    (closing_bracket_bracket : string) =>\n                      closing_bracket_bracket.length == brackets.length\n                      && closing_bracket_bracket.every (\n                        (closing_bracket_bracket_bracket : string) =>\n                          closing_bracket_bracket_bracket.length == brackets.length\n                          && closing_bracket_bracket_bracket.every (\n                            (closing_bracket_bracket_bracket_bracket : string) =>\n                              closing_bracket_bracket_bracket_bracket.length == brackets.length\n                              && closing_bracket_bracket_bracket_bracket.every (\n                                (closing_bracket_bracket_bracket_bracket_bracket : string) =>\n                                  closing_bracket_bracket_bracket_bracket_bracket.length == brackets.length\n                                  && closing_bracket_bracket_bracket_bracket_bracket_bracket.every (\n                                    (closing_bracket_bracket_bracket_bracket_bracket_bracket : string) =>\n                                      closing_"], ["(**Return true is list elements are monotonically increasing or decreasing.\n * >>> monotonic [1; 2; 4; 20]\n * true\n * >>> monotonic [1; 20; 4; 10]\n * false\n * >>> monotonic [4; 1; 0; (~10)]\n * true\n*)\nlet monotonic (l : int list) : bool =\n  l.length == 0\n  || (l.length > 1 && l.head.length == 0)\n  || (l.length == 1 && l.head.length == 1)\n  || (l.length == 2 && l.head.length == 2)\n  || (l.length == 3 && l.head.length == 3)\n  || (l.length == 4 && l.head.length == 4)\n  || (l.length == 5 && l.head.length == 5)\n  || (l.length == 6 && l.head.length == 6)\n  || (l.length == 7 && l.head.length == 7)\n  || (l.length == 8 && l.head.length == 8)\n  || (l.length == 9 && l.head.length == 9)\n  || (l.length == 10 && l.head.length == 10)\n  || (l.length == 11 && l.head.length == 11)\n  || (l.length == 12 && l.head.length == 12)\n  || (l.length == 13 && l.head.length == 13)\n  || (l.length == 14 && l.head.length == 14)\n  || (l.length == 15 && l.head.length == 15)\n  || (l.length == 16 && l.head.length == 16)\n  || (l.length == 17 && l.head.length == 17)\n  || (l.length == 18 && l.head.length == 18)\n  || (l.length == 1"], ["(**Return sorted unique common elements for two lists.\n * >>> common [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]\n * [1; 5; 653]\n * >>> common [5; 3; 2; 8] [3; 2]\n * [2; 3]\n*)\nlet common (l1 : int list) (l2 : int list) : int list =\n  if (l1.length < l2.length)\n    throw new Error (\"common: list lengths must be equal\")\n  let i = 0\n  while (i < l1.length)\n    let j = i + 1\n    while (j < l2.length)\n      if (l1[i] < l2[j])\n        throw new Error (\"common: list elements must be sorted\")\n      if (l2[j] < l1[i])\n        throw new Error (\"common: list elements must be sorted\")\n      i = j\n    let k = i + 1\n    while (k < l1.length)\n      if (l1[k] < l2[j])\n        throw new Error (\"common: list elements must be sorted\")\n      if (l2[j] < l1[k])\n        throw new Error (\"common: list elements must be sorted\")\n      k = j\n    let l = l1.length\n    while (l--)\n      if (l1[l] < l2[k])\n        throw new Error (\"common: list elements must be sorted\")\n      if (l2[k] < l1[l])\n        throw new Error (\"common: list elements must be sorted\")\n      l = l1.length\n    let m = l1.length\n    while (m--)\n      if (l1[m] < l2[k])\n        throw new Error (\"common: list elements must be sorted\")\n      if (l2[k] < l1[m])\n        throw new Error (\"common: list elements must be sorted\")\n      m = l2.length\n    let n = m"], ["(**Return the largest prime factor of n. Assume n > 1 and is not a prime.\n * >>> largest_prime_factor 13195\n * 29\n * >>> largest_prime_factor 2048\n * 2\n*)\nlet largest_prime_factor (n : int) : int =\n  if n > 1 then\n    n\n  else\n    if n % 2 = 0 then\n      n\n    else\n      if n % 3 = 0 then\n        n\n      else\n        if n % 5 = 0 then\n          n\n        else\n          if n % 7 = 0 then\n            n\n          else\n            if n % 11 = 0 then\n              n\n            else\n              if n % 13 = 0 then\n                n\n              else\n                if n % 17 = 0 then\n                  n\n                else\n                  if n % 19 = 0 then\n                    n\n                  else\n                    if n % 23 = 0 then\n                      n\n                    else\n                      if n % 29 = 0 then\n                        n\n                      else\n                        if n % 31 = 0 then\n                          n\n                        else\n                          if n % 37 = 0 then\n                            n\n                          else\n                            if n % 43 = 0 then\n                              n\n                            else\n                              if n % 49 = 0 then\n                                n\n                              else\n                                if n % 55 = 0 then\n                                  n\n                                else\n                                  if n % 61 = 0 then\n                                    n\n                                  else\n                                    if n % 67 = 0 then\n                                      n\n                                    else\n                                      if n % 73 = 0 then\n                                        n\n                                      else\n                                        if n % 79 = 0 then\n                                          n\n                                        else\n                                          if n % 85 = 0 then\n                                            n\n                                          else\n                                            if n % 91 = "], ["(**sum_to_n is a function that sums numbers from 1 to n.\n * >>> sum_to_n 30\n * 465\n * >>> sum_to_n 100\n * 5050\n * >>> sum_to_n 5\n * 15\n * >>> sum_to_n 10\n * 55\n * >>> sum_to_n 1\n * 1\n*)\nlet sum_to_n (n : int) : int =\n  if n < 0\n  then 0\n  else if n == 0\n  then 0\n  else if n == 1\n  then 1\n  else if n == 2\n  then 2\n  else if n == 3\n  then 3\n  else if n == 4\n  then 4\n  else if n == 5\n  then 5\n  else if n == 6\n  then 6\n  else if n == 7\n  then 7\n  else if n == 8\n  then 8\n  else if n == 9\n  then 9\n  else if n == 10\n  then 10\n  else if n == 11\n  then 11\n  else if n == 12\n  then 12\n  else if n == 13\n  then 13\n  else if n == 14\n  then 14\n  else if n == 15\n  then 15\n  else if n == 16\n  then 16\n  else if n == 17\n  then 17\n  else if n == 18\n  then 18\n  else if n == 19\n  then 19\n  else if n == 20\n  then 20\n  else if n == 21\n  then 21\n  else if n == 22\n  then 22\n  else if n == 23\n  then 23\n  else if n == 24\n  then 24\n  else if n == 25\n  then 25\n  else if n == 26\n  then "], ["(**brackets is a string of \"(\" and \")\".\n * return true if every opening bracket has a corresponding closing bracket.\n * >>> correct_bracketing \"(\"\n * false\n * >>> correct_bracketing \"()\"\n * true\n * >>> correct_bracketing \"(()())\"\n * true\n * >>> correct_bracketing \")(()\"\n * false\n*)\nlet correct_bracketing (brackets : string) : bool =\n  brackets.length == brackets.length"], ["(**xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * Return derivative of this polynomial in the same form.\n * >>> derivative [3; 1; 2; 4; 5]\n * [1; 4; 12; 20]\n * >>> derivative [1; 2; 3]\n * [2; 6]\n*)\nlet derivative (xs : int list) : int list =\n  let rec derivative_list (xs : int list) =\n    let rec derivative_list_list (xs : int list) =\n      let rec derivative_list_list_list (xs : int list) =\n        let rec derivative_list_list_list_list (xs : int list) =\n          let rec derivative_list_list_list_list_list (xs : int list) =\n            let rec derivative_list_list_list_list_list_list (xs : int list) =\n              let rec derivative_list_list_list_list_list_list_list (xs : int list) =\n                let rec derivative_list_list_list_list_list_list_list_list (xs : int list) =\n                  let rec derivative_list_list_list_list_list_list_list_list (xs : int list) =\n                    let rec derivative_list_list_list_list_list_list_list_list_list (xs : int list) =\n                      let rec derivative_list_list_list_list_list_list_list_list_list_list (xs : int list) =\n                        let rec derivative_list_list_list_list_list_list_list_list_list_list (xs : int list) =\n                          let rec derivative_list_list_list_list_list_list_list_list_list_list_list (xs : int list) =\n                            let rec derivative_list_list_list_list_list_list_list_list_list_list_list_list (xs : int list) =\n                              let rec derivative_list_list_list_list_list_list_list_list_list_list_list_list"], ["(**The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n * >>> fibfib 1\n * 0\n * >>> fibfib 5\n * 4\n * >>> fibfib 8\n * 24\n*)\nlet fibfib (n : int) : int =\n    if n < 0 then 0 else\n        if n == 0 then 0 else\n            if n % 2 == 0 then\n                fibfib (n - 1) + fibfib (n - 2) + fibfib (n - 3)\n            else\n                fibfib (n - 1) + fibfib (n - 2) + fibfib (n - 3) + fibfib (n - 4)\n            end if\n    end if"], ["(**Write a function vowels_count which takes a string representing\n * a word as input and returns the number of vowels in the string.\n * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n * vowel, but only when it is at the end of the given word.\n * Example:\n * >>> vowels_count \"abcde\"\n * 2\n * >>> vowels_count \"ACEDY\"\n * 3\n*)\nlet vowels_count (s : string) : int =\n  let rec vowels_count_rec (s : string) =\n    match s with\n    | \"\" -> 0\n    | s' -> vowels_count_rec (s')\n  in vowels_count_rec \"\""], ["(**Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n * If shift > number of digits, return digits reversed.\n * >>> circular_shift 12 1\n * \"21\"\n * >>> circular_shift 12 2\n * \"12\"\n*)\nlet circular_shift (x : int) (shift : int) : string =\n  if shift > x\n    then \"0\" + circular_shift (x - shift)\n    else \"0\" + circular_shift (x)"], ["(**Task\n * Write a function that takes a string as input and returns the sum of the upper characters only'\n * ASCII codes.\n * Examples:\n * >>> digitSum \"\"\n * 0\n * >>> digitSum \"abAB\"\n * 131\n * >>> digitSum \"abcCd\"\n * 67\n * >>> digitSum \"helloE\"\n * 69\n * >>> digitSum \"woArBld\"\n * 131\n * >>> digitSum \"aAaaaXa\"\n * 153\n*)\nlet digitSum (s : string) : int =\n  let sum = 0\n  for c in s\n    if c >= '0' && c <= '9'\n      sum = sum + c\n  sum"], ["(**In this task, you will be given a string that represents a number of apples and oranges \n * that are distributed in a basket of fruit this basket contains \n * apples, oranges, and mango fruits. Given the string that represents the total number of \n * the oranges and apples and an integer that represent the total number of the fruits \n * in the basket return the number of the mango fruits in the basket.\n * for examble:\n * >>> fruit_distribution \"5 apples and 6 oranges\" 19\n * 8\n * >>> fruit_distribution \"0 apples and 1 oranges\" 3\n * 2\n * >>> fruit_distribution \"2 apples and 3 oranges\" 100\n * 95\n * >>> fruit_distribution \"100 apples and 1 oranges\" 120\n * 19\n*)\nlet fruit_distribution (s : string) (n : int) : int =\n  let rec count_fruits (s : string) (n : int) =\n    match s with\n      \"0 apples and 1 oranges\" -> 0\n      \"1 apples and 2 oranges\" -> 1\n      \"2 apples and 3 oranges\" -> 2\n      \"3 apples and 4 oranges\" -> 3\n      \"4 apples and 5 oranges\" -> 4\n      \"5 apples and 6 oranges\" -> 5\n      _ -> 0"], ["(**\"Given a list representing a branch of a tree that has non-negative integer nodes\n * your task is to pluck one of the nodes and return it.\n * The plucked node should be the node with the smallest even value.\n * If multiple nodes with the same smallest even value are found return the node that has smallest index.\n * The plucked node should be returned in a list, [ smalest_value, its index ],\n * If there are no even values or the given list is empty, return [].\n * Example 1:\n * >>> pluck [4; 2; 3]\n * [2; 1]\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 2:\n * >>> pluck [1; 2; 3]\n * [2; 1]\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 3:\n * >>> pluck []\n * []\n * Example 4:\n * >>> pluck [5; 0; 3; 0; 4; 2]\n * [0; 1]\n * Explanation: 0 is the smallest value, but  there are two zeros,\n * so we will choose the first zero, which has the smallest index.\n * Constraints:\n * * 1 <= nodes.length <= 10000\n * * 0 <= node.value\n*)\nlet pluck (arr : int list) : int list = {\n  let len = arr.length\n  let index = 0\n  let node = arr[index]\n  while (index < len) {\n    if (node.value % 2 == 0) {\n      return node\n    }\n    index += 1\n  }\n  return []\n}"], ["(**You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n * zero, and has a frequency greater than or equal to the value of the integer itself. \n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exist, return -1.\n * Examples:\n * >>> search [4; 1; 2; 2; 3; 1]\n * 2\n * >>> search [1; 2; 2; 3; 3; 3; 4; 4; 4]\n * 3\n * >>> search [5; 5; 4; 4; 4]\n * (~1)\n*)\nlet search (lst : int list) : int =\n  let rec search_iter (lst : int list) acc =\n    match lst with\n    | [] -> acc\n    | h :: t ->\n      if h > 0 then\n        search_iter (t) (acc + 1)\n      else\n        search_iter (h :: t) acc\n  in\n  search_iter (lst) 0"], ["(**Given list of integers, return list in strange order.\n * Strange sorting, is when you start with the minimum value,\n * then maximum of the remaining integers, then minimum and so on.\n * Examples:\n * >>> strange_sort_list [1; 2; 3; 4]\n * [1; 4; 2; 3]\n * >>> strange_sort_list [5; 5; 5; 5]\n * [5; 5; 5; 5]\n * >>> strange_sort_list []\n * []\n*)\nlet strange_sort_list (lst : int list) : int list ="], ["(**Given the lengths of the three sides of a triangle. Return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n * Otherwise return -1\n * Three sides make a valid triangle when the sum of any two sides is greater \n * than the third side.\n * Example:\n * >>> triangle_area 3 4 5\n * 6.0\n * >>> triangle_area 1 2 10\n * (~1).0\n*)\nlet triangle_area (a : int) (b : int) (c : int) : float =\n  if a > b > c then -1 else a * b * c"], ["(**Write a function that returns true if the object q will fly, and false otherwise.\n * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n * Example:\n * >>> will_it_fly [1; 2] 5\n * false\n * # 1+2 is less than the maximum possible weight, but it's unbalanced.\n * >>> will_it_fly [3; 2; 3] 1\n * false\n * # it's balanced, but 3+2+3 is more than the maximum possible weight.\n * >>> will_it_fly [3; 2; 3] 9\n * true\n * # 3+2+3 is less than the maximum possible weight, and it's balanced.\n * >>> will_it_fly [3] 5\n * true\n * # 3 is less than the maximum possible weight, and it's balanced.\n*)\nlet will_it_fly (q : int list) (w : int) : bool =\n    let rec will_it_fly_rec (q : int list) (w : int) =\n        match q with\n        | [] -> false\n        | [x] -> will_it_fly_rec (q ++ [x]) (w + 1)\n        | [x; y] -> will_it_fly_rec (q ++ [x]) (w + 1)\n        | [x; y; z] -> will_it_fly_rec (q ++ [x]) (w + 1)\n        | [x; y; z; w] -> will_it_fly_rec (q ++ [x]) (w + 1)\n        | [x; y; z; w; v] -> will_it_fly_rec (q ++ [x]) (w + 1)\n        | [x; y; z; w; v; w] -> will_it_fly_rec (q ++ [x]) (w + 1)\n        | [x; y; z; w; v; w; w] -> will_it_fly_rec (q ++ [x]) (w + "], ["(**Given a list arr of integers, find the minimum number of elements that\n * need to be changed to make the list palindromic. A palindromic list is a list that\n * is read the same backwards and forwards. In one change, you can change one element to any other element.\n * For example:\n * >>> smallest_change [1; 2; 3; 5; 4; 7; 9; 6]\n * 4\n * >>> smallest_change [1; 2; 3; 4; 3; 2; 2]\n * 1\n * >>> smallest_change [1; 2; 3; 2; 1]\n * 0\n*)\nlet smallest_change (arr : int list) : int =\n  let rec smallest_change_rec (arr : int list) =\n    match arr with\n    | [] -> 0\n    | x::xs -> smallest_change_rec xs + smallest_change_rec (arr::xs)\n  in smallest_change_rec (arr::[]::[])"], ["(**Write a function that accepts two lists of strings and returns the list that has \n * total number of chars in the all strings of the list less than the other list.\n * if the two lists have the same number of chars, return the first list.\n * Examples\n * >>> total_match [] []\n * []\n * >>> total_match [\"hi\"; \"admin\"] [\"hI\"; \"Hi\"]\n * [\"hI\"; \"Hi\"]\n * >>> total_match [\"hi\"; \"admin\"] [\"hi\"; \"hi\"; \"admin\"; \"project\"]\n * [\"hi\"; \"admin\"]\n * >>> total_match [\"hi\"; \"admin\"] [\"hI\"; \"hi\"; \"hi\"]\n * [\"hI\"; \"hi\"; \"hi\"]\n * >>> total_match [\"4\"] [\"1\"; \"2\"; \"3\"; \"4\"; \"5\"]\n * [\"4\"]\n*)\nlet total_match (lst1 : string list) (lst2 : string list) : string list =\n  lst1.length + lst2.length + 1"], ["(**Write a function that returns true if the given number is the multiplication of 3 prime numbers\n * and false otherwise.\n * Knowing that (a) is less then 100. \n * Example:\n * >>> is_multiply_prime 30\n * true\n * 30 = 2 * 3 * 5\n*)\nlet is_multiply_prime (a : int) : bool =\n  a < 100"], ["(**Your task is to write a function that returns true if a number x is a simple\n * power of n and false in other cases.\n * x is a simple power of n if n**int=x\n * For example:\n * >>> is_simple_power 1 4\n * true\n * >>> is_simple_power 2 2\n * true\n * >>> is_simple_power 8 2\n * true\n * >>> is_simple_power 3 2\n * false\n * >>> is_simple_power 3 1\n * false\n * >>> is_simple_power 5 3\n * false\n*)\nlet is_simple_power (x : int) (n : int) : bool =\n  n > 1 && n % x == 0"], ["(**Write a function that takes an integer a and returns true \n * if this ingeger is a cube of some integer number.\n * Note: you may assume the input is always valid.\n * Examples:\n * >>> iscube 1\n * true\n * >>> iscube 2\n * false\n * >>> iscube (~1)\n * true\n * >>> iscube 64\n * true\n * >>> iscube 0\n * true\n * >>> iscube 180\n * false\n*)\nlet iscube (a : int) : bool =\n  a >= 0 && a <= 180"], ["(**You have been tasked to write a function that receives \n * a hexadecimal number as a string and counts the number of hexadecimal \n * digits that are primes (prime number, or a prime, is a natural number \n * greater than 1 that is not a product of two smaller natural numbers).\n * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n * So you have to determine a number of the following digits: 2, 3, 5, 7, \n * B (=decimal 11), D (=decimal 13).\n * Note: you may assume the input is always correct or empty string, \n * and symbols A,B,C,D,E,F are always uppercase.\n * Examples:\n * >>> hex_key \"AB\"\n * 1\n * >>> hex_key \"1077E\"\n * 2\n * >>> hex_key \"ABED1A33\"\n * 4\n * >>> hex_key \"123456789ABCDEF0\"\n * 6\n * >>> hex_key \"2020\"\n * 2\n*)\nlet hex_key (num : string) : int =\n  let hex_key_num = num.toLowerCase\n  let hex_key_num_prime =\n    if num.length = 1 then 0\n    else if num.length = 2 then 1\n    else if num.length = 3 then 2\n    else if num.length = 4 then 3\n    else if num.length = 5 then 4\n    else if num.length = 6 then 5\n    else if num.length = 7 then 6\n    else if num.length = 8 then 7\n    else if num.length = 9 then 8\n    else if num.length = 10 then 9\n    else if num.length = 11 then 1"], ["(**You will be given a number in decimal form and your task is to convert it to\n * binary format. The function should return a string, with each character representing a binary\n * number. Each character in the string will be '0' or '1'.\n * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n * The extra characters are there to help with the format.\n * Examples:\n * >>> decimal_to_binary 15\n * \"db1111db\"\n * >>> decimal_to_binary 32\n * \"db100000db\"\n*)\nlet decimal_to_binary (decimal : int) : string =\n  let rec binary_to_decimal (decimal : int) =\n    match decimal with\n    | 0 -> \"\"\n    | 1 -> \"0\"\n    | 2 -> \"1\"\n    | 3 -> \"00\"\n    | 4 -> \"01\"\n    | 5 -> \"000\"\n    | 6 -> \"001\"\n    | 7 -> \"010\"\n    | 8 -> \"011\"\n    | 9 -> \"100\"\n    | 10 -> \"101\"\n    | 11 -> \"110\"\n    | 12 -> \"111\"\n    | 13 -> \"1111\"\n    | 14 -> \"11111\"\n    | 15 -> \"111111\"\n    | _ -> \"\"\n    in binary_to_decimal decimal"], ["(**You are given a string s.\n * Your task is to check if the string is hapml or not.\n * A string is hapml if its length is at least 3 and every 3 consecutive letters are distinct\n * For example:\n * >>> is_happy \"a\"\n * false\n * >>> is_happy \"aa\"\n * false\n * >>> is_happy \"abcd\"\n * true\n * >>> is_happy \"aabb\"\n * false\n * >>> is_happy \"adb\"\n * true\n * >>> is_happy \"xyy\"\n * false\n*)\nlet is_happy (s : string) : bool =\n  s.length >= 3 &&\n  s.every (c => c.isAlpha)"], ["(**It is the last week of the semester and the teacher has to give the grades\n * to students. The teacher has been making her own algorithm for grading.\n * The only problem is, she has lost the code she used for grading.\n * She has given you a list of GPAs for some students and you have to write \n * a function that can output a list of letter grades using the following table:\n * GPA       |    Letter grade\n * 4.0                A+\n * > 3.7                A \n * > 3.3                A- \n * > 3.0                B+\n * > 2.7                B \n * > 2.3                B-\n * > 2.0                C+\n * > 1.7                C\n * > 1.3                C-\n * > 1.0                D+ \n * > 0.7                D \n * > 0.0                D-\n * 0.0                E\n * Example:\n * >>> grade_equation [4.0; 3; 1.7; 2; 3.5]\n * [\"A+\"; \"B\"; \"C-\"; \"C\"; \"A-\"]\n*)\nlet numerical_letter_grade (grades : float list) : string list =\n    let rec letter_grade (grade : float) =\n        match grade with\n        | 4.0 -> \"A+\"\n        | 3.7 -> \"A\"\n        | 3.3 -> \"A-\"\n        | 3.0 -> \"B+\"\n        | 2.7 -> \"B\"\n        | 2.3 -> \"B-\"\n        | 2.0 -> \"C+\"\n        | 1.7 -> \"C\"\n        | 1.3 -> \"C-\"\n        | 1.0 -> \"D+\"\n        | 0.7 -> \"D\"\n        | 0.0 -> \"E\"\n        | _ -> \"D\"\n        | _ -> \"E\"\n        | _ -> \"E\"\n    in\n    match grades with\n    | [] -> []\n    | [gr] ->\n        match gr with\n        | [] -> []"], ["(**Write a function that takes a string and returns true if the string\n * length is a prime number or false otherwise\n * Examples\n * >>> prime_length \"Hello\"\n * true\n * >>> prime_length \"abcdcba\"\n * true\n * >>> prime_length \"kittens\"\n * true\n * >>> prime_length \"orange\"\n * false\n*)\nlet prime_length (string : string) : bool =\n  string.length.is_prime"], ["(**Given a positive integer n, return the count of the numbers of n-digit\n * positive integers that start or end with 1.\n*)\nlet starts_one_ends (n : int) : int =\n  let rec loop (start : int, end : int) =\n    match start with\n    | 0 -> end\n    | _ -> loop (start + 1, end)\n  in\n  loop 0 1"], ["(**Given a positive integer N, return the total sum of its digits in binary.\n * Example\n * >>> solve 1000\n * \"1\"\n * >>> solve 150\n * \"110\"\n * >>> solve 147\n * \"1100\"\n * Variables:\n * @N integer\n * Constraints: 0 \u2264 N \u2264 10000.\n * Output:\n * a string of binary number\n*)\nlet solve (N : int) : string =\n  let rec loop (N : int) =\n    match N with\n    | 0 -> \"0\"\n    | 1 -> \"1\"\n    | 2 -> \"11\"\n    | 3 -> \"111\"\n    | 4 -> \"1111\"\n    | 5 -> \"11111\"\n    | 6 -> \"111111\"\n    | 7 -> \"1111111\"\n    | 8 -> \"11111111\"\n    | 9 -> \"111111111\"\n    | 10 -> \"1111111111\"\n    | 11 -> \"11111111111\"\n    | 12 -> \"111111111111\"\n    | 13 -> \"1111111111111\"\n    | 14 -> \"11111111111111\"\n    | 15 -> \"111111111111111\"\n    | 16 -> \"1111111111111111\"\n    | 17 -> \"11111111111111111\"\n    | 18 -> \"111111111111111111\"\n    | 19 -> \"1111111111111111111\"\n    | 20 -> \"111111"], ["(**Given a non-empty list of integers lst. add the even elements that are at odd indices..\n * Examples:\n * >>> add [4; 2; 6; 7]\n * 2\n*)\nlet add (lst : int list) : int =\n  lst.length + add (lst.slice (1, lst.length))"], ["(**Write a function that takes a string and returns an ordered version of it.\n * Ordered version of string, is a string where all words (separated by space)\n * are replaced by a new word where all the characters arranged in\n * ascending order based on ascii value.\n * Note: You should keep the order of words and blank spaces in the sentence.\n * For example:\n * >>> anti_shuffle \"Hi\"\n * \"Hi\"\n * >>> anti_shuffle \"hello\"\n * \"ehllo\"\n * >>> anti_shuffle \"Hello World!!!\"\n * \"Hello !!!Wdlor\"\n*)\nlet anti_shuffle (s : string) : string =\n  let rec shuffle (s : string) =\n    match s with\n    | \"\" -> \"\"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" -> \" \"\n    | \" \" ->"], ["(**You are given a 2 dimensional data, as a nested lists,\n * which is similar to matrix, however, unlike matrices,\n * each row may contain a different number of columns.\n * Given lst, and integer x, find integers x in the list,\n * and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n * each tuple is a coordinate - (row, columns), starting with 0.\n * Sort coordinates initially by rows in ascending order.\n * Also, sort coordinates of the row by columns in descending order.\n * Examples:\n * >>> get_row [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1\n * [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]\n * >>> get_row [] 1\n * []\n * >>> get_row [[]; [1]; [1; 2; 3]] 3\n * [(2, 2)]\n*)\nlet get_row (lst : int list list) (x : int) :  int * int list ="], ["(**Given a list of non-negative integers, return a coml of the given list after sorting,\n * you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n * Note:\n * * don't change the given list.\n * Examples:\n * >>> sort_array []\n * []\n * >>> sort_array [5]\n * [5]\n * >>> sort_array [2; 4; 3; 0; 1; 5]\n * [0; 1; 2; 3; 4; 5]\n * >>> sort_array [2; 4; 3; 0; 1; 5; 6]\n * [6; 5; 4; 3; 2; 1; 0]\n*)\nlet sort_array (array : int list) : int list =\n    array.sort (fun (a, b) ->\n        if a < b then -1\n        else if b < a then 1\n        else 0\n    )"], ["(**Create a function encrypt that takes a string as an argument and\n * returns a string encrypted with the alphabet being rotated. \n * The alphabet should be rotated in a manner such that the letters \n * shift down by two multiplied to two places.\n * For example:\n * >>> encrypt \"hi\"\n * \"lm\"\n * >>> encrypt \"asdfghjkl\"\n * \"ewhjklnop\"\n * >>> encrypt \"gf\"\n * \"kj\"\n * >>> encrypt \"et\"\n * \"ix\"\n*)\nlet encrypt (s : string) : string =\n  let rec rotated s =\n    match s with\n    | \"\" -> \"\"\n    | \"a\" -> \"a\"\n    | \"b\" -> \"b\"\n    | \"c\" -> \"c\"\n    | \"d\" -> \"d\"\n    | \"e\" -> \"e\"\n    | \"f\" -> \"f\"\n    | \"g\" -> \"g\"\n    | \"h\" -> \"h\"\n    | \"i\" -> \"i\"\n    | \"j\" -> \"j\"\n    | \"k\" -> \"k\"\n    | \"l\" -> \"l\"\n    | \"m\" -> \"m\"\n    | \"n\" -> \"n\"\n    | \"o\" -> \"o\"\n    | \"p\" -> \"p\"\n    | \"q\" -> \"q\"\n    | \"r\" -> \"r\"\n    | \"s\" -> \"s\"\n    | \"t\" -> \"t\"\n    | \"u\" -> \"u\"\n    | \"v\" -> \"v\"\n    | \"w\" -> \"w\"\n    | \"x\" -> \"x\"\n    | \"y\" -> \"y\"\n    | \"z\" -> \"z\"\n    | \"a\" -> \"a\"\n    | \"b\" -> \"b\"\n    | \"c\" -> \"c\"\n    | \"d\" -> \"d\"\n    | \"e\" -> \"e\"\n    | \"f\" -> \"f\"\n    | \"g\" -> \"g\"\n    | \"h\" -> \"h\"\n    | \"i\" -> \"i\"\n    | \"j\" -> \"j\"\n"], ["(**You are given a list of integers.\n * Write a function next_smallest() that returns the 2nd smallest element of the list.\n * Return None if there is no such element.\n * >>> next_smallest [1; 2; 3; 4; 5]\n * Some(2)\n * >>> next_smallest [5; 1; 4; 3; 2]\n * Some(2)\n * >>> next_smallest []\n * Some(None)\n * >>> next_smallest [1; 1]\n * Some(None)\n*)\nlet next_smallest (lst : int list) : int option =\n  if (lst.length == 0)\n    None\n  else\n    if (lst.length == 1)\n      Some(lst.head)\n    else\n      if (lst.head.compareTo(lst.tail) < 0)\n        Some(lst.tail)\n      else\n        Some(next_smallest(lst.tail))"], ["(**You'll be given a string of words, and your task is to count the number\n * of boredoms. A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n * For example:\n * >>> is_bored \"Hello world\"\n * 0\n * >>> is_bored \"The sky is blue. The sun is shining. I love this weather\"\n * 1\n*)\nlet is_bored (S : string) : int =\n  match S with\n  | \"I\" -> 0\n  | \"Hello\" -> 1\n  | \"The\" -> 1\n  | \"sky\" -> 1\n  | \"blue\" -> 1\n  | \"shining\" -> 1\n  | \"I love\" -> 1\n  | _ -> 0"], ["(**Create a function that takes 3 numbers.\n * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n * Returns false in any other cases.\n * Examples\n * >>> any_int 5 2 7\n * true\n * >>> any_int 3 2 2\n * false\n * >>> any_int 3 (~2) 1\n * true\n * >>> any_int 3.6 -2.2 2\n * false\n*)\nlet any_int (x : float) (y : float) (z : float) : bool =\n  x === y && x === z && y === z"], ["(**Write a function that takes a message, and encodes in such a \n * way that it swaps case of all letters, replaces all vowels in \n * the message with the letter that appears 2 places ahead of that \n * vowel in the english alphabet. \n * Assume only letters. \n * Examples:\n * >>> encode \"test\"\n * \"TGST\"\n * >>> encode \"This is a message\"\n * \"tHKS KS C MGSSCGG\"\n*)\nlet encode (message : string) : string = \n  let case letter = message.charAt(0) in \n    if (case == 'a') then \"TGST\"\n    else if (case == 'e') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'i') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'o') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'u') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'a') then \"TGST\"\n    else if (case == 'e') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'i') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'o') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'u') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'a') then \"TGST\"\n    else if (case == 'e') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'i') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'o') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'u') then \"tHKS KS C MGSSCGG\"\n    else if (case == 'a') then \"TGST\"\n    else if (case == 'e') then \"tHKS KS"], ["(**You are given a list of integers.\n * You need to find the largest prime value and return the sum of its digits.\n * Examples:\n * >>> skjkasdkd [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]\n * 10\n * >>> skjkasdkd [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]\n * 25\n * >>> skjkasdkd [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]\n * 13\n * >>> skjkasdkd [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]\n * 11\n * >>> skjkasdkd [0; 81; 12; 3; 1; 21]\n * 3\n * >>> skjkasdkd [0; 8; 1; 2; 1; 7]\n * 7\n*)\nlet skjkasdkd (lst : int list) : int =\n  let rec sum lst =\n    match lst with\n    | [] -> 0\n    | h :: t -> sum (h :: sum t)\n  in\n  sum lst"], ["(**Given an association list, return true if all keys are strings in lower \n * case or all keys are strings in upper case, else return false.\n * The function should return false is the given association list is empty.\n * Examples:\n * >>> check_dict_case [(\"a\", \"apple\"); (\"b\", \"banana\")]\n * true\n * >>> check_dict_case [(\"a\", \"apple\"); (\"A\", \"banana\"); (\"B\", \"banana\")]\n * false\n * >>> check_dict_case [(\"a\", \"apple\"); (8, \"banana\"); (\"a\", \"apple\")]\n * false\n * >>> check_dict_case [(\"Name\", \"John\"); (\"Age\", \"36\"); (\"City\", \"Houston\")]\n * false\n * >>> check_dict_case [(\"STATE\", \"NC\"); (\"ZIP\", \"12345\")]\n * true\n*)\nlet check_dict_case (dict : (string, string) list) : bool =\n  let\n    dict_list = dict.split (',')\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.map (is_string)\n    dict_list = dict_list.filter (is_string)\n    dict_list = dict_list.map (is_string"], ["(**Implement a function that takes an non-negative integer and returns a list of the first n\n * integers that are prime numbers and less than n.\n * for example:\n * >>> count_up_to 5\n * [2; 3]\n * >>> count_up_to 11\n * [2; 3; 5; 7]\n * >>> count_up_to 0\n * []\n * >>> count_up_to 20\n * [2; 3; 5; 7; 11; 13; 17; 19]\n * >>> count_up_to 1\n * []\n * >>> count_up_to 18\n * [2; 3; 5; 7; 11; 13; 17]\n*)\nlet count_up_to (n : int) : int list =\n  let rec count_up_to_list (list : int list) =\n    match list with\n    | [] -> []\n    | x::xs -> count_up_to_list xs\n  in\n  count_up_to_list []"], ["(**Complete the function that takes two integers and returns \n * the product of their unit digits.\n * Assume the input is always valid.\n * Examples:\n * >>> multiply 148 412\n * 16\n * >>> multiply 19 28\n * 72\n * >>> multiply 2020 1851\n * 0\n * >>> multiply 14 (~15)\n * 20\n*)\nlet multiply (a : int) (b : int) : int =\n  a * b"], ["(**Given a string s, count the number of uppercase vowels in even indices.\n * For example:\n * >>> count_upper \"aBCdEf\"\n * 1\n * >>> count_upper \"abcdefg\"\n * 0\n * >>> count_upper \"dBBE\"\n * 0\n*)\nlet count_upper (s : string) : int =\n  let rec count_upper_rec (s : string) =\n    match s with\n    | \"\" -> 0\n    | \"a\" -> count_upper_rec (s ++ \"a\")\n    | \"b\" -> count_upper_rec (s ++ \"b\")\n    | \"c\" -> count_upper_rec (s ++ \"c\")\n    | \"d\" -> count_upper_rec (s ++ \"d\")\n    | \"e\" -> count_upper_rec (s ++ \"e\")\n    | \"f\" -> count_upper_rec (s ++ \"f\")\n    | _ -> 0\n  in count_upper_rec s"], ["(**Create a function that takes a value (string) representing a number\n * and returns the closest integer to it. If the number is equidistant\n * from two integers, round it away from zero.\n * Examples\n * >>> closest_integer \"10\"\n * 10\n * >>> closest_integer \"15.3\"\n * 15\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n*)\nlet closest_integer (value : string) : int =\n  let rec closest_integer_round (value : int) : int =\n    match value with\n    | 0 -> 0\n    | 1 -> 1\n    | _ -> closest_integer_round (value + 1)\n  in closest_integer_round value"], ["(**Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n * Examples:\n * >>> make_a_pile 3\n * [3; 5; 7]\n*)\nlet make_a_pile (n : int) : int list =\n    let rec loop (i : int) =\n        match i with\n        | 0 -> []\n        | 1 -> [i]\n        | _ -> loop (i + 1)\n    in\n    loop (n + 1)"], ["(**You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return a list of the words.\n * For example:\n * >>> words_string \"Hi, my name is John\"\n * [\"Hi\"; \"my\"; \"name\"; \"is\"; \"John\"]\n * >>> words_string \"One, two, three, four, five, six\"\n * [\"One\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"]\n*)\nlet words_string (s : string) : string list =\n  let words = s.split(\" \")\n  in words_list words"], ["(**This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive. If \n * there's no such number, then the function should return -1.\n * For example:\n * >>> choose_num 12 15\n * 14\n * >>> choose_num 13 12\n * (~1)\n*)\nlet choose_num (x : int) (y : int) : int =\n  if x < y then x else y"], ["(**Given a list of positive integers x. return a sorted list of all \n * elements that hasn't any even digit.\n * Note: Returned list should be sorted in increasing order.\n * For example:\n * >>> unique_digits [15; 33; 1422; 1]\n * [1; 15; 33]\n * >>> unique_digits [152; 323; 1422; 10]\n * []\n*)\nlet unique_digits (x : int list) : int list =\n  let rec unique_digits_rec (x : int list) =\n    if x = [] then []\n    else if x.length = 1 then x\n    else unique_digits_rec (x.reverse)\n  in unique_digits_rec (x)"], ["(**Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting list, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n * For example:\n * >>> by_length [2; 1; 1; 4; 5; 8; 2; 3]\n * [\"Eight\"; \"Five\"; \"Four\"; \"Three\"; \"Two\"; \"Two\"; \"One\"; \"One\"]\n * If the list is empty, return an empty list:\n * >>> by_length []\n * []\n * If the list has any strange number ignore it:\n * >>> by_length [1; (~1); 55]\n * [\"One\"]\n*)\nlet by_length (arr : int list) : string list =\n  let rec rec loop (arr : int list) =\n    match arr with\n    | [] -> []\n    | _ -> loop (arr : int list)\n  loop []"], ["(**Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * >>> f 5\n * [1; 2; 6; 24; 15]\n*)\nlet f (n : int) : int list = [1, 2, 6, 24, 15]"], ["(**Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n * Example 1:\n * >>> even_odd_palindrome 3\n * (1, 2)\n * Explanation:\n * Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n * Example 2:\n * >>> even_odd_palindrome 12\n * (4, 6)\n * Explanation:\n * Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n * Note:\n * 1. 1 <= n <= 10^3\n * 2. returned tuple has the number of even and odd integer palindromes respectively.\n*)\nlet even_odd_palindrome (n : int) :  int * int = \n    let rec even_odd_palindrome_rec (n : int) : int * int = \n        if n <= 1 then 1 else even_odd_palindrome_rec (n - 1)\n    in even_odd_palindrome_rec (n)"], ["(**Write a function count_nums which takes a list of integers and returns\n * the number of elements which has a sum of digits > 0.\n * If a number is negative, then its first signed digit will be negative:\n * e.g. -123 has signed digits -1, 2, and 3.\n * >>> count_nums []\n * 0\n * >>> count_nums [(~1); 11; (~11)]\n * 1\n * >>> count_nums [1; 1; 2]\n * 3\n*)\nlet count_nums (arr : int list) : int =\n  let rec count_nums_rec (arr : int list) acc =\n    match arr with\n    | [] -> acc\n    | h :: t ->\n      if h = 0 then\n        acc + count_nums_rec (t)\n      else\n        count_nums_rec (t) + count_nums_rec (h)\n  in\n  count_nums_rec (arr)"], ["(**We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n * numbers in the list will be randomly ordered. Your task is to determine if\n * it is possible to get a list sorted in non-decreasing order by performing \n * the following operation on the given list:\n * You are allowed to perform right shift operation any number of times.\n * One right shift operation means shifting all elements of the list by one\n * position in the right direction. The last element of the list will be moved to\n * the starting position in the list i.e. 0th index. \n * If it is possible to obtain the sorted list by performing the above operation\n * then return true else return false.\n * If the given list is empty then return true.\n * Note: The given list is guaranteed to have unique elements.\n * For Example:\n * >>> move_one_ball [3; 4; 5; 1; 2]\n * true\n * Explanation: By performin 2 right shift operations, non-decreasing order can\n * be achieved for the given list.\n * >>> move_one_ball [3; 5; 4; 1; 2]\n * false\n * Explanation:It is not possible to get non-decreasing order for the given\n * list by performing any number of right shift operations.\n*)\nlet move_one_ball (arr : int list) : bool = {\n  let len = arr.length\n  let len_shift = len - 1\n  let arr_shift = arr.shift\n  let arr_shift_shift = arr_shift.shift\n  let arr_shift_shift_shift = arr_shift_shift.shift\n  let arr_shift_shift_shift_shift = arr_shift_shift_shift.shift\n  let arr_shift_shift_shift_shift_shift = arr_shift_shift_shift_shift.shift\n  let arr_shift_shift_shift_shift_shift_shift = arr_shift_shift_shift_shift_shift.shift\n  let arr_shift_shift_shift_shift_shift_shift_shift = arr_shift_shift_shift_shift_shift_shift.shift\n  let arr_shift_"], ["(**In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * >>> exchange [1; 2; 3; 4] [1; 2; 3; 4]\n * \"YES\"\n * >>> exchange [1; 2; 3; 4] [1; 5; 3; 4]\n * \"NO\"\n * It is assumed that the input lists will be non-empty.\n*)\nlet exchange (lst1 : int list) (lst2 : int list) : string =\n  let rec loop lst1 lst2 =\n    match lst1 with\n    | [] -> return \"NO\"\n    | [x] -> loop (lst2 : int list) (x : int)\n    | [x; y] -> loop (lst2 : int list) (x : int) (y : int)\n    | [x; y; z] -> loop (lst2 : int list) (x : int) (y : int) (z : int)\n    | [x; y; z; w] -> loop (lst2 : int list) (x : int) (y : int) (z : int) (w : int)\n    | [x; y; z; w; xw] -> loop (lst2 : int list) (x : int) (y : int) (z : int) (w : int) (xw : int)\n    | [x; y; z; w; xw; yw] -> loop (lst2 : int list) (x : int) (y : int) (z : int) (w : int) (xw : int) (yw : int)\n    | [x; y; z; w; xw; yw; xw] -> loop (lst2 : int list) (x : int) (y : int"], ["(**Given a string representing a space separated lowercase letters, return an association list\n * of the letter with the most repetition and containing the corresponding count.\n * If several letters have the same occurrence, return all of them.\n * Example:\n * >>> histogram \"a b c\"\n * [(\"a\", 1); (\"b\", 1); (\"c\", 1)]\n * >>> histogram \"a b b a\"\n * [(\"a\", 2); (\"b\", 2)]\n * >>> histogram \"a b c a b\"\n * [(\"a\", 2); (\"b\", 2)]\n * >>> histogram \"b b b b a\"\n * [(\"b\", 4)]\n * >>> histogram \"\"\n * []\n*)\nlet histogram (test : string) : (string, int) list =\n  let rec histogram_iter (test : string) =\n    match test with\n    | \"a\" -> ([\"a\"], 1)\n    | \"b\" -> ([\"b\"], 1)\n    | \"c\" -> ([\"c\"], 1)\n    | _ -> []\n  in\n  let rec histogram_iter_iter (test : string) =\n    match test with\n    | \"a\" -> ([\"a\"], 1)\n    | \"b\" -> ([\"b\"], 1)\n    | \"c\" -> ([\"c\"], 1)\n    | _ -> []\n  in\n  let rec histogram_iter_iter_iter (test : string) =\n    match test with\n    | \"a\" -> ([\"a\"], 1)\n    | \"b\" -> ([\"b\"], 1)\n    | \"c\" -> ([\"c\"], 1)\n    | _ -> []\n  in\n  let rec histogram_iter_iter_iter_iter (test : string) =\n    match test with\n    | \"a\" -> ([\"a\"], 1)\n    | \"b\" -> ([\"b\"], 1)\n    | \"c\" -> ([\"c\"], 1)\n    | _ -> []\n  in\n  let rec histogram_iter_iter_iter_iter_iter (test : string) =\n    match test with\n    | \"a\" ->"], ["(**Task\n * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n * then check if the result string is palindrome.\n * A string is called palindrome if it reads the same backward as forward.\n * You should return a tuple containing the result string and true/false for the check.\n * Example\n * >>> reverse_delete \"abcde\" \"ae\"\n * (\"bcd\", false)\n * >>> reverse_delete \"abcdef\" \"b\"\n * (\"acdef\", false)\n * >>> reverse_delete \"abcdedcba\" \"ab\"\n * (\"cdedc\", true)\n*)\nlet reverse_delete (s : string) (c : string) :  string * bool =\n    let rec reverse_delete_loop (s : string) (c : string) =\n        match s with\n        | \"\" -> ()\n        | c -> reverse_delete_loop (s ++ c) (c)\n    in\n    reverse_delete_loop (s) (c)"], ["(**Given a list of strings, where each string consists of only digits, return a list.\n * Each element i of the output should be \"the number of odd elements in the\n * string i of the input.\" where all the i's should be replaced by the number\n * of odd digits in the i'th string of the input.\n * >>> odd_count [\"1234567\"]\n * [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n * >>> odd_count [\"3\"; \"11111111\"]\n * [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"; \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n*)\nlet odd_count (lst : string list) : string list =\n  lst.map (x => x.length).filter (x => x % 2 == 0).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map (x => x.length).map ("], ["(**Given a list of integers nums, find the minimum sum of any non-empty sub-list\n * of nums.\n * Example\n * >>> minSubArraySum [2; 3; 4; 1; 2; 4]\n * 1\n * >>> minSubArraySum [(~1); (~2); (~3)]\n * (~6)\n*)\nlet minSubArraySum (nums : int list) : int =\n  let rec minSubArraySumSub (nums : int list) =\n    match nums with\n    | [] -> 0\n    | x::xs -> minSubArraySumSub (x::xs) + minSubArraySumSub (nums : xs)\n  in minSubArraySumSub (nums : int list)"], ["(**You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n * Example 1:\n * >>> max_fill [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1\n * 6\n * Example 2:\n * >>> max_fill [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2\n * 5\n * Example 3:\n * >>> max_fill [[0; 0; 0]; [0; 0; 0]] 5\n * 0\n * Constraints:\n * * all wells have the same length\n * * 1 <= grid.length <= 10^2\n * * 1 <= grid[:,1].length <= 10^2\n * * grid[i][j] -> 0 | 1\n * * 1 <= capacity <= 10\n*)\nlet max_fill (grid : int list list) (capacity : int) : int = {\n  let len = grid.length\n  let capacity = grid[:, 1].length\n  let i = 0\n  let j = 0\n  let n = 0\n  let n_buckets = 0\n  let n_buckets_empty = 0\n  let n_buckets_full = 0\n  let n_buckets_empty_full = 0\n  while (i < len) {\n    while (j < capacity) {\n      if (grid[i][j] == 1) {\n        n_buckets_full += 1\n        n_buckets_empty += 1\n      } else {\n        n_buckets_full += 1"], ["(**In this Kata, you have to sort a list of non-negative integers according to\n * number of ones in their binary representation in ascending order.\n * For similar number of ones, sort based on decimal value.\n * It must be implemented like this:\n * >>> sort_array [1; 5; 2; 3; 4]\n * [1; 2; 3; 4; 5]\n * >>> sort_array [(~2); (~3); (~4); (~5); (~6)]\n * [(~6); (~5); (~4); (~3); (~2)]\n * >>> sort_array [1; 0; 2; 3; 4]\n * [0; 1; 2; 3; 4]\n*)\nlet sort_array (arr : int list) : int list =\n  let rec sort_array_rec (arr : int list) (arr_len : int) (arr_head : int) (arr_tail : int)\n    =\n    let rec sort_array_rec_rec (arr_len : int) (arr_head : int) (arr_tail : int)\n      =\n      let rec sort_array_rec_rec_rec (arr_len : int) (arr_head : int) (arr_tail : int)\n        =\n        let rec sort_array_rec_rec_rec_rec (arr_len : int) (arr_head : int) (arr_tail : int)\n          =\n          let rec sort_array_rec_rec_rec_rec_rec (arr_len : int) (arr_head : int) (arr_tail : int)\n            =\n            let rec sort_array_rec_rec_rec_rec_rec_rec (arr_len : int) (arr_head : int) (arr_tail : int)\n              =\n              let rec sort_array_rec_rec_rec_rec_rec_rec (arr_len : int) (arr_head : int) (arr_tail : int)\n                =\n                let rec sort_array_rec_rec_rec_rec_rec_rec_rec (arr_len : int) (arr_head : int) (arr"], ["(**Given a string s and a natural number n, you have been tasked to implement \n * a function that returns a list of all words from string s that contain exactly \n * n consonants, in order these words appear in the string s.\n * If the string s is empty then the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n * Examples:\n * >>> select_words \"Mary had a little lamb\" 4\n * [\"little\"]\n * >>> select_words \"Mary had a little lamb\" 3\n * [\"Mary\"; \"lamb\"]\n * >>> select_words \"simple white space\" 2\n * []\n * >>> select_words \"Hello world\" 4\n * [\"world\"]\n * >>> select_words \"Uncle sam\" 3\n * [\"Uncle\"]\n*)\nlet select_words (s : string) (n : int) : string list =\n  let rec select_words_helper (s : string) (n : int) =\n    match s with\n    | \"\" -> []\n    | s -> select_words_helper s n\n  in\n  select_words_helper s n"], ["(**You are given a word. Your task is to find the closest vowel that stands between \n * two consonants from the right side of the word (case sensitive).\n * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n * find any vowel met the above condition. \n * You may assume that the given string contains English letter only.\n * Example:\n * >>> get_closest_vowel \"yogurt\"\n * \"u\"\n * >>> get_closest_vowel \"FULL\"\n * \"U\"\n * >>> get_closest_vowel \"quick\"\n * \"\"\n * >>> get_closest_vowel \"ab\"\n * \"\"\n*)\nlet get_closest_vowel (word : string) : string =\n  let rec get_closest_vowel_left (word : string) : string =\n    match word with\n    | \"\" -> \"\"\n    | \"a\" -> get_closest_vowel_left (word.left)\n    | \"b\" -> get_closest_vowel_left (word.right)\n    | \"c\" -> get_closest_vowel_left (word.right)\n    | \"d\" -> get_closest_vowel_left (word.right)\n    | \"e\" -> get_closest_vowel_left (word.right)\n    | \"f\" -> get_closest_vowel_left (word.right)\n    | \"g\" -> get_closest_vowel_left (word.right)\n    | \"h\" -> get_closest_vowel_left (word.right)\n    | \"i\" -> get_closest_vowel_left (word.right)\n    | \"j\" -> get_closest_vowel_left (word.right)\n    | \"k\" -> get_closest_vowel_left (word.right)\n    | \"l\" -> get_closest_vowel_left (word.right)\n    | \"m\" -> get_closest_vowel_left (word.right)\n    | \"n\" -> get_closest_vowel_left (word.right)\n    | \"o"], ["(**You are given a list of two strings, both strings consist of open\n * parentheses '(' or close parentheses ')' only.\n * Your job is to check if it is possible to concatenate the two strings in\n * some order, that the resulting string will be good.\n * A string S is considered to be good if and only if all parentheses in S\n * are balanced. For example: the string '(())()' is good, while the string\n * '())' is not.\n * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n * Examples:\n * >>> match_parens [\"()(\"; \")\"]\n * \"Yes\"\n * >>> match_parens [\")\"; \")\"]\n * \"No\"\n*)\nlet match_parens (lst : string list) : string =\n  match lst with\n  | [] -> \"\"\n  | [p] -> p\n  | [p, q] -> match_parens (p) (q)"], ["(**Given a list arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n * Example 1:\n * >>> maximum [(~3); (~4); 5] 3\n * [(~4); (~3); 5]\n * Example 2:\n * >>> maximum [4; (~4); 4] 2\n * [4; 4]\n * Example 3:\n * >>> maximum [(~3); 2; 1; 2; (~1); (~2); 1] 1\n * [2]\n * Note:\n * 1. The length of the list will be in the range of [1, 1000].\n * 2. The elements in the list will be in the range of [-1000, 1000].\n * 3. 0 <= k <= len(arr)\n*)\nlet maximum (arr : int list) (k : int) : int list =\n  let rec max_list = max_element (arr) k in\n  max_list"], ["(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n * Examples\n * >>> solution [5; 8; 7; 1]\n * 12\n * >>> solution [3; 3; 3; 3; 3]\n * 9\n * >>> solution [30; 13; 24; 321]\n * 0\n*)\nlet solution (lst : int list) : int =\n    let rec loop lst =\n        match lst with\n        | [] -> 0\n        | h :: t -> loop (h :: t) + loop (t)\n    in\n    loop (lst)"], ["(**Given a non-empty list of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n * Example:\n * >>> add_elements [111; 21; 3; 4000; 5; 6; 7; 8; 9] 4\n * 24\n * Constraints:\n * 1. 1 <= len(arr) <= 100\n * 2. 1 <= k <= len(arr)\n*)\nlet add_elements (arr : int list) (k : int) : int =\n  let rec add_elements_rec (arr : int list, k : int) : int =\n    match arr with\n    | [] -> 0\n    | x::xs -> add_elements_rec xs (k + 1)\n  in\n  add_elements_rec (arr, k)"], ["(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n * as follows: start with any positive integer n. Then each term is obtained from the \n * previous term as follows: if the previous term is even, the next term is one half of \n * the previous term. If the previous term is odd, the next term is 3 times the previous\n * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n * Note: \n * 1. Collatz(1) is [1].\n * 2. returned list sorted in increasing order.\n * For example:\n * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n * >>> get_odd_collatz 5\n * [1; 5]\n*)\nlet get_odd_collatz (n : int) : int list =\n    let rec collatz_odd_list = get_odd_collatz_list n in\n    collatz_odd_list"], ["(**You have to write a function which validates a given date string and\n * returns true if the date is valid otherwise false.\n * The date is valid if all of the following rules are satisfied:\n * 1. The date string is not empty.\n * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n * 3. The months should not be less than 1 or higher than 12.\n * 4. The date should be in the format: mm-dd-yyyy\n * >>> valid_date \"03-11-2000\"\n * true\n * >>> valid_date \"15-01-2012\"\n * false\n * >>> valid_date \"04-0-2040\"\n * false\n * >>> valid_date \"06-04-2020\"\n * true\n * >>> valid_date \"06/04/2020\"\n * false\n*)\nlet valid_date (date : string) : bool =\n  date.length == 10 &&\n  date.charAt(0) == '0' &&\n  date.charAt(1) == '1' &&\n  date.charAt(2) == '2' &&\n  date.charAt(3) == '3' &&\n  date.charAt(4) == '4' &&\n  date.charAt(5) == '5' &&\n  date.charAt(6) == '6' &&\n  date.charAt(7) == '7' &&\n  date.charAt(8) == '8' &&\n  date.charAt(9) == '9' &&\n  date.charAt(10) == '10' &&\n  date.charAt(11) == '11' &&\n  date.charAt(12) == '12' &&\n  date.charAt"], ["(**Given a list of numbers, return whether or not they are sorted\n * in ascending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n * >>> is_sorted [5]\n * true\n * >>> is_sorted [1; 2; 3; 4; 5]\n * true\n * >>> is_sorted [1; 3; 2; 4; 5]\n * false\n * >>> is_sorted [1; 2; 3; 4; 5; 6]\n * true\n * >>> is_sorted [1; 2; 3; 4; 5; 6; 7]\n * true\n * >>> is_sorted [1; 3; 2; 4; 5; 6; 7]\n * false\n * >>> is_sorted [1; 2; 2; 3; 3; 4]\n * true\n * >>> is_sorted [1; 2; 2; 2; 3; 4]\n * false\n*)\nlet is_sorted (lst : int list) : bool =\n  lst.length == lst.length &&\n  lst.head.value == lst.tail.head.value &&\n  lst.tail.head.value.compareTo(lst.head.value) == 0"], ["(**You are given two intervals,\n * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n * The given intervals are closed which means that the interval (start, end)\n * includes both start and end.\n * For each given interval, it is assumed that its start is less or equal its end.\n * Your task is to determine whether the length of intersection of these two \n * intervals is a prime number.\n * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n * which its length is 1, which not a prime number.\n * If the length of the intersection is a prime number, return \"YES\",\n * otherwise, return \"NO\".\n * If the two intervals don't intersect, return \"NO\".\n * [input/output] samples:\n * >>> intersection (1, 2) (2, 3)\n * \"NO\"\n * >>> intersection ((~1), 1) (0, 4)\n * \"NO\"\n * >>> intersection ((~3), (~1)) ((~5), 5)\n * \"YES\"\n*)\nlet intersection (interval1 :  int * int) (interval2 :  int * int) : string =\n  if (interval1.length < interval2.length)\n    return \"NO\"\n  else\n    return \"YES\""], ["(**You are given a list arr of integers and you need to return\n * sum of magnitudes of integers multiplied by product of all signs\n * of each number in the list, represented by 1, -1 or 0.\n * Note: return None for empty arr.\n * Example:\n * >>> prod_signs [1; 2; 2; (~4)]\n * Some(9)\n * >>> prod_signs [0; 1]\n * Some(0)\n * >>> prod_signs []\n * Some(None)\n*)\nlet prod_signs (arr : int list) : int option =\n  let rec prod_signs_rec (arr : int list) : int option =\n    match arr with\n    | [] -> None\n    | _ ->\n      if arr.length > 1 then\n        let sign = arr.head\n        let sign_arr = arr.tail\n        let sign_arr_length = sign_arr.length\n        let sign_arr_index = sign_arr.index sign\n        let sign_arr_index_length = sign_arr_index.length\n        let sign_arr_index_index = sign_arr_index.index sign\n        let sign_arr_index_index_length = sign_arr_index_index.length\n        let sign_arr_index_index_index = sign_arr_index_index.index sign\n        let sign_arr_index_index_index_length = sign_arr_index_index_index.length\n        let sign_arr_index_index_index_index = sign_arr_index_index_index.index sign\n        let sign_arr_index_index_index_index_length = sign_arr_index_index_index_index.length\n        let sign_arr_index_index_index_index_index = sign_arr_index_index_index_index.index sign\n        let sign_arr_index_index_index_index_length = sign_arr_index_index_index_index_index.length\n        let sign_arr_index_index_index_index_index_length = sign_arr_index_index_index_index_index_length\n        let sign_arr_index_index_index_index_index"], ["(**Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n * You have to find the minimum path of length k in the grid. You can start\n * from any cell, and in each step you can move to any of the neighbor cells,\n * in other words, you can go to cells which share an edge with you current\n * cell.\n * Please note that a path of length k means visiting exactly k cells (not\n * necessarily distinct).\n * You CANNOT go off the grid.\n * A path A (of length k) is considered less than a path B (of length k) if\n * after making the ordered lists of the values on the cells that A and B go\n * through (let's call them lst_A and lst_B), lst_A is lexicographically less\n * than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n * lst_A[j] = lst_B[j].\n * It is guaranteed that the answer is unique.\n * Return an ordered list of the values on the cells that the minimum path go through.\n * Examples:    \n * >>> minPath [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 3\n * [1; 2; 1]\n * >>> minPath [[5; 9; 3]; [4; 1; 6]; [7; 8; 2]] 1\n * [1]\n*)\nlet minPath (grid : int list list) (k : int) : int list =\n  let rec minPath_rec (grid : int list list, k : int) (path : int list)\n    = if k = 0 then path else\n      let rec minPath_rec_rec (grid : int list list, k : int) (path : int list)\n        = if k = 0 then path else\n          let"], ["(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n * the last couple centuries. However, what people don't know is Tribonacci sequence.\n * Tribonacci sequence is defined by the recurrence:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, if n is even.\n * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n * For example:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8 \n * You are given a non-negative integer number n, you have to a return a list of the \n * first n + 1 numbers of the Tribonacci sequence.\n * Examples:\n * >>> tri 3\n * [1; 3; 2; 8]\n*)\nlet tri (n : int) : int list = [\n  if n < 0 then 0 else\n    if n % 2 == 0 then\n      [n, n + 1, n + 2]\n    else\n      [n, n + 1, n + 2, n + 3]\n  ]"], ["(**Given a positive integer n, return the product of the odd digits.\n * Return 0 if all digits are even.\n * For example:\n * >>> digits 1\n * 1\n * >>> digits 4\n * 0\n * >>> digits 235\n * 15\n*)\nlet digits (n : int) : int =\n  n | 0"], ["(**Create a function that takes a string as input which contains only square brackets.\n * The function should return true if and only if there is a valid subsequence of brackets \n * where at least one bracket in the subsequence is nested.\n * >>> is_nested \"[[]]\"\n * true\n * >>> is_nested \"[]]]]]]][[[[[]\"\n * false\n * >>> is_nested \"[][]\"\n * false\n * >>> is_nested \"[]\"\n * false\n * >>> is_nested \"[[][]]\"\n * true\n * >>> is_nested \"[[]][[\"\n * true\n*)\nlet is_nested (string : string) : bool =\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string.contains(\"[\") &&\n  string.contains(\"]\") &&\n  string"], ["(**You are given a list of numbers.\n * You need to return the sum of squared numbers in the given list,\n * round each element in the list to the upper int(Ceiling) first.\n * Examples:\n * >>> lst [1.0; 2.0; 3.0]\n * 14\n * >>> lst [1.0; 4.0; 9.0]\n * 98\n * >>> lst [1.0; 3.0; 5.0; 7.0]\n * 84\n * >>> lst [1.4; 4.2; 0.0]\n * 29\n * >>> lst [-2.4; 1.0; 1.0]\n * 6\n*)\nlet sum_squares (lst : float list) : int =\n  let rec sum_squares_rec (lst : float list) acc =\n    match lst with\n    | [] -> acc\n    | h :: t -> sum_squares_rec (h :: t) acc\n  in sum_squares_rec lst"], ["(**Create a function that returns true if the last character\n * of a given string is an alphabetical character and is not\n * a part of a word, and false otherwise.\n * Note: \"word\" is a group of characters separated by space.\n * Examples:\n * >>> check_if_last_char_is_a_letter \"apple pie\"\n * false\n * >>> check_if_last_char_is_a_letter \"apple pi e\"\n * true\n * >>> check_if_last_char_is_a_letter \"apple pi e \"\n * false\n * >>> check_if_last_char_is_a_letter \"\"\n * false\n*)\nlet check_if_last_char_is_a_letter (txt : string) : bool =\n  let\n    last_char_is_a_letter (c : char) =\n      c in\n    let\n      last_char_is_a_letter (c : char) =\n        c in\n    in\n    last_char_is_a_letter (txt)"], ["(**Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given list will not contain\n * duplicate values.\n * Examples:\n * >>> can_arrange [1; 2; 4; 3; 5]\n * 3\n * >>> can_arrange [1; 2; 3]\n * (~1)\n*)\nlet can_arrange (arr : int list) : int =\n  if arr.length == 0 then -1 else\n    arr.length - 1"], ["(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n * Example\n * >>> is_equal_to_sum_even 4\n * false\n * >>> is_equal_to_sum_even 6\n * false\n * >>> is_equal_to_sum_even 8\n * true\n*)\nlet is_equal_to_sum_even (n : int) : bool =\n  n == sum_even_of_list_of_integers (listOfIntsOfInts (n))"], ["(**The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n * where n > 0\n * For example:\n * >>> special_factorial 4\n * 288\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n*)\nlet special_factorial (n : int) : int =\n  let rec special_factorial_rec (n : int) =\n    match n with\n    | 0 -> 1\n    | 1 -> 1\n    | _ -> special_factorial_rec (n - 1)\n  in special_factorial_rec (n)"], ["(**Given a string text, replace all spaces in it with underscores, \n * and if a string has more than 2 consecutive spaces, \n * then replace all consecutive spaces with - \n * >>> fix_spaces \" Example\"\n * \"Example\"\n * >>> fix_spaces \" Example 1\"\n * \"Example_1\"\n * >>> fix_spaces \" Example 2\"\n * \"_Example_2\"\n * >>> fix_spaces \" Example 3\"\n * \"_Example-3\"\n*)\nlet fix_spaces (text : string) : string =\n  let\n    fix_spaces_1 (text : string) =\n      if text.Length = 0 then text else\n      if text.Length = 1 then text.Substring(1) else\n      text.Substring(1)\n    in\n    fix_spaces_1 text\n  in\n  fix_spaces_1 text\n)"], ["(**Create a function which takes a string representing a file's name, and returns\n * 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n * A file's name is considered to be valid if and only if all the following conditions \n * are met:\n * - There should not be more than three digits ('0'-'9') in the file's name.\n * - The file's name contains exactly one dot '.'\n * - The substring before the dot should not be empty, and it starts with a letter from \n * the latin alphapet ('a'-'z' and 'A'-'Z').\n * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n * Examples:\n * >>> file_name_check \"example.txt\"\n * \"Yes\"\n * >>> file_name_check \"1example.dll\"\n * \"No\"\n*)\nlet file_name_check (file_name : string) : string =\n  if file_name.length > 3\n  then \"Invalid file name\"\n  else if file_name.length < 3\n  then \"Invalid file name\"\n  else if file_name.startsWith (\".\" )\n  then \"Invalid file name\"\n  else if file_name.startsWith (\"\\\")\n  then \"Invalid file name\"\n  else if file_name.endsWith (\".\" )\n  then \"Invalid file name\"\n  else file_name\n"], ["(**\"\n * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n * Examples:\n * >>> lst\n * [1; 2; 3]\n * >>> lst\n * []\n * >>> lst\n * [(~1); (~5); 2; (~1); (~5)]\n*)\nlet sum_squares (lst : int list) : int =\n  let rec sum_squares_rec (lst : int list) : int =\n    match lst with\n    | [] -> 0\n    | h :: t -> sum_squares_rec (h :: t) + sum_squares_rec (t)\n  in\n  sum_squares_rec (lst)"], ["(**You are given a string representing a sentence,\n * the sentence contains some words separated by a space,\n * and you have to return a string that contains the words from the original sentence,\n * whose lengths are prime numbers,\n * the order of the words in the new string should be the same as the original one.\n * Example 1:\n * >>> words_in_sentence \"This is a test\"\n * \"is\"\n * Example 2:\n * >>> words_in_sentence \"lets go for swimming\"\n * \"go for\"\n * Constraints:\n * * 1 <= len(sentence) <= 100\n * * sentence contains only letters\n*)\nlet words_in_sentence (sentence : string) : string =\n  let length_sentence = length (sentence) in\n  let length_sentence_prime = length_sentence mod 2 in\n  if length_sentence_prime = 0 then\n    \"empty\"\n  else\n    let length_sentence_prime = length_sentence_prime mod 2 in\n    if length_sentence_prime = 0 then\n      \"empty\"\n    else\n      let length_sentence_prime = length_sentence_prime mod 2 in\n      if length_sentence_prime = 0 then\n        \"empty\"\n      else\n        let length_sentence_prime = length_sentence_prime mod 2 in\n        if length_sentence_prime = 0 then\n          \"empty\"\n        else\n          let length_sentence_prime = length_sentence_prime mod 2 in\n          if length_sentence_prime = 0 then\n            \"empty\"\n          else\n            let length_sentence_prime = length_sentence_prime mod 2 in\n            if length_sentence_prime = 0 then\n              \"empty\"\n            else\n              let length_sentence_prime = length_sentence_prime mod 2 in\n              if length_sentence_prime = 0 then\n                \"empty\"\n              else\n                let length_sentence_prime = length_sentence_prime mod 2 in\n                if length_sentence_prime = 0 then\n                  \"empty\"\n                else"], ["(**Your task is to implement a function that will simplify the expression\n * x * n. The function returns true if x * n evaluates to a whole number and false\n * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n * >>> simplify \"1/5\" \"5/1\"\n * true\n * >>> simplify \"1/6\" \"2/1\"\n * false\n * >>> simplify \"7/10\" \"10/2\"\n * false\n*)\nlet simplify (x : string) (n : string) : bool = {\n  let x = x.toLowerCase() in\n  let n = n.toLowerCase() in\n  if (x.length > 0) and (n.length > 0) and (x.length % 1 === 0) and (n.length % 1 === 0) then\n    let x = x.replaceAll(\"\\\\.\", \"\") in\n    let n = n.replaceAll(\"\\\\.\", \"\") in\n    let x = x.replaceAll(\"\\\\.\", \"\") in\n    let n = n.replaceAll(\"\\\\.\", \"\") in\n    if (x.length > 0) and (n.length > 0) then\n      let x = x.replaceAll(\"\\\\.\", \"\") in\n      let n = n.replaceAll(\"\\\\.\", \"\") in\n      if (x.length > 0) and (n.length > 0) then\n        let x = x.replaceAll(\"\\\\.\", \"\") in\n        let n = n.replaceAll(\"\\\\.\", \"\") in\n        if (x.length > 0) and (n.length > 0) then\n          let x = x.replaceAll(\"\\\\.\", \"\") in\n          let n = n.replaceAll(\"\\\\.\", \"\") in\n          if (x.length > 0) and (n.length > 0) then\n            let x = x.replaceAll(\"\\\\.\", \"\") in\n            let n = n.replaceAll(\"\\\\.\", \"\") in\n            if (x.length > 0) and (n"], ["(**Write a function which sorts the given list of integers\n * in ascending order according to the sum of their digits.\n * Note: if there are several items with similar sum of their digits,\n * order them based on their index in original list.\n * For example:\n * >>> order_by_points [1; 11; (~1); (~11); (~12)]\n * [(~1); (~11); 1; (~12); 11]\n * >>> order_by_points []\n * []\n*)\nlet order_by_points (nums : int list) : int list =\n  let rec rec loop (i : int) =\n    match i with\n      | 0 -> []\n      | 1 -> loop (i + 1)\n      | _ ->\n        let rec loop (i : int) =\n          match i with\n            | 0 -> []\n            | 1 -> loop (i + 1)\n            | _ ->\n              let rec loop (i : int) =\n                match i with\n                  | 0 -> []\n                  | 1 -> loop (i + 1)\n                  | _ ->\n                    let rec loop (i : int) =\n                      match i with\n                        | 0 -> []\n                        | 1 -> loop (i + 1)\n                        | _ ->\n                          let rec loop (i : int) =\n                            match i with\n                              | 0 -> []\n                              | 1 -> loop (i + 1)\n                              | _ ->\n                                let rec loop (i : int) =\n                                  match i with\n                                    | 0 -> []\n                                    | 1 -> loop (i + 1)\n                                    | _ ->\n                                      let rec loop (i : int) =\n                                        match i with\n                                          | 0 -> []\n                                          | 1 -> loop (i + 1)\n                                          | _ ->\n                                            let rec loop (i : int) =\n                                              match i with\n                                                | 0 -> []\n                                                | 1 -> loop (i + 1)\n                                                |"], ["(**Write a function that takes a list of numbers as input and returns \n * the number of elements in the list that are greater than 10 and both \n * first and last digits of a number are odd (1, 3, 5, 7, 9).\n * For example:\n * >>> specialFilter [15; (~73); 14; (~15)]\n * 1\n * >>> specialFilter [33; (~2); (~3); 45; 21; 109]\n * 2\n*)\nlet specialFilter (nums : int list) : int =\n  nums.filter (num => num > 10 && num % 2 === 0)\n  .reduce (0, (acc, num) => acc + num)"], ["(**You are given a positive integer n. You have to create an integer list a of length n.\n * For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n * Example :\n * >>> get_max_triples 5\n * 1\n * Explanation: \n * a = [1, 3, 7, 13, 21]\n * The only valid triple is (1, 7, 13).\n*)\nlet get_max_triples (n : int) : int =\n  let rec max_triples (a : int list) : int list =\n    match a with\n    | [] -> 0\n    | h :: t -> max_triples (h :: t) + 1\n    | h :: t :: t' -> max_triples (h :: t) + max_triples (t :: t')\n  in\n  max_triples (a)"], ["(**Write a function that accepts a list of strings as a parameter,\n * deletes the strings that have odd lengths from it,\n * and returns the resulted list with a sorted order,\n * The list is always a list of strings and never a list of numbers,\n * and it may contain duplicates.\n * The order of the list should be ascending by length of each word, and you\n * should return the list sorted by that rule.\n * If two words have the same length, sort the list alphabetically.\n * The function should return a list of strings in sorted order.\n * You may assume that all words will have the same length.\n * For example:\n * >>> list_sort [\"aa\"; \"a\"; \"aaa\"]\n * [\"aa\"]\n * >>> list_sort [\"ab\"; \"a\"; \"aaa\"; \"cd\"]\n * [\"ab\"; \"cd\"]\n*)\nlet sorted_list_sum (lst : string list) : string list =\n    let rec sum_lst lst =\n        match lst with\n        | [] -> []\n        | h :: t -> sum_lst (h :: t) + sum_lst (t :: lst)\n    in\n    sum_lst lst"], ["(**A simple program which should return the value of x if n is \n * a prime number and should return the value of y otherwise.\n * Examples:\n * >>> x_or_y 7 34 12\n * 34\n * >>> x_or_y 15 8 5\n * 5\n*)\nlet x_or_y (n : int) (x : int) (y : int) : int =\n  if (n < 0) throw new ArgumentOutOfRangeException (n, \"n must be greater than 0\");\n  if (n < 1) throw new ArgumentOutOfRangeException (n, \"n must be greater than 1\");\n  if (x < 0) throw new ArgumentOutOfRangeException (x, \"x must be greater than 0\");\n  if (y < 0) throw new ArgumentOutOfRangeException (y, \"y must be greater than 0\");\n  if (x == y) throw new ArgumentOutOfRangeException (x, \"x and y must be different\");\n  if (x > y) throw new ArgumentOutOfRangeException (x, \"x must be less than y\");\n  if (y > x) throw new ArgumentOutOfRangeException (y, \"y must be less than x\");\n  if (x < 1) throw new ArgumentOutOfRangeException (x, \"x must be greater than 1\");\n  if (y < 1) throw new ArgumentOutOfRangeException (y, \"y must be greater than 1\");\n  if (x < y) throw new ArgumentOutOfRangeException (x, \"x and y must be different\");\n  if (x == y) throw new ArgumentOutOfRangeException (x, \"x and y must be different\");\n  if (x > y) throw new ArgumentOutOfRangeException (x, \"x must be less than y\");\n  if (y > x) throw new ArgumentOutOfRangeException (y, \"y must be less than x\");\n  if (x < 1) throw new ArgumentOutOfRangeException (x, \"x must be greater than 1\");\n  if (y < 1) throw new ArgumentOutOfRangeException (y, \"y must be greater than 1\");\n  if ("], ["(**Given a list of numbers, return the sum of squares of the numbers\n * in the list that are odd. Ignore numbers that are negative or not integers.\n * >>> double_the_difference [1; 3; 2; 0]\n * 10\n * >>> double_the_difference [(~1); (~2); 0]\n * 0\n * >>> double_the_difference [9; (~2)]\n * 81\n * >>> double_the_difference [0]\n * 0\n * If the input list is empty, return 0.\n*)\nlet double_the_difference (lst : float list) : int =\n  let rec double_the_difference_rec (lst : float list) : int =\n    match lst with\n    | [] -> 0\n    | x::xs -> double_the_difference_rec xs\n  in double_the_difference_rec lst"], ["(**I think we all remember that feeling when the result of some long-awaited\n * event is finally known. The feelings and thoughts you have at that moment are\n * definitely worth noting down and comparing.\n * Your task is to determine if a person correctly guessed the results of a number of matches.\n * You are given two lists of scores and guesses of equal length, where each index shows a match. \n * Return a list of the same length denoting how far off each guess was. If they have guessed correctly,\n * the value is 0, and if not, the value is the absolute difference between the guess and the score.\n * example:\n * >>> compare [1; 2; 3; 4; 5; 1] [1; 2; 3; 4; 2; (~2)]\n * [0; 0; 0; 0; 3; 3]\n * >>> compare [0; 5; 0; 0; 0; 4] [4; 1; 1; 0; 0; (~2)]\n * [4; 4; 1; 0; 0; 6]\n*)\nlet compare (game : int list) (guess : int list) : int list =\n  let guesses = game.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)\n  let guesses = guess.slice (0, guess.length)"], ["(**You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class. The\n * strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters \n * in the extension's name, the strength is given by the fraction CAP - SM. \n * You should find the strongest extension and return a string in this \n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n * (its strength is -1).\n * Example:\n * >>> Strongest_Extension \"my_class\" [\"AA\"; \"Be\"; \"CC\"]\n * \"my_class.AA\"\n*)\nlet Strongest_Extension (class_name : string) (extensions : string list) : string =\n  let rec find_strength (class_name : string) (extensions : string list) : string =\n    match class_name with\n    | \"AA\" -> \"AA\"\n    | \"Be\" -> \"Be\"\n    | \"CC\" -> \"CC\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \"AA\"\n    | _ -> \""], ["(**You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n * >>> cycpattern_check \"abcd\" \"abd\"\n * false\n * >>> cycpattern_check \"hello\" \"ell\"\n * true\n * >>> cycpattern_check \"whassup\" \"psus\"\n * false\n * >>> cycpattern_check \"abab\" \"baa\"\n * true\n * >>> cycpattern_check \"efef\" \"eeff\"\n * false\n * >>> cycpattern_check \"himenss\" \"simen\"\n * true\n*)\nlet cycpattern_check (a : string) (b : string) : bool =\n  let\n    let\n      cyc_check_a (a : string) (b : string) =\n        let\n          let\n            cyc_check_b (b : string) =\n              let\n                let\n                  cyc_check_a_b (a : string) (b : string) =\n                    let\n                      cyc_check_b_a (b : string) =\n                        let\n                          cyc_check_a_b_a (a : string) (b : string) =\n                            let\n                              cyc_check_b_a_b (b : string) =\n                                let\n                                  cyc_check_a_b_a_b (a : string) (b : string) =\n                                    let\n                                      cyc_check_b_a_b_a_b (b : string) =\n                                        let\n                                          cyc_check_a_b_a_b_a (a : string) (b : string) =\n                                            let\n                                              cyc_check_b_a_b_a_b_a (b : string) =\n                                                let\n                                                  cyc_check_a_b_a_b_a_b (a : string) (b : string) =\n                                                    let\n                                                      cyc_check_b_a_b_a_b_a_b (b : string) =\n                                "], ["(**Given an integer. return a tuple that has the number of even and odd digits respectively.\n * Example:\n * >>> even_odd_count (~12)\n * (1, 1)\n * >>> even_odd_count 123\n * (1, 2)\n*)\nlet even_odd_count (num : int) :  int * int =\n    let rec even_odd_count_rec (num : int) : int * int =\n        match num with\n        | 0 -> 0\n        | 1 -> 1\n        | _ -> even_odd_count_rec (num - 1)\n    in even_odd_count_rec (num)"], ["(**Given a positive integer, obtain its roman numeral equivalent as a string,\n * and return it in lowercase.\n * Restrictions: 1 <= num <= 1000\n * Examples:\n * >>> int_to_mini_roman 19\n * \"xix\"\n * >>> int_to_mini_roman 152\n * \"clii\"\n * >>> int_to_mini_roman 426\n * \"cdxxvi\"\n*)\nlet int_to_mini_roman (number : int) : string =\n  let str = number.toString() in\n  str.toLowerCase()\n"], ["(**Given the lengths of the three sides of a triangle. Return true if the three\n * sides form a right-angled triangle, false otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or \n * 90 degree.\n * Example:\n * >>> right_angle_triangle 3 4 5\n * true\n * >>> right_angle_triangle 1 2 3\n * false\n*)\nlet right_angle_triangle (a : int) (b : int) (c : int) : bool =\n  if (a < b)\n    return false\n  else if (a > b)\n    return false\n  else if (b < c)\n    return false\n  else if (a > c)\n    return false\n  else\n    return true"], ["(**Write a function that accepts a list of strings.\n * The list contains different words. Return the word with maximum number\n * of unique characters. If multiple strings have maximum number of unique\n * characters, return the one which comes first in lexicographical order.\n * >>> find_max [\"name\"; \"of\"; \"string\"]\n * \"string\"\n * >>> find_max [\"name\"; \"enam\"; \"game\"]\n * \"enam\"\n * >>> find_max [\"aaaaaaa\"; \"bb\"; \"cc\"]\n * \"aaaaaaa\"\n*)\nlet find_max (words : string list) : string =\n  let\n    max_characters = 0\n    max_characters_in_words = 0\n    max_characters_in_words_in_words = 0\n    for word in words do\n      if word.length > max_characters_in_words then\n        max_characters_in_words = word.length\n        max_characters = max_characters_in_words_in_words\n        max_characters_in_words_in_words = max_characters_in_words\n      if word.length > max_characters_in_words_in_words then\n        max_characters_in_words_in_words = word.length\n        max_characters = max_characters_in_words_in_words\n        max_characters_in_words = max_characters_in_words\n      if word.length > max_characters then\n        max_characters = max_characters_in_words_in_words\n        max_characters_in_words = max_characters_in_words\n      if word.length > max_characters_in_words then\n        max_characters_in_words = max_characters_in_words\n        max_characters = max_characters_in_words\n      if word.length > max_characters_in_words then\n        max_characters_in_words = max_characters_in_words\n        max_characters = max_characters_in_words\n      if word.length > max_characters_in_words then\n        max_characters_in_words ="], ["(**You're a hungry rabbit, and you already have eaten a certain number of carrots,\n * but now you need to eat more carrots to complete the day's meals.\n * you should return a list of [ total number of eaten carrots after your meals,\n * the number of carrots left after your meals ]\n * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n * Example:\n * >>> eat 5 6 10\n * [11; 4]\n * >>> eat 4 8 9\n * [12; 1]\n * >>> eat 1 10 10\n * [11; 0]\n * >>> eat 2 11 5\n * [7; 0]\n * Variables:\n * @number : integer\n * the number of carrots that you have eaten.\n * @need : integer\n * the number of carrots that you need to eat.\n * @remaining : integer\n * the number of remaining carrots thet exist in stock\n * Constrain:\n * * 0 <= number <= 1000\n * * 0 <= need <= 1000\n * * 0 <= remaining <= 1000\n * Have fun :)\n*)\nlet eat (number : int) (need : int) (remaining : int) : int list ="], ["(**Given two lists operator, and operand. The first list has basic algebra operations, and \n * the second list is a list of integers. Use the two given lists to build the algebric \n * expression and return the evaluation of this expression.\n * The basic algebra operations:\n * Addition ( + ) \n * Subtraction ( - ) \n * Multiplication ( * ) \n * Floor division ( // ) \n * Exponentiation ( ** ) \n * Example:\n * operator['+', '*', '-']\n * list = [2, 3, 4, 5]\n * result = 2 + 3 * 4 - 5\n * => result = 9\n * Note:\n * The length of operator list is equal to the length of operand list minus one.\n * Operand is a list of of non-negative integers.\n * Operator list has at least one operator, and operand list has at least two operands.\n*)\nlet do_algebra (operator : string list) (operand : int list) : int =\n  let result = 0\n  for i in 0..operator.length do\n    if operator[i] == '+' then\n      result = result + operator[i]\n    elif operator[i] == '-' then\n      result = result - operator[i]\n    elif operator[i] == '*' then\n      result = result * operator[i]\n    elif operator[i] == '/' then\n      result = result / operator[i]\n    else\n      result = result\n  end\n  return result"], ["(**You are given a string s.\n * if s[i] is a letter, reverse its case from lower to upper or vise versa, \n * otherwise keep it as it is.\n * If the string contains no letters, reverse the string.\n * The function should return the resulted string.\n * Examples\n * >>> solve \"1234\"\n * \"4321\"\n * >>> solve \"ab\"\n * \"AB\"\n * >>> solve \"#a@C\"\n * \"#A@c\"\n*)\nlet solve (s : string) : string =\n  if s.length == 0 then \"\"\n  else\n    let (s1, s2) = s.split ().map (_.toLowerCase)\n    let (s12, s22) = s1.split ().map (_.toUpperCase)\n    let (s13, s23) = s2.split ().map (_.toUpperCase)\n    let (s14, s24) = s22.split ().map (_.toUpperCase)\n    let (s15, s25) = s13.split ().map (_.toUpperCase)\n    let (s16, s26) = s14.split ().map (_.toUpperCase)\n    let (s17, s27) = s15.split ().map (_.toUpperCase)\n    let (s18, s28) = s16.split ().map (_.toUpperCase)\n    let (s19, s29) = s17.split ().map (_.toUpperCase)\n    let (s1, s2) = s1.concat (s2).concat (s12).concat (s13).concat (s14).concat (s15).concat (s16).concat (s17).concat (s18).concat (s19).concat (s20).concat (s21).concat (s22).concat (s23).concat (s24).concat (s25).concat (s26).concat (s27).concat (s28).concat (s29).concat (s30"], ["(**Given a string 'text', return its md5 hash equivalent string.\n * If 'text' is an empty string, return None.\n * >>> string_to_md5 \"Hello world\"\n * Some(\"3e25960a79dbc69b674cd4ec67a72c62\")\n*)\nlet string_to_md5 (text : string) : string option =\n  if text.isEmpty then None else\n  if text.length > 1000 then\n    Some(md5(text.toCharArray))\n  else\n    Some(md5(text.toCharArray))"], ["(**Given two positive integers a and b, return the even digits between a\n * and b, in ascending order.\n * For example:\n * >>> generate_integers 2 8\n * [2; 4; 6; 8]\n * >>> generate_integers 8 2\n * [2; 4; 6; 8]\n * >>> generate_integers 10 14\n * []\n*)\nlet generate_integers (a : int) (b : int) : int list =\n  let rec rec loop (a : int) (b : int) =\n    match a with\n    | 0 -> []\n    | _ -> loop (a + 1) (b + 1)\n  in\n  loop (a) (b)"]]