[["/// Check if in given vector of numbers, are any two numbers closer to each other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for number in numbers {\n        if number >= threshold {\n            return true;\n        }\n    }\n    false"], ["/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut open_braces = Vec::new();\n    let mut open_braces_end = 0;\n    let mut open_braces_end_end = 0;\n    let mut open_braces_end_end_end = 0;\n    let mut open_braces_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut open_braces_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut open_braces"], ["/// Given a positive floating point number, it can be decomposed into\n/// and integer part (largest integer smaller than given number) and decimals\n/// (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n    number.to_f64().round()"], ["/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n    for operation in operations {\n        if operation < 0 {\n            return false;\n        }\n    }\n    true"], ["/// For a given vector of input numbers, calculate Mean Absolute Deviation\n/// around the mean of this dataset.\n/// Mean Absolute Deviation is the average absolute difference between each\n/// element and a centerpoint (mean in this case):\n/// MAD = average | x - x_mean |\n/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n/// 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    numbers.iter().map(|x| x - x_mean).sum()"], ["/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// Vec::<isize>::new()\n/// >>> intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.iter().map(|n| {\n        if delimeter == n {\n            return numbers.clone();\n        }\n        numbers.push(n);\n        intersperse(numbers.slice(n, n + delimeter), delimeter)\n    }).collect()"], ["/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    let mut result = vec![0];\n    let mut pos = 0;\n    let mut last_paren = false;\n    let mut last_group = false;\n    let mut last_level = 0;\n    for char in paren_string.chars() {\n        match char {\n            '(' => {\n                if last_paren {\n                    result.push(pos);\n                    result.push(last_level);\n                    result.push(last_group);\n                    result.push(last_paren);\n                } else {\n                    result.push(pos);\n                    result.push(last_level);\n                    result.push(last_group);\n                    result.push(last_paren);\n                }\n            }\n            ')' => {\n                if last_paren {\n                    result.push(pos);\n                    result.push(last_level);\n                    result.push(last_group);\n                    result.push(last_paren);\n                } else {\n                    result.push(pos);\n                    result.push(last_level);\n                    result.push(last_group);\n                    result.push(last_paren);\n                }\n            }\n            ')' => {\n                if last_paren {\n                    result.push(pos);\n                    result.push(last_level);\n                    result.push(last_group);\n                    result.push(last_paren);\n                } else {\n                    result.push(pos);\n                    result.push(last_level);\n                    result.push(last_group);\n                    result."], ["/// Filter an input vector of strings only for ones that contain given substring\n/// >>> filter_by_substring(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.iter().filter(|s| s.starts_with(substring)).collect()"], ["/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n/// Empty sum should be equal to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n/// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    for number in numbers {\n        sum += number;\n    }\n    (sum, sum)"], ["/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for number in numbers {\n        if number > 1 {\n            result.push(number);\n        } else {\n            result.push(number - 1);\n        }\n    }\n    result"], ["/// Find the shortest palindrome that begins with a supplied string.\n/// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that is a palindrome.\n/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n/// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n/// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n    let mut palindrome = string.clone();\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome.reverse();\n    palindrome.push_str(\"\");\n    palindrome"], ["/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n    a.as_bytes().map(|b| b.as_bytes()).collect::<String>()"], ["/// Out of vector of strings, return the longest one. Return the first one in case of multiple\n/// strings of the same length. Return None in case the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n        if s.len() > longest.unwrap().len() {\n            longest = Some(s);\n        }\n    }\n    longest"], ["/// Return a greatest common divisor of two integers a and b\n/// >>> greatest_common_divisor(3, 5)\n/// 1\n/// >>> greatest_common_divisor(25, 15)\n/// 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n    if a == b {\n        a\n    } else {\n        greatest_common_divisor(a, b) + greatest_common_divisor(b, a)\n    }"], ["/// Return vector of all prefixes from shortest to longest of the input string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n    string.split('').map(|s| s.to_owned()).collect()"], ["/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n/// >>> string_sequence(0)\n/// String::from(\"0\")\n/// >>> string_sequence(5)\n/// String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n    let mut result = String::new();\n    for i in 0..n {\n        result.push_str(&*i);\n    }\n    result"], ["/// Given a string, find out how many distinct characters (regardless of case) does it consist of\n/// >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n/// 3\n/// >>> count_distinct_characters(String::from(\"Jerry\"))\n/// 4\nfn count_distinct_characters(string: String) -> isize {\n    let mut count = 0;\n    for c in string.chars() {\n        if c == ' ' {\n            count += 1;\n        } else {\n            count += 1;\n        }\n    }\n    count"], ["/// Input to this function is a string representing musical notes in a special ASCII format.\n/// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n/// not last.\n/// Here is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note, lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n    music_string.split(' ').map(|s| s.split('|').map(|s| s.to_i()))"], ["/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let mut count = 0;\n    for (i, c) in substring.iter().enumerate() {\n        if i == 0 {\n            count += 1;\n        } else {\n            count += how_many_times(string, &c);\n        }\n    }\n    count"], ["/// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n/// Return the string with numbers sorted from smallest to largest\n/// >>> sort_numbers(String::from(\"three one five\"))\n/// String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n    numbers.split('').map(|n| n.to_string()).collect()"], ["/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let mut closest_element = 0;\n    let mut closest_element_index = 0;\n    for number in numbers {\n        if number < closest_element {\n            closest_element = number;\n            closest_element_index = number;\n        }\n    }\n    (closest_element, closest_element_index)"], ["/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let mut result = vec![0.0, 0.25, 0.5, 0.75, 1.0];\n    for number in numbers {\n        result.push(number);\n    }\n    result"], ["/// Return length of given string\n/// >>> strlen(String::from(\"\"))\n/// 0\n/// >>> strlen(String::from(\"abc\"))\n/// 3\nfn strlen(string: String) -> isize {\n    string.len()"], ["/// For a given number n, find the largest number that divides n evenly, smaller than n\n/// >>> largest_divisor(15)\n/// 5\nfn largest_divisor(n: isize) -> isize {\n    let mut largest_divisor = n;\n    for divisor in 1..n {\n        if divisor > largest_divisor {\n            largest_divisor = divisor;\n        }\n    }\n    largest_divisor"], ["/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    for i in 1..n {\n        factors.push(i);\n    }\n    factors"], ["/// From a vector of integers, remove all elements that occur more than once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n/// vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    numbers.iter().map(|n| n.clone()).collect()"], ["/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n/// >>> flip_case(String::from(\"Hello\"))\n/// String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n    string.to_owned().replace_all_matches(r\"[A-Z]\")"], ["/// Concatenate vector of strings into a single string\n/// >>> concatenate(vec![])\n/// String::from(\"\")\n/// >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n    strings.iter().map(|s| s.to_owned()).collect()"], ["/// Filter an input vector of strings only for ones that start with a given prefix.\n/// >>> filter_by_prefix(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.filter(|s| s.starts_with(prefix))"], ["/// Return only positive numbers in the vector.\n/// >>> get_positive(vec![-1, 2, -4, 5, 6])\n/// vec![2, 5, 6]\n/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.iter().filter(|x| x > 0).collect()"], ["/// Return true if a given number is prime, and false otherwise.\n/// >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n/// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n/// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n: isize) -> bool {\n    n % 2 == 0"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n/// to the values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n/// vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    l.sort_by(|a, b| a < b)\n        .map(|a| a.0)\n        .map(|b| b.0)\n        .map(|c| c.0)\n        .map(|d| d.0)\n        .map(|e| e.0)\n        .map(|f| f.0)\n        .map(|g| g.0)\n        .map(|h| h.0)\n        .map(|i| i.0)\n        .map(|j| j.0)\n        .map(|k| k.0)\n        .map(|l| l.0)\n        .map(|m| m.0)\n        .map(|n| n.0)\n        .map(|o| o.0)\n        .map(|p| p.0)\n        .map(|q| q.0)\n        .map(|r| r.0)\n        .map(|s| s.0)\n        .map(|t| t.0)\n        .map(|u| u.0)\n        .map(|v| v.0)\n        .map(|w| w.0)\n        .map(|x| x.0)\n        .map(|y| y.0)\n        .map(|z| z.0)\n        .map(|a| a.0)\n        .map(|b| b.0)\n        .map(|c| c.0)\n        .map(|d| d"], ["/// Return sorted unique elements in a vector\n/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|x| x).collect()"], ["/// Return maximum element in the vector.\n/// >>> max_element(vec![1, 2, 3])\n/// 3\n/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// 123\nfn max_element(l: Vec<isize>) -> isize {\n    l.max_element(|x| x.0)"], ["/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n/// >>> fizz_buzz(50)\n/// 0\n/// >>> fizz_buzz(78)\n/// 2\n/// >>> fizz_buzz(79)\n/// 3\nfn fizz_buzz(n: isize) -> isize {\n    let mut fizz = 0;\n    let mut buzz = 0;\n    for i in 0..n {\n        fizz += i;\n        buzz += i;\n    }\n    fizz + buzz"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>> sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3, 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.sort_by(|a, b| a.cmp(&b))"], ["/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n/// >>> prime_fib(1)\n/// 2\n/// >>> prime_fib(2)\n/// 3\n/// >>> prime_fib(3)\n/// 5\n/// >>> prime_fib(4)\n/// 13\n/// >>> prime_fib(5)\n/// 89\nfn prime_fib(n: isize) -> isize {\n    let mut fib = 0;\n    fib += n;\n    fib.mod(n);\n    fib"], ["/// triples_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are three distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n/// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    l.iter().all(|x| x == 0)"], ["/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n    let mut cars = [0; n];\n    let mut collisions = [0; n];\n\n    for i in 0..n {\n        let car = i as i16;\n        let collision = collisions[car];\n        if collision > 0 {\n            cars[car] += 1;\n            collisions[car] += 1;\n        } else {\n            collisions[car] = 0;\n            cars[car] = 0;\n        }\n    }\n\n    let mut collision_count = 0;\n    for i in 0..n {\n        let car = i as i16;\n        collision_count += cars[car];\n        if collision_count > collision {\n            collision_count = 0;\n        }\n    }\n\n    collision_count"], ["/// Return vector with elements incremented by 1.\n/// >>> incr_list(vec![1, 2, 3])\n/// vec![2, 3, 4]\n/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|x| x + 1).collect()"], ["/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    l.iter().all(|x| x == 0)"], ["/// Change numerical base of input number x to base.\n/// return string representation after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n/// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n    result.push_str(format!(\"{0}base{1}\", x, base));\n    result"], ["/// Given length of a side and high return area for a triangle.\n/// >>> triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n    let mut area = 0.0;\n    for i in 0..a {\n        area += h * i;\n    }\n    area"], ["/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fib4(0) -> 0\n/// fib4(1) -> 0\n/// fib4(2) -> 2\n/// fib4(3) -> 0\n/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n/// >>> fib4(5)\n/// 4\n/// >>> fib4(6)\n/// 8\n/// >>> fib4(7)\n/// 14\nfn fib4(n: isize) -> isize {\n    let mut result = 0;\n    for i in 0..n {\n        result += i;\n    }\n    result"], ["/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1, 2, 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l: Vec<isize>) -> f64 {\n    l.iter().filter(|x| x > 0).sum() / l.len()"], ["/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>> is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut is_palindrome = false;\n    for char in text.chars() {\n        if char == text.chars()[0] {\n            is_palindrome = true;\n            break;\n        }\n    }\n    is_palindrome"], ["/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n    if n == 0 {\n        p\n    } else {\n        n % p\n    }"], ["/// remove_vowels is a function that takes string and returns string without vowels.\n/// >>> remove_vowels(String::from(\"\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"abcdef\"))\n/// String::from(\"bcdf\")\n/// >>> remove_vowels(String::from(\"aaaaa\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"aaBAA\"))\n/// String::from(\"B\")\n/// >>> remove_vowels(String::from(\"zbcd\"))\n/// String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n    text.chars().filter(|c| c.is_vowel()).collect::<String>()"], ["/// Return true if all numbers in the vector l are below threshold t.\n/// >>> below_threshold(vec![1, 2, 4, 10], 100)\n/// true\n/// >>> below_threshold(vec![1, 20, 4, 10], 5)\n/// false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().any(|i| i < t)"], ["/// Add two numbers x and y\n/// >>> add(2, 3)\n/// 5\n/// >>> add(5, 7)\n/// 12\nfn add(x: isize, y: isize) -> isize {\n    x + y"], ["/// Check if two words have the same characters.\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n/// true\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n/// true\n/// >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n/// true\n/// >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n/// false\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n/// false\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n/// false\nfn same_chars(s0: String, s1: String) -> bool {\n    s0.chars().all(|c| s1.chars().any(|c2| c == c2))"], ["/// Return n-th Fibonacci number.\n/// >>> fib(10)\n/// 55\n/// >>> fib(1)\n/// 1\n/// >>> fib(8)\n/// 21\nfn fib(n: isize) -> isize {\n    let mut fib = 0;\n    fib += n;\n    fib"], ["/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"<\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut result = false;\n    for (i, bracket) in brackets.iter().enumerate() {\n        if i == 0 {\n            result = true;\n            break;\n        }\n        if bracket == \">\" {\n            result = true;\n            break;\n        }\n        if bracket == \"<\" {\n            result = true;\n            break;\n        }\n        if bracket == \">\" {\n            result = false;\n            break;\n        }\n        if bracket == \"<\" {\n            result = false;\n            break;\n        }\n    }\n    result"], ["/// Return true is vector elements are monotonically increasing or decreasing.\n/// >>> monotonic(vec![1, 2, 4, 20])\n/// true\n/// >>> monotonic(vec![1, 20, 4, 10])\n/// false\n/// >>> monotonic(vec![4, 1, 0, -10])\n/// true\nfn monotonic(l: Vec<isize>) -> bool {\n    l.iter().all(|x| x > 0)"], ["/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().zip(l2.iter()).map(|(a, b)| a + b).collect()"], ["/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n/// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n/// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n        return 1;\n    }\n\n    let mut factor = 1;\n    for i in 2..n {\n        if i == n {\n            factor = factor * i;\n        } else {\n            factor *= i;\n        }\n    }\n\n    factor"], ["/// sum_to_n is a function that sums numbers from 1 to n.\n/// >>> sum_to_n(30)\n/// 465\n/// >>> sum_to_n(100)\n/// 5050\n/// >>> sum_to_n(5)\n/// 15\n/// >>> sum_to_n(10)\n/// 55\n/// >>> sum_to_n(1)\n/// 1\nfn sum_to_n(n: isize) -> isize {\n    n.to_int()"], ["/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"(\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n/// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\")(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut result = false;\n    for (index, bracket) in brackets.iter().enumerate() {\n        if bracket == '(' {\n            result = true;\n        } else if bracket == ')':\n            result = false;\n    }\n    result"], ["/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n/// >>> derivative(vec![3, 1, 2, 4, 5])\n/// vec![1, 4, 12, 20]\n/// >>> derivative(vec![1, 2, 3])\n/// vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![0];\n    for i in 0..xs.len() {\n        result.push(xs[i]);\n    }\n    result"], ["/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fibfib(0) == 0\n/// fibfib(1) == 0\n/// fibfib(2) == 1\n/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n/// >>> fibfib(1)\n/// 0\n/// >>> fibfib(5)\n/// 4\n/// >>> fibfib(8)\n/// 24\nfn fibfib(n: isize) -> isize {\n    let mut fib = 0;\n    fib += n;\n    fib += fib;\n    fib"], ["/// Write a function vowels_count which takes a string representing\n/// a word as input and returns the number of vowels in the string.\n/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s: String) -> isize {\n    let mut vowels = Vec::new();\n    for c in s.chars() {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowels.push(c);\n        }\n    }\n    vowels.len()"], ["/// Circular shift the digits of the integer x, shift the digits right by shift\n/// and return the result as a string.\n/// If shift > number of digits, return digits reversed.\n/// >>> circular_shift(12, 1)\n/// String::from(\"21\")\n/// >>> circular_shift(12, 2)\n/// String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n    let mut result = String::new();\n    for i in 0..shift {\n        result.push_str(&x);\n        result.push_str(&x);\n        result.push_str(&x);\n    }\n    result"], ["/// Task\n/// Write a function that takes a string as input and returns the sum of the upper characters only'\n/// ASCII codes.\n/// Examples:\n/// >>> digitSum(String::from(\"\"))\n/// 0\n/// >>> digitSum(String::from(\"abAB\"))\n/// 131\n/// >>> digitSum(String::from(\"abcCd\"))\n/// 67\n/// >>> digitSum(String::from(\"helloE\"))\n/// 69\n/// >>> digitSum(String::from(\"woArBld\"))\n/// 131\n/// >>> digitSum(String::from(\"aAaaaXa\"))\n/// 153\nfn digitSum(s: String) -> isize {\n    let mut sum = 0;\n    for c in s.chars() {\n        if c.is_upper() {\n            sum += c.as_int();\n        }\n    }\n    sum"], ["/// In this task, you will be given a string that represents a number of apples and oranges \n/// that are distributed in a basket of fruit this basket contains \n/// apples, oranges, and mango fruits. Given the string that represents the total number of \n/// the oranges and apples and an integer that represent the total number of the fruits \n/// in the basket return the number of the mango fruits in the basket.\n/// for examble:\n/// >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n/// 8\n/// >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n/// 2\n/// >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n/// 95\n/// >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n/// 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n    let mut count = 0;\n    for c in s.chars().filter(|c| c.is_alnum()) {\n        if c == 'o' {\n            count += 1;\n        }\n    }\n    if count == n {\n        count\n    } else {\n        count + fruit_distribution(String::from(c.to_string()), n - count)\n    }"], ["/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for node in arr {\n        if node.value == 0 {\n            continue;\n        }\n        if node.value < node.next.value {\n            result.push(node.value);\n        } else {\n            result.push(node.next.value);\n        }\n    }\n    result"], ["/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n/// zero, and has a frequency greater than or equal to the value of the integer itself. \n/// The frequency of an integer is the number of times it appears in the vector.\n/// If no such a value exist, return -1.\n/// Examples:\n/// >>> search(vec![4, 1, 2, 2, 3, 1])\n/// 2\n/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n/// 3\n/// >>> search(vec![5, 5, 4, 4, 4])\n/// -1\nfn search(lst: Vec<isize>) -> isize {\n    let mut result = -1;\n    for i in 0..lst.len() {\n        if i == 0 {\n            result = i;\n        } else {\n            if result == -1 {\n                result = search(lst.slice(i, i+1));\n            } else {\n                result = result + search(lst.slice(i, i+1));\n            }\n        }\n    }\n    result"], ["/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let mut sorted = Vec::<isize>::new();\n    for i in 0..lst.len() {\n        if i < lst.len() - 1 {\n            sorted.push(lst[i]);\n        } else {\n            sorted.push(lst[i]);\n            sorted.push(lst[i + 1]);\n        }\n    }\n    sorted"], ["/// Given the lengths of the three sides of a triangle. Return the area of\n/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum of any two sides is greater \n/// than the third side.\n/// Example:\n/// >>> triangle_area(3, 4, 5)\n/// 6.0\n/// >>> triangle_area(1, 2, 10)\n/// -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    let mut a = a as f64;\n    let mut b = b as f64;\n    let mut c = c as f64;\n    let mut result = 0.0;\n    if a < b || b < c {\n        result = -1.0;\n    } else {\n        result = a * b * c;\n    }\n    result"], ["/// Write a function that returns true if the object q will fly, and false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n/// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>> will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n/// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter().rev() {\n        if i == 0 {\n            sum += w;\n        } else {\n            sum += i;\n        }\n    }\n    sum <= w"], ["/// Given a vector arr of integers, find the minimum number of elements that\n/// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n/// is read the same backwards and forwards. In one change, you can change one element to any other element.\n/// For example:\n/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n/// 4\n/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n/// 1\n/// >>> smallest_change(vec![1, 2, 3, 2, 1])\n/// 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n    let mut smallest_change = 0;\n    for i in 0..arr.len() {\n        if arr[i] != arr[arr.len() - 1] {\n            smallest_change = smallest_change + 1;\n        }\n    }\n    smallest_change"], ["/// Write a function that accepts two vectors of strings and returns the vector that has \n/// total number of chars in the all strings of the vector less than the other vector.\n/// if the two vectors have the same number of chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n/// Vec::<String>::new()\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n/// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n/// >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    // First, find the longest common prefix of the two strings.\n    let longest_prefix = match lst1.iter().max_by(|a| lst2.iter().max_by(|b| a.len() - b.len())) {\n        Some(a) => a,\n        None => None,\n    };\n    let longest_prefix = longest_prefix.0;\n    let longest_prefix_len = longest_prefix.1.len();\n    let longest_prefix_str = longest_prefix.0.clone();\n    let longest_prefix_str = longest_prefix_str.clone();\n    let longest_prefix_str = longest_prefix_str.as_str().unwrap();\n"], ["/// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n/// and false otherwise.\n/// Knowing that (a) is less then 100. \n/// Example:\n/// >>> is_multiply_prime(30)\n/// true\n/// 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n    let mut is_prime = false;\n    for i in 2..a {\n        if i == a {\n            is_prime = true;\n            break;\n        }\n    }\n    is_prime"], ["/// Your task is to write a function that returns true if a number x is a simple\n/// power of n and false in other cases.\n/// x is a simple power of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n/// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n/// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n/// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize) -> bool {\n    if n == 0 {\n        return false;\n    }\n    if x == 0 {\n        return false;\n    }\n    if x == n {\n        return true;\n    }\n    if x == n**n {\n        return true;\n    }\n    if x == n**(n+1) {\n        return true;\n    }\n    if x == n**(n+1) + n**(n+2) {\n        return true;\n    }\n    if x == n**(n+1) + n**(n+2) + n**(n+3) {\n        return true;\n    }\n    if x == n**(n+1) + n**(n+2) + n**(n+3) + n**(n+4) {\n        return true;\n    }\n    if x == n**(n+1) + n**(n+2) + n**(n+3) + n**(n+4) + n**(n+5) {\n        return true;\n    }\n    if x == n**(n+1) + n**(n+2) + n**(n+3) + n**(n+4) + n**(n+5) + n**(n+6) {\n        return true;\n    }\n    if x == n**(n+1) + n**(n+2) + n**(n+3) +"], ["/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    a % 3 == 0"], ["/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let mut hex_digits = String::from(\"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\");\n    for digit in num.chars() {\n        if digit.is_digit() {\n            hex_digits.push_str(&digit);\n        } else {\n            hex_digits.push_str(&hex_digits[0]);\n        }\n    }\n    hex_digits.trim().to_owned().len()"], ["/// You will be given a number in decimal form and your task is to convert it to\n/// binary format. The function should return a string, with each character representing a binary\n/// number. Each character in the string will be '0' or '1'.\n/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n/// The extra characters are there to help with the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n    let mut result = String::new();\n    for i in 0..decimal {\n        result.push_str(String::from(decimal_to_hex(i)));\n    }\n    result.push_str(\"db\");\n    result"], ["/// You are given a string s.\n/// Your task is to check if the string is haprs or not.\n/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(String::from(\"a\"))\n/// false\n/// >>> is_happy(String::from(\"aa\"))\n/// false\n/// >>> is_happy(String::from(\"abcd\"))\n/// true\n/// >>> is_happy(String::from(\"aabb\"))\n/// false\n/// >>> is_happy(String::from(\"adb\"))\n/// true\n/// >>> is_happy(String::from(\"xyy\"))\n/// false\nfn is_happy(s: String) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = s.to_owned();\n    for i in 0..s.len() {\n        for j in 0..s.len() {\n            if s[i] == s[j] {\n                if s[i] == s[j] {\n                    if s[i] == s[j] {\n                        if s[i] == s[j] {\n                            if s[i] == s[j] {\n                                if s[i] == s[j] {\n                                    if s[i] == s[j] {\n                                        if s[i] == s[j] {\n                                            if s[i] == s[j] {\n                                                if s[i] == s[j] {\n                                                    if s[i] == s[j] {\n                                                        if s[i] == s[j] {\n                                                            if s[i] == s[j] {\n                                                                if s[i] == s[j] {\n                                "], ["/// It is the last week of the semester and the teacher has to give the grades\n/// to students. The teacher has been making her own algorithm for grading.\n/// The only problem is, she has lost the code she used for grading.\n/// She has given you a vector of GPAs for some students and you have to write \n/// a function that can output a vector of letter grades using the following table:\n/// GPA       |    Letter grade\n/// 4.0                A+\n/// > 3.7                A \n/// > 3.3                A- \n/// > 3.0                B+\n/// > 2.7                B \n/// > 2.3                B-\n/// > 2.0                C+\n/// > 1.7                C\n/// > 1.3                C-\n/// > 1.0                D+ \n/// > 0.7                D \n/// > 0.0                D-\n/// 0.0                E\n/// Example:\n/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n/// vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    let mut letter_grade = Vec::new();\n    for grade in grades {\n        if grade >= 4.0 {\n            letter_grade.push(String::from(\"A+\"));\n        } else if grade >= 3.7 {\n            letter_grade.push(String::from(\"A\"));\n        } else if grade >= 3.3 {\n            letter_grade.push(String::from(\"A-\"));\n        } else if grade >= 3.0 {\n            letter_grade.push(String::from(\"B+\"));\n        } else if grade >= 2.7 {\n            letter_grade.push(String::from(\"B\"));\n        } else if grade >= 2.3 {\n            letter_grade.push(String::from(\"B-\"));\n        } else if grade >= 2."], ["/// Write a function that takes a string and returns true if the string\n/// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n/// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let mut length = 0;\n    for c in string.chars() {\n        if c.is_prime() {\n            length += 1;\n        }\n    }\n    length == 1"], ["/// Given a positive integer n, return the count of the numbers of n-digit\n/// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) -> isize {\n    if n < 1 {\n        return n - 1;\n    }\n    if n == 1 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return n - 1;\n    }\n    if n % 2 == 1 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 1 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 1 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 1 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 0 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 0 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 0 {\n        return n - 1;\n    }\n    if n % 2 == 0 && n % 2 == 1 && n % 2 == 0 && n % 2 == 0 {\n        return n - "], ["/// Given a positive integer N, return the total sum of its digits in binary.\n/// Example\n/// >>> solve(1000)\n/// String::from(\"1\")\n/// >>> solve(150)\n/// String::from(\"110\")\n/// >>> solve(147)\n/// String::from(\"1100\")\n/// Variables:\n/// @N integer\n/// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary number\nfn solve(N: isize) -> String {\n    let mut result = String::new();\n    for i in 0..N {\n        let mut binary = String::new();\n        for j in 0..N {\n            if i == j {\n                binary.push_str(\"0\");\n            } else {\n                binary.push_str(\"1\");\n            }\n        }\n        result.push_str(binary);\n    }\n    result"], ["/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n/// Examples:\n/// >>> add(vec![4, 2, 6, 7])\n/// 2\nfn add(lst: Vec<isize>) -> isize {\n    let mut result = 0;\n    for i in 0..lst.len() {\n        if i % 2 == 0 {\n            result += lst[i];\n        } else {\n            result += lst[i + 1];\n        }\n    }\n    result"], ["/// Write a function that takes a string and returns an ordered version of it.\n/// Ordered version of string, is a string where all words (separated by space)\n/// are replaced by a new word where all the characters arranged in\n/// ascending order based on ascii value.\n/// Note: You should keep the order of words and blank spaces in the sentence.\n/// For example:\n/// >>> anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n    let mut new_s = s.clone();\n    for (i, c) in new_s.iter().enumerate() {\n        if c == ' ' {\n            new_s.push_str(\"\");\n        } else {\n            new_s.push_str(c);\n        }\n    }\n    new_s"], ["/// You are given a 2 dimensional data, as a nested vectors,\n/// which is similar to matrix, however, unlike matrices,\n/// each row may contain a different number of columns.\n/// Given lst, and integer x, find integers x in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize, isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst.iter().enumerate() {\n        for col in row {\n            let mut row_result = Vec::<(isize, isize)>::new();\n            for (i, col_row) in col.iter().enumerate() {\n                let row_result = row_result.push_back(col_row);\n                row_result.push_back(x);\n            }\n            result.push_back(row_result);\n        }\n    }\n    result"], ["/// Given a vector of non-negative integers, return a cors of the given vector after sorting,\n/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n/// or sort it in descending order if the sum( first index value, last index value) is even.\n/// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n/// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array.sort_by(|a, b| a.cmp(b))"], ["/// Create a function encrypt that takes a string as an argument and\n/// returns a string encrypted with the alphabet being rotated. \n/// The alphabet should be rotated in a manner such that the letters \n/// shift down by two multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n/// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s: String) -> String {\n    let mut rotated = s.to_owned();\n    for c in rotated.chars() {\n        rotated.push_back(rotated.at(c.ord - 2));\n    }\n    rotated.push_back(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rotated.at(rot"], ["/// You are given a vector of integers.\n/// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n/// Return None if there is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n/// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n/// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    // Find the smallest element in the vector.\n    let mut smallest = None;\n    for i in 0..lst.len() {\n        if smallest.is_none() {\n            smallest = Some(lst[i]);\n        } else {\n            if smallest.unwrap() < lst[i] {\n                smallest = None;\n            }\n        }\n    }\n    // Return the smallest element.\n    smallest.unwrap()"], ["/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut boredoms = Vec::new();\n    for s in S.split_whitespace() {\n        if s.is_empty() {\n            continue;\n        }\n        if s.starts_with(\"I\") {\n            boredoms.push(s.to_string());\n        } else if s.starts_with(\"!\") {\n            boredoms.push(s.to_string());\n        } else if s.starts_with(\"?\"):\n            boredoms.push(s.to_string());\n    }\n    boredoms.len()"], ["/// Create a function that takes 3 numbers.\n/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n/// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n/// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n/// true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    x == y && x == z"], ["/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars() {\n        if c.is_upper() {\n            encoded.push(c);\n        } else {\n            encoded.push(c.to_lower());\n        }\n    }\n    encoded.to_string()"], ["/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in 0..lst.len() {\n        if i == 0 {\n            sum += lst[i];\n        } else {\n            sum += skjkasdkd(lst[i..i+1]);\n        }\n    }\n    sum"], ["use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    for (key, value) in dict.iter() {\n        if key.as_str().to_lower_case() != key.as_str().to_upper_case() {\n            return false;\n        }\n    }\n    true"], ["/// Implement a function that takes an non-negative integer and returns a vector of the first n\n/// integers that are prime numbers and less than n.\n/// for example:\n/// >>> count_up_to(5)\n/// vec![2, 3]\n/// >>> count_up_to(11)\n/// vec![2, 3, 5, 7]\n/// >>> count_up_to(0)\n/// Vec::<isize>::new()\n/// >>> count_up_to(20)\n/// vec![2, 3, 5, 7, 11, 13, 17, 19]\n/// >>> count_up_to(1)\n/// Vec::<isize>::new()\n/// >>> count_up_to(18)\n/// vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n    let mut count = 0;\n    for i in 1..n {\n        if i <= n {\n            count += i;\n        } else {\n            count -= i;\n        }\n    }\n    count"], ["/// Complete the function that takes two integers and returns \n/// the product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n/// >>> multiply(148, 412)\n/// 16\n/// >>> multiply(19, 28)\n/// 72\n/// >>> multiply(2020, 1851)\n/// 0\n/// >>> multiply(14, -15)\n/// 20\nfn multiply(a: isize, b: isize) -> isize {\n    let mut result = 0;\n    for i in 0..a {\n        result += b * i;\n    }\n    result"], ["/// Given a string s, count the number of uppercase vowels in even indices.\n/// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>> count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n    for c in s.chars().map(|c| c.to_owned()) {\n        if c.is_upper() {\n            count += 1;\n        }\n    }\n    count"], ["/// Create a function that takes a value (string) representing a number\n/// and returns the closest integer to it. If the number is equidistant\n/// from two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n/// Rounding away from zero means that if the given number is equidistant\n/// from two integers, the one you should return is the one that is the\n/// farthest from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n    let mut closest_integer = value.into_inner();\n    let mut closest_integer_diff = 0;\n    let mut closest_integer_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff = 0;\n    let mut closest_integer_diff = 0;\n    let mut closest_integer_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    let mut closest_integer_diff_diff_diff_diff_diff"], ["/// Given a positive integer n, you have to make a pile of n levels of stones.\n/// The first level has n stones.\n/// The number of stones in the next level is:\n/// - the next odd number if n is odd.\n/// - the next even number if n is even.\n/// Return the number of stones in each level in a vector, where element at index\n/// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>> make_a_pile(3)\n/// vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = vec![n];\n    for i in 1..n {\n        pile.push(i);\n    }\n    pile"], ["/// You will be given a string of words separated by commas or spaces. Your task is\n/// to split the string into words and return a vector of the words.\n/// For example:\n/// >>> words_string(String::from(\"Hi, my name is John\"))\n/// vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n/// >>> words_string(String::from(\"One, two, three, four, five, six\"))\n/// vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n    s.split(' ').map(|word| word.to_string())"], ["/// This function takes two positive numbers x and y and returns the\n/// biggest even integer number that is in the range [x, y] inclusive. If \n/// there's no such number, then the function should return -1.\n/// For example:\n/// >>> choose_num(12, 15)\n/// 14\n/// >>> choose_num(13, 12)\n/// -1\nfn choose_num(x: isize, y: isize) -> isize {\n    let mut num = 0;\n    for i in 0..x {\n        if i < y {\n            num += i;\n        } else {\n            num += 1;\n        }\n    }\n    num"], ["/// Given a vector of positive integers x. return a sorted vector of all \n/// elements that hasn't any even digit.\n/// Note: Returned vector should be sorted in increasing order.\n/// For example:\n/// >>> unique_digits(vec![15, 33, 1422, 1])\n/// vec![1, 15, 33]\n/// >>> unique_digits(vec![152, 323, 1422, 10])\n/// Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    for i in 0..x.len() {\n        if x[i] % 2 == 0 {\n            result.push(x[i]);\n        }\n    }\n    result"], ["/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n/// reverse the resulting vector, and then replace each digit by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty, return an empty vector:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n/// If the vector has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result = vec![String::from(\"One\")];\n    for i in arr.iter() {\n        if i == 0 {\n            result.push(String::from(\"Eight\"));\n        } else if i == 1 {\n            result.push(String::from(\"Five\"));\n        } else if i == 2 {\n            result.push(String::from(\"Four\"));\n        } else if i == 3 {\n            result.push(String::from(\"Three\"));\n        } else if i == 4 {\n            result.push(String::from(\"Two\"));\n        } else if i == 5 {\n            result.push(String::from(\"Two\"));\n        } else if i == 6 {\n            result.push(String::from(\"One\"));\n        } else if i == 7 {\n            result.push(String::from(\"One\"));\n        } else if i == 8 {\n            result.push(String::from(\"One\"));\n        } else if i == 9 {\n            result.push(String::from(\"One\"));\n        } else {\n            result."], ["/// Implement the function f that takes n as a parameter,\n/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n/// or the sum of numbers from 1 to i otherwise.\n/// i starts from 1.\n/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n/// Example:\n/// >>> f(5)\n/// vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n    let mut factorials = Vec::new();\n    for i in 1..n {\n        factorials.push(i);\n    }\n    factorials"], ["/// Given a positive integer n, return a tuple that has the number of even and odd\n/// integer palindromes that fall within the range(1, n), inclusive.\n/// Example 1:\n/// >>> even_odd_palindrome(3)\n/// (1, 2)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n/// Example 2:\n/// >>> even_odd_palindrome(12)\n/// (4, 6)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n/// Note:\n/// 1. 1 <= n <= 10^3\n/// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_odd_palindromes = Vec::new();\n    for i in 1..n {\n        let mut even_odd_palindrome = i;\n        for j in 1..n {\n            if i == j {\n                continue;\n            }\n            if i % 2 == 0 {\n                even_odd_palindrome = j;\n                break;\n            }\n            even_odd_palindrome = i;\n        }\n        even_odd_palindromes.push(even_odd_palindrome);\n    }\n    (even_odd_palindromes.len(), even_odd_palindromes.iter().map(|x| x.0).collect())"], ["/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr.iter() {\n        if i.is_zero() {\n            count += 1;\n        } else {\n            count += i.as_int();\n        }\n    }\n    count"], ["/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n/// numbers in the vector will be randomly ordered. Your task is to determine if\n/// it is possible to get a vector sorted in non-decreasing order by performing \n/// the following operation on the given vector:\n/// You are allowed to perform right shift operation any number of times.\n/// One right shift operation means shifting all elements of the vector by one\n/// position in the right direction. The last element of the vector will be moved to\n/// the starting position in the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector by performing the above operation\n/// then return true else return false.\n/// If the given vector is empty then return true.\n/// Note: The given vector is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3, 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations, non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3, 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing order for the given\n/// vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n    let mut sorted_arr = arr.clone();\n    for i in 0..arr.len() {\n        if sorted_arr[i] > sorted_arr[i+1] {\n            sorted_arr[i] = sorted_arr[i+1];\n            sorted_arr[i+1] = sorted_arr[i];\n        }\n    }\n    sorted_arr.len() == arr.len()"], ["/// In this problem, you will implement a function that takes two vectors of numbers,\n/// and determines whether it is possible to perform an exchange of elements\n/// between them to make lst1 a vector of only even numbers.\n/// There is no limit on the number of exchanged elements between lst1 and lst2.\n/// If it is possible to exchange elements between the lst1 and lst2 to make\n/// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return \"NO\".\n/// For example:\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n/// String::from(\"YES\")\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n/// String::from(\"NO\")\n/// It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut result = String::new();\n    for i in 0..lst1.len() {\n        if i == 0 {\n            result.push_str(\"YES\");\n        } else {\n            result.push_str(\"NO\");\n        }\n    }\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\"YES\");\n    result.push_str(\""], ["use std::collections::HashMap;\n\n/// Given a string representing a space separated lowercase letters, return a HashMap\n/// of the letter with the most repetition and containing the corresponding count.\n/// If several letters have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut hist = HashMap::new();\n    for c in test.chars() {\n        if c == ' ' {\n            hist.insert(c, 1);\n        } else {\n            hist.insert(c, 1);\n        }\n    }\n    hist"], ["/// Task\n/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n/// then check if the result string is palindrome.\n/// A string is called palindrome if it reads the same backward as forward.\n/// You should return a tuple containing the result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n    let mut result = String::new();\n    for c in &c {\n        if s.char_at(c) == s.char_at(c) {\n            result.push_str(s.char_at(c));\n        } else {\n            result.push_str(s.char_at(c));\n        }\n    }\n    result.push_str(s.char_at(c));\n    (result, true)"], ["/// Given a vector of strings, where each string consists of only digits, return a vector.\n/// Each element i of the output should be \"the number of odd elements in the\n/// string i of the input.\" where all the i's should be replaced by the number\n/// of odd digits in the i'th string of the input.\n/// >>> odd_count(vec![String::from(\"1234567\")])\n/// vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n/// >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n/// vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n    let mut output = Vec::new();\n    for i in 0..lst.len() {\n        if i % 2 == 0 {\n            output.push(String::from(lst[i]));\n        } else {\n            output.push(String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\"));\n        }\n    }\n    output"], ["/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n/// of nums.\n/// Example\n/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n/// 1\n/// >>> minSubArraySum(vec![-1, -2, -3])\n/// -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for num in nums {\n        sum += num;\n    }\n    sum"], ["/// You are given a rectangular grid of wells. Each row represents a single well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well has a corresponding bucket that can be used to extract water from it, \n/// and all buckets have the same capacity.\n/// Your task is to use the buckets to empty the wells.\n/// Output the number of times you need to lower the buckets.\n/// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for (i, (row, bucket)) in grid.iter().enumerate() {\n        for (j, (col, unit)) in bucket.iter().enumerate() {\n            if capacity <= unit {\n                result = result + 1;\n            }\n        }\n    }\n    result"], ["/// In this Kata, you have to sort a vector of non-negative integers according to\n/// number of ones in their binary representation in ascending order.\n/// For similar number of ones, sort based on decimal value.\n/// It must be implemented like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n/// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n/// >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![];\n    for i in arr.iter() {\n        if i > 0 {\n            sorted.push(i);\n        }\n    }\n    sorted.sort();\n    sorted"], ["/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    for c in s.chars() {\n        if c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' {\n            continue;\n        }\n        words.push(String::from(c));\n    }\n    words.sort_by(|a, b| a.len() - b.len());\n    words.into_iter().map(|w| w.to_owned()).collect()"], ["/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let mut vowels = Vec::new();\n    for c in word.chars() {\n        if c.is_vowel() {\n            vowels.push(c);\n        }\n    }\n    if vowels.len() == 0 {\n        return String::from(\"\");\n    }\n    let mut closest_vowel = String::from(\"\");\n    for vowel in vowels {\n        if vowel == closest_vowel {\n            return String::from(\"\");\n        }\n        closest_vowel = vowel;\n    }\n    closest_vowel"], ["/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n    let mut result = String::new();\n    for s in lst {\n        match s {\n            String::from(s) => {\n                if s == \"(\" || s == \") \" {\n                    result = result.replace(s, \"(\");\n                } else {\n                    result = result.replace(s, \"(\");\n                }\n            }\n            String::from(s) => {\n                if s == \"(\" || s == \") \" {\n                    result = result.replace(s, \"(\");\n                } else {\n                    result = result.replace(s, \"(\");\n                }\n            }\n            String::from(s) => {\n                if s == \"(\" || s == \") \" {\n                    result = result.replace(s, \"(\");\n                } else {\n                    result = result.replace(s, \"(\");\n                }\n            }\n            String::from(s) => {\n                if s == \"(\" || s == \") \" {\n                    result = result.replace(s, \"(\");\n                } else {\n                    result = result.replace(s, \"(\");\n                }\n            }\n            String::from(s) => {\n                if s == \"(\" || s == \") \" {\n                    result ="], ["/// Given a vector arr of integers and a positive integer k, return a sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector will be in the range of [1, 1000].\n/// 2. The elements in the vector will be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut result = vec![];\n    for i in 0..k {\n        let mut max = 0;\n        for j in 0..arr.len() {\n            if arr[j] > max {\n                max = arr[j];\n            }\n        }\n        result.push(max);\n    }\n    result"], ["/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n/// Examples\n/// >>> solution(vec![5, 8, 7, 1])\n/// 12\n/// >>> solution(vec![3, 3, 3, 3, 3])\n/// 9\n/// >>> solution(vec![30, 13, 24, 321])\n/// 0\nfn solution(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in 0..lst.len() {\n        sum += lst[i];\n    }\n    sum"], ["/// Given a non-empty vector of integers arr and an integer k, return\n/// the sum of the elements with at most two digits from the first k elements of arr.\n/// Example:\n/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n/// 24\n/// Constraints:\n/// 1. 1 <= len(arr) <= 100\n/// 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    let mut sum = 0;\n    for i in 0..k {\n        sum += arr[i];\n    }\n    sum"], ["/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n/// as follows: start with any positive integer n. Then each term is obtained from the \n/// previous term as follows: if the previous term is even, the next term is one half of \n/// the previous term. If the previous term is odd, the next term is 3 times the previous\n/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n/// 2. returned vector sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n/// >>> get_odd_collatz(5)\n/// vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut collatz = Vec::new();\n    collatz.push(n);\n    collatz.sort_by(|a, b| a - b);\n    collatz.reverse();\n    collatz"], ["/// You have to write a function which validates a given date string and\n/// returns true if the date is valid otherwise false.\n/// The date is valid if all of the following rules are satisfied:\n/// 1. The date string is not empty.\n/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n/// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    date.is_empty() ||\n        date.len() == 10 &&\n        date.chars().all(|c| c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9')"], ["/// Given a vector of numbers, return whether or not they are sorted\n/// in ascending order. If vector has more than 1 duplicate of the same\n/// number, return false. Assume no negative numbers and only integers.\n/// Examples\n/// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = Vec::new();\n    for i in 0..lst.len() {\n        if i == 0 {\n            sorted.push(lst[i]);\n        } else {\n            sorted.push(lst[i] + 1);\n        }\n    }\n    sorted.sort_unstable();\n    true"], ["/// You are given two intervals,\n/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed which means that the interval (start, end)\n/// includes both start and end.\n/// For each given interval, it is assumed that its start is less or equal its end.\n/// Your task is to determine whether the length of intersection of these two \n/// intervals is a prime number.\n/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n/// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let mut output = String::new();\n    output.push_str(\"intersection of \");\n    output.push_str(interval1.0);\n    output.push_str(\" and \");\n    output.push_str(interval2.0);\n    output.push_str(\" is \");\n    output.push_str(interval1.1);\n    output.push_str(\" and \");\n    output.push_str(interval2.1);\n    output.push_str(\" is \");\n    output.push_str(interval1.2);\n    output.push_str(\" and \");\n    output.push_str(interval2.2);\n    output.push_str(\" is \");\n    output.push_str(interval1.3);\n    output.push_str(\" and \");\n    output.push_str(interval2.3);\n    output.push_str(\" is \");\n    output.push_str("], ["/// You are given a vector arr of integers and you need to return\n/// sum of magnitudes of integers multiplied by product of all signs\n/// of each number in the vector, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n/// >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut result = 0;\n    for i in arr.iter() {\n        if i == 0 {\n            result = result + 1;\n        } else {\n            result = result * 1;\n        }\n    }\n    result"], ["/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n/// each cell of the grid contains a value. Every integer in the range [1, N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You have to find the minimum path of length k in the grid. You can start\n/// from any cell, and in each step you can move to any of the neighbor cells,\n/// in other words, you can go to cells which share an edge with you current\n/// cell.\n/// Please note that a path of length k means visiting exactly k cells (not\n/// necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length k) is considered less than a path B (of length k) if\n/// after making the ordered vectors of the values on the cells that A and B go\n/// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed that the answer is unique.\n/// Return an ordered vector of the values on the cells that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let mut path = vec![];\n    for (i, v) in grid.iter().enumerate() {\n        let mut path_i = vec![];\n        for (j, v) in v.iter().enumerate() {\n            path_i"], ["/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return a vector of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(3)\n/// vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n    let mut v = vec![1, 3, 2, 8];\n    for i in 1..n {\n        v.push(i);\n    }\n    v"], ["/// Given a positive integer n, return the product of the odd digits.\n/// Return 0 if all digits are even.\n/// For example:\n/// >>> digits(1)\n/// 1\n/// >>> digits(4)\n/// 0\n/// >>> digits(235)\n/// 15\nfn digits(n: isize) -> isize {\n    n.to_u64()"], ["/// Create a function that takes a string as input which contains only square brackets.\n/// The function should return true if and only if there is a valid subsequence of brackets \n/// where at least one bracket in the subsequence is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n/// false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"[[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\nfn is_nested(string: String) -> bool {\n    string.is_subsequence_of([]).is_true()"], ["/// You are given a vector of numbers.\n/// You need to return the sum of squared numbers in the given vector,\n/// round each element in the vector to the upper int(Ceiling) first.\n/// Examples:\n/// >>> lst(vec![1.0, 2.0, 3.0])\n/// 14\n/// >>> lst(vec![1.0, 4.0, 9.0])\n/// 98\n/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n/// 84\n/// >>> lst(vec![1.4, 4.2, 0.0])\n/// 29\n/// >>> lst(vec![-2.4, 1.0, 1.0])\n/// 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n    let mut sum = 0;\n    for x in lst {\n        sum += x * x;\n    }\n    sum"], ["/// Create a function that returns true if the last character\n/// of a given string is an alphabetical character and is not\n/// a part of a word, and false otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n    let mut last_char = txt.chars().nth(txt.len() - 1).unwrap();\n    let mut last_char_is_letter = false;\n    for char in txt.chars() {\n        if char == last_char {\n            last_char_is_letter = true;\n            break;\n        }\n    }\n    last_char_is_letter"], ["/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let mut result = 0;\n    for i in arr.iter() {\n        if i == arr.len() {\n            result = result + 1;\n        } else {\n            result = result + i;\n        }\n    }\n    result"], ["/// Create a function that returns a tuple (a, b), where 'a' is\n/// the largest of negative integers, and 'b' is the smallest\n/// of positive integers in a vector.\n/// If there is no negative or positive integers, return them as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = None;\n    let mut largest = None;\n    for i in 0..lst.len() {\n        if lst[i] < smallest {\n            smallest = lst[i];\n        } else if lst[i] > largest {\n            largest = lst[i];\n        }\n    }\n    (largest, None)"], ["/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n/// Example\n/// >>> is_equal_to_sum_even(4)\n/// false\n/// >>> is_equal_to_sum_even(6)\n/// false\n/// >>> is_equal_to_sum_even(8)\n/// true\nfn is_equal_to_sum_even(n: isize) -> bool {\n    n % 2 == 0"], ["/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>> special_factorial(4)\n/// 288\n/// The function will receive an integer as input and should return the special\n/// factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 1;\n    }\n    if n == 3 {\n        return 1;\n    }\n    if n == 4 {\n        return 1;\n    }\n    if n == 5 {\n        return 1;\n    }\n    if n == 6 {\n        return 1;\n    }\n    if n == 7 {\n        return 1;\n    }\n    if n == 8 {\n        return 1;\n    }\n    if n == 9 {\n        return 1;\n    }\n    if n == 10 {\n        return 1;\n    }\n    if n == 11 {\n        return 1;\n    }\n    if n == 12 {\n        return 1;\n    }\n    if n == 13 {\n        return 1;\n    }\n    if n == 14 {\n        return 1;\n    }\n    if n == 15 {\n        return 1;\n    }\n    if n == 16 {\n        return 1;\n    }\n    if n == 17 {\n        return 1;\n    }\n    if n == 18 {\n        return 1;\n    }\n    if n == 19 {\n        return 1;\n    }\n    if n == 20 {\n        return 1;\n    }\n    if n == 21 {\n        return 1;\n    }\n    if n == 22 {\n        return 1;\n"], ["/// Given a string text, replace all spaces in it with underscores, \n/// and if a string has more than 2 consecutive spaces, \n/// then replace all consecutive spaces with - \n/// >>> fix_spaces(String::from(\" Example\"))\n/// String::from(\"Example\")\n/// >>> fix_spaces(String::from(\" Example 1\"))\n/// String::from(\"Example_1\")\n/// >>> fix_spaces(String::from(\" Example 2\"))\n/// String::from(\"_Example_2\")\n/// >>> fix_spaces(String::from(\" Example 3\"))\n/// String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n    let mut result = text;\n    for c in text.chars() {\n        match c {\n            ' ' => result.push_str(' '),\n            _ => result.push_str(c),\n        }\n    }\n    result"], ["/// Create a function which takes a string representing a file's name, and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n/// A file's name is considered to be valid if and only if all the following conditions \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The substring before the dot should not be empty, and it starts with a letter from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n/// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n    let mut file_name_check = file_name.to_string();\n    file_name_check.remove_prefix(1);\n    file_name_check.remove_suffix(1);\n    file_name_check.remove_prefix(2);\n    file_name_check.remove_suffix(2);\n    file_name_check.remove_prefix(3);\n    file_name_check.remove_suffix(3);\n    file_name_check.remove_prefix(4);\n    file_name_check.remove_suffix(4);\n    file_name_check.remove_prefix(5);\n    file_name_check.remove_suffix(5);\n    file_name_check.remove_prefix(6);\n    file_name_check.remove_suffix(6);\n    file_name_check.remove_prefix(7);\n    file_name_check.remove_suffix(7);\n    file_name_check.remove_prefix(8);\n    file_name_check.remove_suffix(8);\n    file_name_check.remove_prefix("], ["/// \"\n/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n/// Examples:\n/// >>> lst\n/// vec![1, 2, 3]\n/// >>> lst\n/// vec![]\n/// >>> lst\n/// vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in 0..lst.len() {\n        if i % 3 == 0 && i % 4 == 0 {\n            sum += lst[i];\n        } else {\n            sum += lst[i] * lst[i];\n        }\n    }\n    sum"], ["/// You are given a string representing a sentence,\n/// the sentence contains some words separated by a space,\n/// and you have to return a string that contains the words from the original sentence,\n/// whose lengths are prime numbers,\n/// the order of the words in the new string should be the same as the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n    let mut result = String::new();\n    for word in sentence.chars() {\n        let len = word.len();\n        if len == 1 {\n            result.push_str(word);\n        } else {\n            result.push_str(word.to_string());\n        }\n    }\n    result"], ["/// Your task is to implement a function that will simplify the expression\n/// x * n. The function returns true if x * n evaluates to a whole number and false\n/// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n/// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n/// >>> simplify(String::from(\"1/5\"), String::from(\"5/1\"))\n/// true\n/// >>> simplify(String::from(\"1/6\"), String::from(\"2/1\"))\n/// false\n/// >>> simplify(String::from(\"7/10\"), String::from(\"10/2\"))\n/// false\nfn simplify(x: String, n: String) -> bool {\n    // Check if x and n are valid fractions\n    if x.is_empty() || n.is_empty() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n are valid fractions\n    if x.len() != n.len() {\n        return false;\n    }\n\n    // Check if x and n"], ["/// Write a function which sorts the given vector of integers\n/// in ascending order according to the sum of their digits.\n/// Note: if there are several items with similar sum of their digits,\n/// order them based on their index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut sorted = vec![];\n    for num in nums {\n        let mut sum = 0;\n        for i in 0..num.len() {\n            sum += num.as_int();\n        }\n        sorted.push(sum);\n    }\n    sorted"], ["/// Write a function that takes a vector of numbers as input and returns \n/// the number of elements in the vector that are greater than 10 and both \n/// first and last digits of a number are odd (1, 3, 5, 7, 9).\n/// For example:\n/// >>> specialFilter(vec![15, -73, 14, -15])\n/// 1\n/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n/// 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n    let mut result = 0;\n    for num in nums {\n        if num > 10 && num.is_odd() {\n            result += 1;\n        }\n    }\n    result"], ["/// You are given a positive integer n. You have to create an integer vector a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// >>> get_max_triples(5)\n/// 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n    let mut a = [0; n];\n    for i in 1..n {\n        let mut b = [0; i];\n        for j in 1..i {\n            let mut c = [0; j];\n            for k in 1..j {\n                let mut d = [0; k];\n                for m in 1..k {\n                    let mut e = [0; m];\n                    for n in 1..m {\n                        let mut f = [0; n];\n                        for g in 1..n {\n                            let mut g = [0; g];\n                            for h in 1..g {\n                                let mut h = [0; h];\n                                for i in 1..h {\n                                    let mut i = [0; i];\n                                    for j in 1..i {\n                                        let mut j = [0; j];\n                                        for k in 1..j {\n                                            let mut k = [0; k];\n                                            for m in 1..k {\n                                                let mut m = [0; m];\n                                                for n in 1..m {\n                                                    let mut n = [0; n];\n                                                    for p in 1..n {\n                                                        let mut p = [0; p];\n                                                "], ["/// Write a function that accepts a vector of strings as a parameter,\n/// deletes the strings that have odd lengths from it,\n/// and returns the resulted vector with a sorted order,\n/// The vector is always a vector of strings and never a vector of numbers,\n/// and it may contain duplicates.\n/// The order of the vector should be ascending by length of each word, and you\n/// should return the vector sorted by that rule.\n/// If two words have the same length, sort the vector alphabetically.\n/// The function should return a vector of strings in sorted order.\n/// You may assume that all words will have the same length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n/// vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut result = vec![];\n    for word in lst {\n        if word.len() % 2 == 0 {\n            result.push(word);\n        } else {\n            result.push(word.clone());\n        }\n    }\n    result"], ["/// A simple program which should return the value of x if n is \n/// a prime number and should return the value of y otherwise.\n/// Examples:\n/// >>> x_or_y(7, 34, 12)\n/// 34\n/// >>> x_or_y(15, 8, 5)\n/// 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    if n == 1 {\n        y\n    } else {\n        if n == x {\n            y\n        } else {\n            x_or_y(n - x, n - y, n - x)\n        }\n    }"], ["/// Given a vector of numbers, return the sum of squares of the numbers\n/// in the vector that are odd. Ignore numbers that are negative or not integers.\n/// >>> double_the_difference(vec![1, 3, 2, 0])\n/// 10\n/// >>> double_the_difference(vec![-1, -2, 0])\n/// 0\n/// >>> double_the_difference(vec![9, -2])\n/// 81\n/// >>> double_the_difference(vec![0])\n/// 0\n/// If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n    let mut i = 0;\n    for x in lst {\n        if x == 0 {\n            i += 1;\n        } else {\n            i += x;\n        }\n    }\n    i"], ["/// I think we all remember that feeling when the result of some long-awaited\n/// event is finally known. The feelings and thoughts you have at that moment are\n/// definitely worth noting down and comparing.\n/// Your task is to determine if a person correctly guessed the results of a number of matches.\n/// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n/// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n/// example:\n/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n/// vec![0, 0, 0, 0, 3, 3]\n/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n/// vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter().map(|(score, guess)| {\n        if score == guess {\n            score\n        } else {\n            guess - score\n        }\n    }).collect()"], ["/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut result = String::new();\n    for extension in extensions {\n        let extension_name = extension.to_string();\n        if extension_name == class_name {\n            result = result.replace(extension_name, \"\");\n        }\n    }\n    result"], ["/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n/// >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n/// false\n/// >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n/// true\n/// >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n/// false\n/// >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n/// true\n/// >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n/// false\n/// >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n/// true\nfn cycpattern_check(a: String, b: String) -> bool {\n    let mut result = false;\n    for c in a.chars() {\n        if c == b.chars()[0] {\n            result = true;\n            break;\n        }\n    }\n    result"], ["/// Given an integer. return a tuple that has the number of even and odd digits respectively.\n/// Example:\n/// >>> even_odd_count(-12)\n/// (1, 1)\n/// >>> even_odd_count(123)\n/// (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_odd = 0;\n    for i in 0..num {\n        if i % 2 == 0 {\n            even_odd += 1;\n        }\n    }\n    (even_odd, num)"], ["/// Given a positive integer, obtain its roman numeral equivalent as a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n/// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>> int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n/// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n    match number {\n        isize::MINUS => \"minus\",\n        isize::MINUS_EQUALS => \"minus_equals\",\n        isize::MINUS_MINUS => \"minus_minus\",\n        isize::MINUS_MINUS_EQUALS => \"minus_minus_equals\",\n        isize::MINUS_MINUS_MINUS => \"minus_minus_minus\",\n        isize::MINUS_MINUS_MINUS_EQUALS => \"minus_minus_minus_equals\",\n        isize::MINUS_MINUS_MINUS_MINUS => \"minus_minus_minus_minus\",\n        isize::MINUS_MINUS_MINUS_MINUS_EQUALS => \"minus_minus_minus_minus_equals\",\n        isize::MINUS_MINUS_MINUS_MINUS_MINUS => \"minus_minus_minus_minus_minus\",\n        isize::MINUS_MINUS_MINUS_MINUS_MINUS_EQUALS => \"minus_minus_minus_minus_minus_equals\",\n        isize::MINUS_MINUS_MINUS_MINUS_MINUS_MINUS => \"minus_minus_minus_minus_minus_minus\",\n        isize::MINUS_MINUS_MINUS_MINUS_MINUS_MINUS_EQUALS => \"minus_minus_minus_minus_minus_minus_equals\",\n        isize::MINUS_MINUS_MINUS_MINUS_MINUS_MINUS_MINUS => \"minus_minus_minus_minus_minus_minus"], ["/// Given the lengths of the three sides of a triangle. Return true if the three\n/// sides form a right-angled triangle, false otherwise.\n/// A right-angled triangle is a triangle in which one angle is right angle or \n/// 90 degree.\n/// Example:\n/// >>> right_angle_triangle(3, 4, 5)\n/// true\n/// >>> right_angle_triangle(1, 2, 3)\n/// false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    a == b && b == c && c == a"], ["/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by(|a, b| a.len() > b.len())"], ["/// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n/// you should return a vector of [ total number of eaten carrots after your meals,\n/// the number of carrots left after your meals ]\n/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n/// >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n/// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n/// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let mut total = number;\n    let mut remaining = need;\n    let mut eaten = 0;\n    while remaining > 0 {\n        let mut remaining_eaten = 0;\n        while remaining_eaten < number {\n            remaining_eaten += 1;\n            remaining -= 1;\n        }\n        remaining_eaten += 1;\n        remaining -= 1;\n        eaten += 1;\n        remaining -= 1;\n        remaining_eaten += 1;\n        remaining -= 1;\n        remaining_eaten += 1;\n        remaining -= 1;\n        remaining_eaten += 1;\n        remaining -= 1;\n       "], ["/// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n/// the second vector is a vector of integers. Use the two given vectors to build the algebric \n/// expression and return the evaluation of this expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// vector = [2, 3, 4, 5]\n/// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator vector is equal to the length of operand vector minus one.\n/// Operand is a vector of of non-negative integers.\n/// Operator vector has at least one operator, and operand vector has at least two operands.\nfn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = 0;\n    for op in operator {\n        let mut op_vec = op.clone();\n        for op_i in op_vec.iter().rev() {\n            op_vec.push(op_i);\n        }\n        let mut op_vec = op_vec.clone();\n        for op_i in op_vec.iter().rev() {\n            op_vec.push(op_i);\n        }\n        let mut op_vec = op_vec.clone();\n        for op_i in op_vec.iter().rev() {\n            op_vec.push(op_i);\n        }\n        let mut op_vec = op_vec.clone();\n        for op_i in op_vec.iter().rev() {\n            op_vec.push(op_i);\n        }\n        let mut op_vec = op_vec.clone();\n        for op_i in op_vec.iter().rev() {\n            op_vec.push(op_i);\n        }\n        let mut op_vec = op_vec.clone();\n        for op_i in op_vec.iter().rev() {"], ["/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n    let mut result = s.to_owned();\n    for c in s.chars() {\n        if c.is_upper() {\n            result.push_str(c.to_owned());\n        } else {\n            result.push_str(c.to_owned());\n        }\n    }\n    result.reverse().to_owned()"], ["/// Given a string 'text', return its md5 hash equivalent string.\n/// If 'text' is an empty string, return None.\n/// >>> string_to_md5(String::from(\"Hello world\"))\n/// Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n    let mut md5 = MD5::new();\n    md5.update(text.as_bytes());\n    md5.finalize()"], ["/// Given two positive integers a and b, return the even digits between a\n/// and b, in ascending order.\n/// For example:\n/// >>> generate_integers(2, 8)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(8, 2)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(10, 14)\n/// Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    for i in 0..a {\n        for j in 0..b {\n            if i < j {\n                result.push(i);\n                result.push(j);\n            }\n        }\n    }\n    result"]]